schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
"""
A `AbuseReportID` is a global ID. It is encoded as a string.

An example `AbuseReportID` is: `"gid://gitlab/AbuseReport/1"`.
"""
scalar AbuseReportID
"""
A `AchievementsAchievementID` is a global ID. It is encoded as a string.

An example `AchievementsAchievementID` is: `"gid://gitlab/Achievements::Achievement/1"`.
"""
scalar AchievementsAchievementID
"""
A `AchievementsUserAchievementID` is a global ID. It is encoded as a string.

An example `AchievementsUserAchievementID` is: `"gid://gitlab/Achievements::UserAchievement/1"`.
"""
scalar AchievementsUserAchievementID
"""
A `AlertManagementAlertID` is a global ID. It is encoded as a string.

An example `AlertManagementAlertID` is: `"gid://gitlab/AlertManagement::Alert/1"`.
"""
scalar AlertManagementAlertID
"""
A `AlertManagementHttpIntegrationID` is a global ID. It is encoded as a string.

An example `AlertManagementHttpIntegrationID` is: `"gid://gitlab/AlertManagement::HttpIntegration/1"`.
"""
scalar AlertManagementHttpIntegrationID
"""
A `AnalyticsCycleAnalyticsStageID` is a global ID. It is encoded as a string.

An example `AnalyticsCycleAnalyticsStageID` is: `"gid://gitlab/Analytics::CycleAnalytics::Stage/1"`.
"""
scalar AnalyticsCycleAnalyticsStageID
"""
A `AnalyticsCycleAnalyticsValueStreamID` is a global ID. It is encoded as a string.

An example `AnalyticsCycleAnalyticsValueStreamID` is: `"gid://gitlab/Analytics::CycleAnalytics::ValueStream/1"`.
"""
scalar AnalyticsCycleAnalyticsValueStreamID
"""
A `AntiAbuseReportsLabelID` is a global ID. It is encoded as a string.

An example `AntiAbuseReportsLabelID` is: `"gid://gitlab/AntiAbuse::Reports::Label/1"`.
"""
scalar AntiAbuseReportsLabelID
"""
A `AntiAbuseReportsNoteID` is a global ID. It is encoded as a string.

An example `AntiAbuseReportsNoteID` is: `"gid://gitlab/AntiAbuse::Reports::Note/1"`.
"""
scalar AntiAbuseReportsNoteID
"""
A `AwardableID` is a global ID. It is encoded as a string.

An example `AwardableID` is: `"gid://gitlab/Awardable/1"`.
"""
scalar AwardableID
"Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."
scalar BigInt
"""
A `BoardID` is a global ID. It is encoded as a string.

An example `BoardID` is: `"gid://gitlab/Board/1"`.
"""
scalar BoardID
"""
A `CiBuildID` is a global ID. It is encoded as a string.

An example `CiBuildID` is: `"gid://gitlab/Ci::Build/1"`.
"""
scalar CiBuildID
"""
A `CiCatalogResourceID` is a global ID. It is encoded as a string.

An example `CiCatalogResourceID` is: `"gid://gitlab/Ci::Catalog::Resource/1"`.
"""
scalar CiCatalogResourceID
"""
A `CiCatalogResourcesComponentID` is a global ID. It is encoded as a string.

An example `CiCatalogResourcesComponentID` is: `"gid://gitlab/Ci::Catalog::Resources::Component/1"`.
"""
scalar CiCatalogResourcesComponentID
"""
A `CiCatalogResourcesVersionID` is a global ID. It is encoded as a string.

An example `CiCatalogResourcesVersionID` is: `"gid://gitlab/Ci::Catalog::Resources::Version/1"`.
"""
scalar CiCatalogResourcesVersionID
"Value for a CI input. Can be a string, array, number, or boolean."
scalar CiInputsValue
"""
A `CiJobArtifactID` is a global ID. It is encoded as a string.

An example `CiJobArtifactID` is: `"gid://gitlab/Ci::JobArtifact/1"`.
"""
scalar CiJobArtifactID
"""
A `CiPipelineID` is a global ID. It is encoded as a string.

An example `CiPipelineID` is: `"gid://gitlab/Ci::Pipeline/1"`.
"""
scalar CiPipelineID
"""
A `CiPipelineScheduleID` is a global ID. It is encoded as a string.

An example `CiPipelineScheduleID` is: `"gid://gitlab/Ci::PipelineSchedule/1"`.
"""
scalar CiPipelineScheduleID
"""
A `CiPipelineScheduleVariableID` is a global ID. It is encoded as a string.

An example `CiPipelineScheduleVariableID` is: `"gid://gitlab/Ci::PipelineScheduleVariable/1"`.
"""
scalar CiPipelineScheduleVariableID
"""
A `CiProcessableID` is a global ID. It is encoded as a string.

An example `CiProcessableID` is: `"gid://gitlab/Ci::Processable/1"`.
"""
scalar CiProcessableID
"""
A `CiRunnerID` is a global ID. It is encoded as a string.

An example `CiRunnerID` is: `"gid://gitlab/Ci::Runner/1"`.
"""
scalar CiRunnerID
"""
A `CiRunnerManagerID` is a global ID. It is encoded as a string.

An example `CiRunnerManagerID` is: `"gid://gitlab/Ci::RunnerManager/1"`.
"""
scalar CiRunnerManagerID
"""
A `CiStageID` is a global ID. It is encoded as a string.

An example `CiStageID` is: `"gid://gitlab/Ci::Stage/1"`.
"""
scalar CiStageID
"""
A `CiTriggerID` is a global ID. It is encoded as a string.

An example `CiTriggerID` is: `"gid://gitlab/Ci::Trigger/1"`.
"""
scalar CiTriggerID
"""
A `ClustersAgentID` is a global ID. It is encoded as a string.

An example `ClustersAgentID` is: `"gid://gitlab/Clusters::Agent/1"`.
"""
scalar ClustersAgentID
"""
A `ClustersAgentTokenID` is a global ID. It is encoded as a string.

An example `ClustersAgentTokenID` is: `"gid://gitlab/Clusters::AgentToken/1"`.
"""
scalar ClustersAgentTokenID
"""
A `ClustersClusterID` is a global ID. It is encoded as a string.

An example `ClustersClusterID` is: `"gid://gitlab/Clusters::Cluster/1"`.
"""
scalar ClustersClusterID
"""
Color represented as a hex code or named color.

For example: "#fefefe".
"""
scalar Color
"""
A `ContainerRegistryProtectionRuleID` is a global ID. It is encoded as a string.

An example `ContainerRegistryProtectionRuleID` is: `"gid://gitlab/ContainerRegistry::Protection::Rule/1"`.
"""
scalar ContainerRegistryProtectionRuleID
"""
A `ContainerRegistryProtectionTagRuleID` is a global ID. It is encoded as a string.

An example `ContainerRegistryProtectionTagRuleID` is: `"gid://gitlab/ContainerRegistry::Protection::TagRule/1"`.
"""
scalar ContainerRegistryProtectionTagRuleID
"""
A `ContainerRepositoryID` is a global ID. It is encoded as a string.

An example `ContainerRepositoryID` is: `"gid://gitlab/ContainerRepository/1"`.
"""
scalar ContainerRepositoryID
"""
A `CustomEmojiID` is a global ID. It is encoded as a string.

An example `CustomEmojiID` is: `"gid://gitlab/CustomEmoji/1"`.
"""
scalar CustomEmojiID
"""
A `CustomerRelationsContactID` is a global ID. It is encoded as a string.

An example `CustomerRelationsContactID` is: `"gid://gitlab/CustomerRelations::Contact/1"`.
"""
scalar CustomerRelationsContactID
"""
A `CustomerRelationsOrganizationID` is a global ID. It is encoded as a string.

An example `CustomerRelationsOrganizationID` is: `"gid://gitlab/CustomerRelations::Organization/1"`.
"""
scalar CustomerRelationsOrganizationID
"Date represented in ISO 8601"
scalar Date
"""
A `DependencyProxyManifestID` is a global ID. It is encoded as a string.

An example `DependencyProxyManifestID` is: `"gid://gitlab/DependencyProxy::Manifest/1"`.
"""
scalar DependencyProxyManifestID
"""
A `DeployKeyID` is a global ID. It is encoded as a string.

An example `DeployKeyID` is: `"gid://gitlab/DeployKey/1"`.
"""
scalar DeployKeyID
"""
A `DescriptionVersionID` is a global ID. It is encoded as a string.

An example `DescriptionVersionID` is: `"gid://gitlab/DescriptionVersion/1"`.
"""
scalar DescriptionVersionID
"""
A `DesignManagementDesignAtVersionID` is a global ID. It is encoded as a string.

An example `DesignManagementDesignAtVersionID` is: `"gid://gitlab/DesignManagement::DesignAtVersion/1"`.
"""
scalar DesignManagementDesignAtVersionID
"""
A `DesignManagementDesignID` is a global ID. It is encoded as a string.

An example `DesignManagementDesignID` is: `"gid://gitlab/DesignManagement::Design/1"`.
"""
scalar DesignManagementDesignID
"""
A `DesignManagementVersionID` is a global ID. It is encoded as a string.

An example `DesignManagementVersionID` is: `"gid://gitlab/DesignManagement::Version/1"`.
"""
scalar DesignManagementVersionID
"""
A `DiffNoteID` is a global ID. It is encoded as a string.

An example `DiffNoteID` is: `"gid://gitlab/DiffNote/1"`.
"""
scalar DiffNoteID
"""
A `DiscussionID` is a global ID. It is encoded as a string.

An example `DiscussionID` is: `"gid://gitlab/Discussion/1"`.
"""
scalar DiscussionID
"""
Duration between two instants, represented as a fractional number of seconds.

For example: 12.3334
"""
scalar Duration
"""
A `EmailID` is a global ID. It is encoded as a string.

An example `EmailID` is: `"gid://gitlab/Email/1"`.
"""
scalar EmailID
"""
A `EnvironmentID` is a global ID. It is encoded as a string.

An example `EnvironmentID` is: `"gid://gitlab/Environment/1"`.
"""
scalar EnvironmentID
"""
A `GitlabErrorTrackingDetailedErrorID` is a global ID. It is encoded as a string.

An example `GitlabErrorTrackingDetailedErrorID` is: `"gid://gitlab/Gitlab::ErrorTracking::DetailedError/1"`.
"""
scalar GitlabErrorTrackingDetailedErrorID
"""
A global identifier.

A global identifier represents an object uniquely across the application.
An example of a global identifier is `"gid://gitlab/User/1"`.

`gid://gitlab` stands for the root name.
`User` is the name of the ActiveRecord class of the record.
`1` is the record id as per the id in the db table.

Global identifiers are encoded as strings.
"""
scalar GlobalID
"""
A `GroupID` is a global ID. It is encoded as a string.

An example `GroupID` is: `"gid://gitlab/Group/1"`.
"""
scalar GroupID
"An ISO 8601-encoded date"
scalar ISO8601Date
"An ISO 8601-encoded datetime"
scalar ISO8601DateTime
"""
A `ImportSourceUserID` is a global ID. It is encoded as a string.

An example `ImportSourceUserID` is: `"gid://gitlab/Import::SourceUser/1"`.
"""
scalar ImportSourceUserID
"""
A `IncidentManagementTimelineEventID` is a global ID. It is encoded as a string.

An example `IncidentManagementTimelineEventID` is: `"gid://gitlab/IncidentManagement::TimelineEvent/1"`.
"""
scalar IncidentManagementTimelineEventID
"""
A `IncidentManagementTimelineEventTagID` is a global ID. It is encoded as a string.

An example `IncidentManagementTimelineEventTagID` is: `"gid://gitlab/IncidentManagement::TimelineEventTag/1"`.
"""
scalar IncidentManagementTimelineEventTagID
"""
A `IntegrationsPrometheusID` is a global ID. It is encoded as a string.

An example `IntegrationsPrometheusID` is: `"gid://gitlab/Integrations::Prometheus/1"`.
The older format `"gid://gitlab/PrometheusService/1"` was deprecated in 14.1.
"""
scalar IntegrationsPrometheusID
"""
A `IssuableID` is a global ID. It is encoded as a string.

An example `IssuableID` is: `"gid://gitlab/Issuable/1"`.
"""
scalar IssuableID
"""
A `IssueID` is a global ID. It is encoded as a string.

An example `IssueID` is: `"gid://gitlab/Issue/1"`.
"""
scalar IssueID
"""
A `IssueParentID` is a global ID. It is encoded as a string.

An example `IssueParentID` is: `"gid://gitlab/IssueParent/1"`.
"""
scalar IssueParentID
"Represents untyped JSON"
scalar JSON
"""
A `CommitStatusID` is a global ID. It is encoded as a string.

An example `CommitStatusID` is: `"gid://gitlab/CommitStatus/1"`.
"""
scalar JobID
"""
A `LabelID` is a global ID. It is encoded as a string.

An example `LabelID` is: `"gid://gitlab/Label/1"`.
"""
scalar LabelID
"""
A `ListID` is a global ID. It is encoded as a string.

An example `ListID` is: `"gid://gitlab/List/1"`.
"""
scalar ListID
"""
A `MergeRequestID` is a global ID. It is encoded as a string.

An example `MergeRequestID` is: `"gid://gitlab/MergeRequest/1"`.
"""
scalar MergeRequestID
"""
A `MergeRequestsClosingIssuesID` is a global ID. It is encoded as a string.

An example `MergeRequestsClosingIssuesID` is: `"gid://gitlab/MergeRequestsClosingIssues/1"`.
"""
scalar MergeRequestsClosingIssuesID
"""
A `MilestoneID` is a global ID. It is encoded as a string.

An example `MilestoneID` is: `"gid://gitlab/Milestone/1"`.
"""
scalar MilestoneID
"""
A `MlCandidateID` is a global ID. It is encoded as a string.

An example `MlCandidateID` is: `"gid://gitlab/Ml::Candidate/1"`.
"""
scalar MlCandidateID
"""
A `MlCandidateMetadataID` is a global ID. It is encoded as a string.

An example `MlCandidateMetadataID` is: `"gid://gitlab/Ml::CandidateMetadata/1"`.
"""
scalar MlCandidateMetadataID
"""
A `MlCandidateMetricID` is a global ID. It is encoded as a string.

An example `MlCandidateMetricID` is: `"gid://gitlab/Ml::CandidateMetric/1"`.
"""
scalar MlCandidateMetricID
"""
A `MlCandidateParamID` is a global ID. It is encoded as a string.

An example `MlCandidateParamID` is: `"gid://gitlab/Ml::CandidateParam/1"`.
"""
scalar MlCandidateParamID
"""
A `MlExperimentID` is a global ID. It is encoded as a string.

An example `MlExperimentID` is: `"gid://gitlab/Ml::Experiment/1"`.
"""
scalar MlExperimentID
"""
A `MlModelID` is a global ID. It is encoded as a string.

An example `MlModelID` is: `"gid://gitlab/Ml::Model/1"`.
"""
scalar MlModelID
"""
A `MlModelVersionID` is a global ID. It is encoded as a string.

An example `MlModelVersionID` is: `"gid://gitlab/Ml::ModelVersion/1"`.
"""
scalar MlModelVersionID
"""
A `NamespaceID` is a global ID. It is encoded as a string.

An example `NamespaceID` is: `"gid://gitlab/Namespace/1"`.
"""
scalar NamespaceID
"""
A `NoteID` is a global ID. It is encoded as a string.

An example `NoteID` is: `"gid://gitlab/Note/1"`.
"""
scalar NoteID
"""
A `NoteableID` is a global ID. It is encoded as a string.

An example `NoteableID` is: `"gid://gitlab/Noteable/1"`.
"""
scalar NoteableID
"""
A `OrganizationsOrganizationID` is a global ID. It is encoded as a string.

An example `OrganizationsOrganizationID` is: `"gid://gitlab/Organizations::Organization/1"`.
"""
scalar OrganizationsOrganizationID
"""
A `OrganizationsOrganizationUserID` is a global ID. It is encoded as a string.

An example `OrganizationsOrganizationUserID` is: `"gid://gitlab/Organizations::OrganizationUser/1"`.
"""
scalar OrganizationsOrganizationUserID
"""
A `PackagesConanFileMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesConanFileMetadatumID` is: `"gid://gitlab/Packages::Conan::FileMetadatum/1"`.
"""
scalar PackagesConanFileMetadatumID
"""
A `PackagesConanMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesConanMetadatumID` is: `"gid://gitlab/Packages::Conan::Metadatum/1"`.
"""
scalar PackagesConanMetadatumID
"""
A `PackagesDependencyID` is a global ID. It is encoded as a string.

An example `PackagesDependencyID` is: `"gid://gitlab/Packages::Dependency/1"`.
"""
scalar PackagesDependencyID
"""
A `PackagesDependencyLinkID` is a global ID. It is encoded as a string.

An example `PackagesDependencyLinkID` is: `"gid://gitlab/Packages::DependencyLink/1"`.
"""
scalar PackagesDependencyLinkID
"""
A `PackagesMavenMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesMavenMetadatumID` is: `"gid://gitlab/Packages::Maven::Metadatum/1"`.
"""
scalar PackagesMavenMetadatumID
"""
A `PackagesNugetDependencyLinkMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesNugetDependencyLinkMetadatumID` is: `"gid://gitlab/Packages::Nuget::DependencyLinkMetadatum/1"`.
"""
scalar PackagesNugetDependencyLinkMetadatumID
"""
A `PackagesNugetMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesNugetMetadatumID` is: `"gid://gitlab/Packages::Nuget::Metadatum/1"`.
"""
scalar PackagesNugetMetadatumID
"""
A `PackagesPackageFileID` is a global ID. It is encoded as a string.

An example `PackagesPackageFileID` is: `"gid://gitlab/Packages::PackageFile/1"`.
"""
scalar PackagesPackageFileID
"""
A `PackagesPackageID` is a global ID. It is encoded as a string.

An example `PackagesPackageID` is: `"gid://gitlab/Packages::Package/1"`.
"""
scalar PackagesPackageID
"""
A `PackagesProtectionRuleID` is a global ID. It is encoded as a string.

An example `PackagesProtectionRuleID` is: `"gid://gitlab/Packages::Protection::Rule/1"`.
"""
scalar PackagesProtectionRuleID
"""
A `PackagesPypiMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesPypiMetadatumID` is: `"gid://gitlab/Packages::Pypi::Metadatum/1"`.
"""
scalar PackagesPypiMetadatumID
"""
A `PackagesTerraformModuleMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesTerraformModuleMetadatumID` is: `"gid://gitlab/Packages::TerraformModule::Metadatum/1"`.
"""
scalar PackagesTerraformModuleMetadatumID
"""
A `PagesDeploymentID` is a global ID. It is encoded as a string.

An example `PagesDeploymentID` is: `"gid://gitlab/PagesDeployment/1"`.
"""
scalar PagesDeploymentID
"""
A `ProjectID` is a global ID. It is encoded as a string.

An example `ProjectID` is: `"gid://gitlab/Project/1"`.
"""
scalar ProjectID
"""
A `ProjectImportStateID` is a global ID. It is encoded as a string.

An example `ProjectImportStateID` is: `"gid://gitlab/ProjectImportState/1"`.
"""
scalar ProjectImportStateID
"""
A `ProjectsBranchRuleID` is a global ID. It is encoded as a string.

An example `ProjectsBranchRuleID` is: `"gid://gitlab/Projects::BranchRule/1"`.
"""
scalar ProjectsBranchRuleID
"""
A `ReleaseID` is a global ID. It is encoded as a string.

An example `ReleaseID` is: `"gid://gitlab/Release/1"`.
"""
scalar ReleaseID
"""
A `ReleasesLinkID` is a global ID. It is encoded as a string.

An example `ReleasesLinkID` is: `"gid://gitlab/Releases::Link/1"`.
"""
scalar ReleasesLinkID
"""
A `SnippetID` is a global ID. It is encoded as a string.

An example `SnippetID` is: `"gid://gitlab/Snippet/1"`.
"""
scalar SnippetID
"""
A `SystemNoteMetadataID` is a global ID. It is encoded as a string.

An example `SystemNoteMetadataID` is: `"gid://gitlab/SystemNoteMetadata/1"`.
"""
scalar SystemNoteMetadataID
"""
A `TerraformStateID` is a global ID. It is encoded as a string.

An example `TerraformStateID` is: `"gid://gitlab/Terraform::State/1"`.
"""
scalar TerraformStateID
"""
Time represented in ISO 8601.

For example: "2021-03-09T14:58:50+00:00".

See `https://www.iso.org/iso-8601-date-and-time-format.html`.
"""
scalar Time
"""
A `TimelogID` is a global ID. It is encoded as a string.

An example `TimelogID` is: `"gid://gitlab/Timelog/1"`.
"""
scalar TimelogID
"""
A `TodoID` is a global ID. It is encoded as a string.

An example `TodoID` is: `"gid://gitlab/Todo/1"`.
"""
scalar TodoID
"""
A `TodoableID` is a global ID. It is encoded as a string.

An example `TodoableID` is: `"gid://gitlab/Todoable/1"`.
"""
scalar TodoableID
"A regexp containing patterns sourced from user input"
scalar UntrustedRegexp
scalar Upload
"""
A `UploadID` is a global ID. It is encoded as a string.

An example `UploadID` is: `"gid://gitlab/Upload/1"`.
"""
scalar UploadID
"""
A `UserID` is a global ID. It is encoded as a string.

An example `UserID` is: `"gid://gitlab/User/1"`.
"""
scalar UserID
"""
A `UsersSavedReplyID` is a global ID. It is encoded as a string.

An example `UsersSavedReplyID` is: `"gid://gitlab/Users::SavedReply/1"`.
"""
scalar UsersSavedReplyID
"""
A `WikiPageMetaID` is a global ID. It is encoded as a string.

An example `WikiPageMetaID` is: `"gid://gitlab/WikiPage::Meta/1"`.
"""
scalar WikiPageMetaID
"""
A `WorkItemID` is a global ID. It is encoded as a string.

An example `WorkItemID` is: `"gid://gitlab/WorkItem/1"`.

While we transition from Issues into Work Items this type will temporarily support
`IssueID` like: `"gid://gitlab/Issue/1"`. This behavior will be removed without notice in the future.
"""
scalar WorkItemID
"""
A `WorkItemsParentID` is a global ID. It is encoded as a string.

An example `WorkItemsParentID` is: `"gid://gitlab/WorkItems::Parent/1"`.
"""
scalar WorkItemsParentID
"""
A `WorkItemsRelatedWorkItemLinkID` is a global ID. It is encoded as a string.

An example `WorkItemsRelatedWorkItemLinkID` is: `"gid://gitlab/WorkItems::RelatedWorkItemLink/1"`.
"""
scalar WorkItemsRelatedWorkItemLinkID
"""
A `WorkItemsTypeID` is a global ID. It is encoded as a string.

An example `WorkItemsTypeID` is: `"gid://gitlab/WorkItems::Type/1"`.
"""
scalar WorkItemsTypeID
"An abuse report"
type AbuseReport {
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AbuseReportDiscussionConnection!
  "Global ID of the abuse report."
  id: AbuseReportID!
  "Labels of the abuse report."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AbuseReportLabelConnection
  "All notes on the noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AbuseReportNoteConnection!
}
type AbuseReportDiscussion implements BaseDiscussionInterface & ResolvableInterface {
  "Abuse report which the discussion belongs to."
  abuseReport: AbuseReport
  "Timestamp of the discussion's creation."
  createdAt: Time!
  "ID of the discussion."
  id: DiscussionID!
  "All notes in the discussion."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AbuseReportNoteConnection!
  "ID used to reply to the discussion."
  replyId: DiscussionID!
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
}
"The connection type for AbuseReportDiscussion."
type AbuseReportDiscussionConnection {
  "A list of edges."
  edges: [AbuseReportDiscussionEdge]
  "A list of nodes."
  nodes: [AbuseReportDiscussion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AbuseReportDiscussionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AbuseReportDiscussion
}
type AbuseReportLabel implements LabelInterface {
  "Background color of the label."
  color: String!
  "When the label was created."
  createdAt: Time!
  "Description of the label (Markdown rendered as HTML for caching)."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Global ID of the abuse report label."
  id: AntiAbuseReportsLabelID!
  "Text color of the label."
  textColor: String!
  "Content of the label."
  title: String!
  "When the label was last updated."
  updatedAt: Time!
}
"The connection type for AbuseReportLabel."
type AbuseReportLabelConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [AbuseReportLabelEdge]
  "A list of nodes."
  nodes: [AbuseReportLabel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of AbuseReportLabelCreate."
type AbuseReportLabelCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Label after mutation."
  label: AbuseReportLabel
}
"An edge in a connection."
type AbuseReportLabelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AbuseReportLabel
}
type AbuseReportNote implements BaseNoteInterface & ResolvableInterface {
  "User who wrote the note."
  author: UserCore
  "List of emoji reactions associated with the note."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Content of the note."
  body: String!
  "First line of the note content."
  bodyFirstLineHtml: String!
  "GitLab Flavored Markdown rendering of the content of the note."
  bodyHtml: String
  "Timestamp of the note creation."
  createdAt: Time!
  "Discussion the note is a part of."
  discussion: AbuseReportDiscussion
  "ID of the note."
  id: AntiAbuseReportsNoteID!
  "Timestamp when note was last edited."
  lastEditedAt: Time
  "User who last edited the note."
  lastEditedBy: UserCore
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
  "Timestamp of the note's last activity."
  updatedAt: Time!
  "URL to view the note in the Web UI."
  url: String
}
"The connection type for AbuseReportNote."
type AbuseReportNoteConnection {
  "A list of edges."
  edges: [AbuseReportNoteEdge]
  "A list of nodes."
  nodes: [AbuseReportNote]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AbuseReportNoteEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AbuseReportNote
}
"Represents the access level of a relationship between a User and object that it is related to"
type AccessLevel {
  "Human-readable display name for the access level."
  humanAccess: String
  "Integer number of the access level."
  integerValue: Int
  "Enum string of the the access level."
  stringValue: AccessLevelEnum
}
"Representation of a GitLab deploy key."
type AccessLevelDeployKey {
  "Expiration date of the deploy key."
  expiresAt: Date
  "ID of the deploy key."
  id: ID!
  "Title of the deploy key."
  title: String!
  "User assigned to the deploy key."
  user: AccessLevelUser!
}
"The connection type for AccessLevelDeployKey."
type AccessLevelDeployKeyConnection {
  "A list of edges."
  edges: [AccessLevelDeployKeyEdge]
  "A list of nodes."
  nodes: [AccessLevelDeployKey]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AccessLevelDeployKeyEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AccessLevelDeployKey
}
"Representation of a GitLab user."
type AccessLevelUser {
  "URL of the user's avatar."
  avatarUrl: String
  "ID of the user."
  id: ID!
  """
  Human-readable name of the user.
  Returns `****` if the user is a project bot and the requester does not have permission to view the project.
  """
  name: String!
  "User's public email."
  publicEmail: String
  "Username of the user."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
type Achievement {
  "URL to avatar of the achievement."
  avatarUrl: String
  "Timestamp the achievement was created."
  createdAt: Time!
  "Description or notes for the achievement."
  description: String
  "ID of the achievement."
  id: AchievementsAchievementID!
  "Name of the achievement."
  name: String!
  "Namespace of the achievement."
  namespace: Namespace
  "Timestamp the achievement was last updated."
  updatedAt: Time!
  "Recipients for the achievement. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
}
"The connection type for Achievement."
type AchievementConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [AchievementEdge]
  "A list of nodes."
  nodes: [Achievement]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AchievementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Achievement
}
"Autogenerated return type of AchievementsAward."
type AchievementsAwardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Achievement award."
  userAchievement: UserAchievement
}
"Autogenerated return type of AchievementsCreate."
type AchievementsCreatePayload {
  "Achievement created."
  achievement: Achievement
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of AchievementsDelete."
type AchievementsDeletePayload {
  "Achievement."
  achievement: Achievement
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of AchievementsRevoke."
type AchievementsRevokePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Achievement award."
  userAchievement: UserAchievement
}
"Autogenerated return type of AchievementsUpdate."
type AchievementsUpdatePayload {
  "Achievement."
  achievement: Achievement
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Activity streams associated with a user"
type ActivityStream {
  "Activity from users followed by the current user. Introduced in GitLab 17.10: **Status**: Experiment."
  followedUsersActivity(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Event target."
    target: EventTarget! = ALL
  ): EventConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
}
"Autogenerated return type of AdminSidekiqQueuesDeleteJobs."
type AdminSidekiqQueuesDeleteJobsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Information about the status of the deletion request."
  result: DeleteJobsResponse
}
"Configuration details for an Agent"
type AgentConfiguration {
  "Name of the agent."
  agentName: String
}
"The connection type for AgentConfiguration."
type AgentConfigurationConnection {
  "A list of edges."
  edges: [AgentConfigurationEdge]
  "A list of nodes."
  nodes: [AgentConfiguration]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AgentConfigurationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AgentConfiguration
}
"Information about a connected Agent"
type AgentMetadata {
  "Agent version commit."
  commit: String
  "Name of the pod running the Agent."
  podName: String
  "Namespace of the pod running the Agent."
  podNamespace: String
  "Agent version tag."
  version: String
}
"Version-related warning for a connected Agent"
type AgentVersionWarning {
  "Warning message related to the version."
  message: String
  "Warning type related to the version."
  type: String
}
"Warning object for a connected Agent"
type AgentWarning {
  "Agent warning related to the version."
  version: AgentVersionWarning
}
"Describes an alert from the project's Alert Management"
type AlertManagementAlert implements NoteableInterface & Todoable {
  "Assignees of the alert."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "All commenters on the noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Timestamp the alert was created."
  createdAt: Time
  "Description of the alert."
  description: String
  "Alert details."
  details: JSON
  "URL of the alert detail page."
  detailsUrl: String!
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Timestamp the alert ended."
  endedAt: Time
  "Environment for the alert."
  environment: Environment
  "Number of events of the alert."
  eventCount: Int
  "List of hosts the alert came from."
  hosts: [String!]
  "ID of the alert."
  id: ID!
  "Internal ID of the alert."
  iid: String!
  "Issue attached to the alert."
  issue: Issue
  "Internal ID of the GitLab issue attached to the alert. Deprecated in GitLab 13.10: Use issue field."
  issueIid: String @deprecated(reason: "Use issue field. Deprecated in GitLab 13.10.")
  "URL for metrics embed for the alert. Deprecated in GitLab 16.0: Returns no data. Underlying feature was removed in 16.0."
  metricsDashboardUrl: String @deprecated(reason: "Returns no data. Underlying feature was removed in 16.0. Deprecated in GitLab 16.0.")
  "Monitoring tool the alert came from."
  monitoringTool: String
  "Name or title of the object."
  name: String
  "All notes on this noteable."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Alert condition for Prometheus. Deprecated in GitLab 17.3: Returns no data. Underlying feature was removed in 16.0."
  prometheusAlert: PrometheusAlert @deprecated(reason: "Returns no data. Underlying feature was removed in 16.0. Deprecated in GitLab 17.3.")
  "Runbook for the alert as defined in alert details."
  runbook: String
  "Service the alert came from."
  service: String
  "Severity of the alert."
  severity: AlertManagementSeverity
  "Timestamp the alert was raised."
  startedAt: Time
  "Status of the alert."
  status: AlertManagementStatus
  "Title of the alert."
  title: String
  "To-do items of the current user for the alert."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "Timestamp the alert was last updated."
  updatedAt: Time
  "URL of the alert."
  webUrl: String!
}
"The connection type for AlertManagementAlert."
type AlertManagementAlertConnection {
  "A list of edges."
  edges: [AlertManagementAlertEdge]
  "A list of nodes."
  nodes: [AlertManagementAlert]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AlertManagementAlertEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AlertManagementAlert
}
"Represents total number of alerts for the represented categories"
type AlertManagementAlertStatusCountsType {
  "Number of alerts with status ACKNOWLEDGED for the project"
  acknowledged: Int
  "Total number of alerts for the project."
  all: Int
  "Number of alerts with status IGNORED for the project"
  ignored: Int
  "Number of alerts with status TRIGGERED or ACKNOWLEDGED for the project."
  open: Int
  "Number of alerts with status RESOLVED for the project"
  resolved: Int
  "Number of alerts with status TRIGGERED for the project"
  triggered: Int
}
"An endpoint and credentials used to accept alerts for a project"
type AlertManagementHttpIntegration implements AlertManagementIntegration {
  "Whether the endpoint is currently accepting alerts."
  active: Boolean
  "URL at which Prometheus metrics can be queried to populate the metrics dashboard."
  apiUrl: String
  "ID of the integration."
  id: ID!
  "Name of the integration."
  name: String
  "Token used to authenticate alert notification requests."
  token: String
  "Type of integration."
  type: AlertManagementIntegrationType!
  "Endpoint which accepts alert notifications."
  url: String
}
"The connection type for AlertManagementHttpIntegration."
type AlertManagementHttpIntegrationConnection {
  "A list of edges."
  edges: [AlertManagementHttpIntegrationEdge]
  "A list of nodes."
  nodes: [AlertManagementHttpIntegration]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AlertManagementHttpIntegrationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AlertManagementHttpIntegration
}
"The connection type for AlertManagementIntegration."
type AlertManagementIntegrationConnection {
  "A list of edges."
  edges: [AlertManagementIntegrationEdge]
  "A list of nodes."
  nodes: [AlertManagementIntegration]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AlertManagementIntegrationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AlertManagementIntegration
}
"An endpoint and credentials used to accept Prometheus alerts for a project"
type AlertManagementPrometheusIntegration implements AlertManagementIntegration {
  "Whether the endpoint is currently accepting alerts."
  active: Boolean
  "URL at which Prometheus metrics can be queried to populate the metrics dashboard."
  apiUrl: String
  "ID of the integration."
  id: ID!
  "Name of the integration."
  name: String
  "Token used to authenticate alert notification requests."
  token: String
  "Type of integration."
  type: AlertManagementIntegrationType!
  "Endpoint which accepts alert notifications."
  url: String
}
"Autogenerated return type of AlertSetAssignees."
type AlertSetAssigneesPayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}
"Autogenerated return type of AlertTodoCreate."
type AlertTodoCreatePayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}
"Autogenerated return type of ArtifactDestroy."
type ArtifactDestroyPayload {
  "Deleted artifact."
  artifact: CiJobArtifact
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Represents the YAML definitions for audit events defined in `ee/config/audit_events/types/<event-type-name>.yml` and `config/audit_events/types/<event-type-name>.yml`."
type AuditEventDefinition {
  "Description of what action the audit event tracks."
  description: String!
  "Feature category associated with the event."
  featureCategory: String!
  "Link to the issue introducing the event. For olderaudit events, it can be a commit URL rather than amerge request URL."
  introducedByIssue: String
  "Link to the merge request introducing the event. Forolder audit events, it can be a commit URL rather thana merge request URL."
  introducedByMr: String
  "Milestone the event was introduced in."
  milestone: String!
  "Key name of the audit event."
  name: String!
  "Indicates if the event is saved to PostgreSQL database."
  savedToDatabase: Boolean!
  "Indicates if the event is streamed to an external destination."
  streamed: Boolean!
}
"The connection type for AuditEventDefinition."
type AuditEventDefinitionConnection {
  "A list of edges."
  edges: [AuditEventDefinitionEdge]
  "A list of nodes."
  nodes: [AuditEventDefinition]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AuditEventDefinitionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AuditEventDefinition
}
"Core representation of a GitLab user."
type AutocompletedUser implements Todoable & User {
  "Indicates if the user is active."
  active: Boolean
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Merge request state related to the user."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
"An emoji awarded by a user"
type AwardEmoji {
  "Emoji description."
  description: String!
  "Emoji as an icon."
  emoji: String!
  "Emoji name."
  name: String!
  "Emoji in Unicode."
  unicode: String!
  "Unicode version for the emoji."
  unicodeVersion: String!
  "User who awarded the emoji."
  user: UserCore!
}
"Autogenerated return type of AwardEmojiAdd."
type AwardEmojiAddPayload {
  "Emoji reactions after mutation."
  awardEmoji: AwardEmoji
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"The connection type for AwardEmoji."
type AwardEmojiConnection {
  "A list of edges."
  edges: [AwardEmojiEdge]
  "A list of nodes."
  nodes: [AwardEmoji]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type AwardEmojiEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AwardEmoji
}
"Autogenerated return type of AwardEmojiRemove."
type AwardEmojiRemovePayload {
  "Emoji reactions after mutation."
  awardEmoji: AwardEmoji
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of AwardEmojiToggle."
type AwardEmojiTogglePayload {
  "Emoji reactions after mutation."
  awardEmoji: AwardEmoji
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Indicates the status of the emoji. True if the toggle awarded the emoji, and false if the toggle removed the emoji."
  toggledOn: Boolean!
}
type BaseService implements Service {
  "Indicates if the service is active."
  active: Boolean
  "Type of the service."
  serviceType: ServiceType
  "Class name of the service."
  type: String
}
type Blame {
  "First line of Git Blame for given range."
  firstLine: String
  "Git Blame grouped by contiguous lines for commit."
  groups: [Groups!]
}
type Blob implements Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "LFS ID of the blob."
  lfsOid: String
  "Blob mode in numeric format."
  mode: String
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "SHA of the entry."
  sha: String!
  "Type of tree entry."
  type: EntryType!
  "Web path of the blob."
  webPath: String
  "Web URL of the blob."
  webUrl: String
}
"The connection type for Blob."
type BlobConnection {
  "A list of edges."
  edges: [BlobEdge]
  "A list of nodes."
  nodes: [Blob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type BlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Blob
}
"Represents how the blob content should be displayed"
type BlobViewer {
  "Shows whether the blob should be displayed collapsed."
  collapsed: Boolean!
  "Content file type."
  fileType: String!
  "Shows whether the blob content is loaded asynchronously."
  loadAsync: Boolean!
  "Loading partial name."
  loadingPartialName: String!
  "Error rendering the blob content."
  renderError: String
  "Shows whether the blob is too large to be displayed."
  tooLarge: Boolean!
  "Type of blob viewer."
  type: BlobViewersType!
}
"Represents a project or group issue board"
type Board {
  "Timestamp of when the board was created."
  createdAt: Time!
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "ID (global ID) of the board."
  id: ID!
  "Lists of the board."
  lists(
    "Find a list by its global ID."
    id: ListID,
    "Filters applied when getting issue metadata in the board list."
    issueFilters: BoardIssueInput,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardListConnection
  "Name of the board."
  name: String
  "Timestamp of when the board was last updated."
  updatedAt: Time!
  "Web path of the board."
  webPath: String!
  "Web URL of the board."
  webUrl: String!
}
"The connection type for Board."
type BoardConnection {
  "A list of edges."
  edges: [BoardEdge]
  "A list of nodes."
  nodes: [Board]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type BoardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Board
}
"Represents a list for an issue board"
type BoardList {
  "Indicates if the list is collapsed for the user."
  collapsed: Boolean
  "ID (global ID) of the list."
  id: ID!
  "Board issues."
  issues(
    "Filters applied when selecting issues in the board list."
    filters: BoardIssueInput,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssueConnection
  "Count of issues in the list."
  issuesCount: Int
  "Label of the list."
  label: Label
  "Type of the list."
  listType: String!
  "Position of list within the board."
  position: Int
  "Title of the list."
  title: String!
}
"The connection type for BoardList."
type BoardListConnection {
  "A list of edges."
  edges: [BoardListEdge]
  "A list of nodes."
  nodes: [BoardList]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of BoardListCreate."
type BoardListCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue list in the issue board."
  list: BoardList
}
"An edge in a connection."
type BoardListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: BoardList
}
type Branch {
  "Commit for the branch."
  commit: Commit
  "Name of the branch."
  name: String!
}
"Autogenerated return type of BranchDelete."
type BranchDeletePayload {
  "Branch after mutation."
  branch: Branch
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Branch protection details for a branch rule."
type BranchProtection {
  "Toggle force push to the branch for users with write access."
  allowForcePush: Boolean!
  "Details about who can merge when the branch is the source branch."
  mergeAccessLevels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeAccessLevelConnection
  "Details about who can push when the branch is the source branch."
  pushAccessLevels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PushAccessLevelConnection
}
"Branch rules configured for a rule target."
type BranchRule {
  "Branch protections configured for the branch rule."
  branchProtection: BranchProtection
  "Timestamp of when the branch rule was created."
  createdAt: Time
  "ID of the branch rule."
  id: ProjectsBranchRuleID
  "Check if the branch rule protects the project's default branch."
  isDefault: Boolean!
  "Check if the branch rule protects access for the branch."
  isProtected: Boolean!
  "Number of existing branches that match the branch rule."
  matchingBranchesCount: Int!
  "Name of the branch rule target. Includes wildcards."
  name: String!
  "The default behavior for squashing in merge requests. Returns null if `branch_rule_squash_settings` feature flag is disabled. Introduced in GitLab 17.9: **Status**: Experiment."
  squashOption: SquashOption @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Timestamp of when the branch rule was last updated."
  updatedAt: Time
}
"The connection type for BranchRule."
type BranchRuleConnection {
  "A list of edges."
  edges: [BranchRuleEdge]
  "A list of nodes."
  nodes: [BranchRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of BranchRuleCreate."
type BranchRuleCreatePayload {
  "Branch rule after mutation."
  branchRule: BranchRule
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of BranchRuleDelete."
type BranchRuleDeletePayload {
  "Branch rule after mutation."
  branchRule: BranchRule
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type BranchRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: BranchRule
}
"Autogenerated return type of BranchRuleSquashOptionUpdate."
type BranchRuleSquashOptionUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated squash option after mutation."
  squashOption: SquashOption
}
"Autogenerated return type of BranchRuleUpdate."
type BranchRuleUpdatePayload {
  "Branch rule after mutation."
  branchRule: BranchRule
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of BulkDestroyJobArtifacts."
type BulkDestroyJobArtifactsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of job artifacts deleted."
  destroyedCount: Int
  "IDs of job artifacts that were deleted."
  destroyedIds: [CiJobArtifactID!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of BulkRunnerDelete."
type BulkRunnerDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of records effectively deleted. Only present if operation was performed synchronously."
  deletedCount: Int
  "IDs of records effectively deleted. Only present if operation was performed synchronously."
  deletedIds: [CiRunnerID!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CatalogResourcesCreate."
type CatalogResourcesCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CatalogResourcesDestroy."
type CatalogResourcesDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type CiApplicationSettings {
  "Whether to keep the latest jobs artifacts."
  keepLatestArtifact: Boolean
}
type CiBuildNeed {
  "ID of the BuildNeed."
  id: ID!
  "Name of the job we need to complete."
  name: String
}
"The connection type for CiBuildNeed."
type CiBuildNeedConnection {
  "A list of edges."
  edges: [CiBuildNeedEdge]
  "A list of nodes."
  nodes: [CiBuildNeed]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiBuildNeedEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiBuildNeed
}
type CiCatalogResource {
  "Description of the catalog resource."
  description: String
  "Full project path of the catalog resource. Introduced in GitLab 16.11: **Status**: Experiment."
  fullPath: ID @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Icon for the catalog resource."
  icon: String
  "ID of the catalog resource."
  id: ID!
  "Number of projects that used a component from this catalog resource in a pipeline, by using `include:component`, in the last 30 days. Introduced in GitLab 17.0: **Status**: Experiment."
  last30DayUsageCount: Int! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  "Release date of the catalog resource's latest version. Introduced in GitLab 16.5: **Status**: Experiment."
  latestReleasedAt: Time @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.5.")
  "Name of the catalog resource."
  name: String
  "Number of times the catalog resource has been starred."
  starCount: Int!
  "Relative path to the starrers page for the catalog resource project."
  starrersPath: String
  "Topics for the catalog resource."
  topics: [String!]
  "Verification level of the catalog resource."
  verificationLevel: CiCatalogResourceVerificationLevel
  "Versions of the catalog resource. This field can only be resolved for one catalog resource in any single request."
  versions(
    "Name of the version."
    name: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiCatalogResourceVersionConnection
  "Visibility level of the catalog resource."
  visibilityLevel: VisibilityLevelsEnum
  "Web path of the catalog resource. Introduced in GitLab 16.1: **Status**: Experiment."
  webPath: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.1.")
}
type CiCatalogResourceComponent {
  "ID of the component."
  id: CiCatalogResourcesComponentID!
  "Path used to include the component."
  includePath: String
  "Inputs for the component."
  inputs: [CiInputsSpec!]
  "Name of the component."
  name: String
}
"The connection type for CiCatalogResourceComponent."
type CiCatalogResourceComponentConnection {
  "A list of edges."
  edges: [CiCatalogResourceComponentEdge]
  "A list of nodes."
  nodes: [CiCatalogResourceComponent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiCatalogResourceComponentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiCatalogResourceComponent
}
"The connection type for CiCatalogResource."
type CiCatalogResourceConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiCatalogResourceEdge]
  "A list of nodes."
  nodes: [CiCatalogResource]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiCatalogResourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiCatalogResource
}
type CiCatalogResourceVersion {
  "User that created the version."
  author: UserCore
  "Commit associated with the version."
  commit: Commit
  "Components belonging to the catalog resource."
  components(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiCatalogResourceComponentConnection
  "Timestamp of when the version was created."
  createdAt: Time
  "Global ID of the version."
  id: CiCatalogResourcesVersionID!
  "Name that uniquely identifies the version within the catalog resource."
  name: String
  "Relative web path to the version."
  path: String
  "Readme data."
  readme: String
  "GitLab Flavored Markdown rendering of `readme`"
  readmeHtml: String
  "Timestamp of when the version was released. Introduced in GitLab 16.7: **Status**: Experiment."
  releasedAt: Time @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
}
"The connection type for CiCatalogResourceVersion."
type CiCatalogResourceVersionConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiCatalogResourceVersionEdge]
  "A list of nodes."
  nodes: [CiCatalogResourceVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiCatalogResourceVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiCatalogResourceVersion
}
type CiCdSettings {
  "Indicates the default minimum role required to override pipeline variables in the namespace."
  pipelineVariablesDefaultRole: String
}
type CiConfig {
  "Linting errors."
  errors: [String!]
  "List of included files."
  includes: [CiConfigInclude!]
  "Merged CI configuration YAML."
  mergedYaml: String
  "Stages of the pipeline."
  stages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigStageConnection
  "Status of linting, can be either valid or invalid."
  status: CiConfigStatus
  "Linting warnings."
  warnings: [String!]
}
type CiConfigGroup {
  "Jobs in group."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigJobConnection
  "Name of the job group."
  name: String
  "Size of the job group."
  size: Int
}
"The connection type for CiConfigGroup."
type CiConfigGroupConnection {
  "A list of edges."
  edges: [CiConfigGroupEdge]
  "A list of nodes."
  nodes: [CiConfigGroup]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiConfigGroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigGroup
}
type CiConfigInclude {
  """
  File blob location. It can be masked if it contains masked variables. For example, `"https://gitlab.com/gitlab-org/gitlab/-/blob/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml"`.
  """
  blob: String
  """
  Current project scope, e.g., "gitlab-org/gitlab".
  """
  contextProject: String
  "Current sha scope."
  contextSha: String
  "Extra information for the `include`, which can contain `job_name`, `project`, and `ref`. Values can be masked if they contain masked variables."
  extra: JSON
  """
  File location. It can be masked if it contains masked variables. For example, `".gitlab/ci/build-images.gitlab-ci.yml"`.
  """
  location: String
  """
  File raw location. It can be masked if it contains masked variables. For example, `"https://gitlab.com/gitlab-org/gitlab/-/raw/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml"`.
  """
  raw: String
  "Include type."
  type: CiConfigIncludeType
}
type CiConfigJob {
  "Override a set of commands that are executed after the job."
  afterScript: [String!]
  "Allow job to fail."
  allowFailure: Boolean
  "Override a set of commands that are executed before the job."
  beforeScript: [String!]
  "Name of an environment to which the job deploys."
  environment: String
  "Limit when jobs are not created."
  except: CiConfigJobRestriction
  "Name of the job group."
  groupName: String
  "Name of the job."
  name: String
  "Builds that must complete before the jobs run."
  needs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigNeedConnection
  "Jobs are created when these conditions do not apply."
  only: CiConfigJobRestriction
  "Shell script that is executed by a runner."
  script: [String!]
  "Name of the job stage."
  stage: String
  "List of tags that are used to select a runner."
  tags: [String!]
  "When to run the job."
  when: String
}
"The connection type for CiConfigJob."
type CiConfigJobConnection {
  "A list of edges."
  edges: [CiConfigJobEdge]
  "A list of nodes."
  nodes: [CiConfigJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiConfigJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigJob
}
type CiConfigJobRestriction {
  "Git refs the job restriction applies to."
  refs: [String!]
}
type CiConfigNeed {
  "Name of the need."
  name: String
}
"The connection type for CiConfigNeed."
type CiConfigNeedConnection {
  "A list of edges."
  edges: [CiConfigNeedEdge]
  "A list of nodes."
  nodes: [CiConfigNeed]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiConfigNeedEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigNeed
}
type CiConfigStage {
  "Groups of jobs for the stage."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigGroupConnection
  "Name of the stage."
  name: String
}
"The connection type for CiConfigStage."
type CiConfigStageConnection {
  "A list of edges."
  edges: [CiConfigStageEdge]
  "A list of nodes."
  nodes: [CiConfigStage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiConfigStageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigStage
}
"CI/CD config variables."
type CiConfigVariable {
  "Description for the CI/CD config variable."
  description: String
  "Name of the variable."
  key: String
  "Value of the variable."
  value: String
  "Value options for the variable."
  valueOptions: [String!]
}
"Histogram of durations for a group of CI/CD jobs or pipelines."
type CiDurationStatistics {
  "50th percentile. 50% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment."
  p50: Duration @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
  "75th percentile. 75% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment."
  p75: Duration @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
  "90th percentile. 90% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment."
  p90: Duration @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
  "95th percentile. 95% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment."
  p95: Duration @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
  "99th percentile. 99% of the durations are lower than this value. Introduced in GitLab 15.8: **Status**: Experiment."
  p99: Duration @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
}
"Represents a deployment freeze window of a project"
type CiFreezePeriod {
  "Time zone for the cron fields, defaults to UTC if not provided."
  cronTimezone: String
  "End of the freeze period in cron format."
  endCron: String!
  "Timestamp (UTC) of when the current/next active period ends."
  endTime: Time
  "Start of the freeze period in cron format."
  startCron: String!
  "Timestamp (UTC) of when the current/next active period starts."
  startTime: Time
  "Freeze period status."
  status: CiFreezePeriodStatus!
}
type CiGroup {
  "Detailed status of the group."
  detailedStatus: DetailedStatus
  "ID for a group."
  id: String!
  "Jobs in group."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Name of the job group."
  name: String
  "Size of the group."
  size: Int
}
"The connection type for CiGroup."
type CiGroupConnection {
  "A list of edges."
  edges: [CiGroupEdge]
  "A list of nodes."
  nodes: [CiGroup]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiGroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiGroup
}
"CI/CD environment scope for a group."
type CiGroupEnvironmentScope {
  "Scope name defininig the enviromnments that can use the variable."
  name: String
}
"The connection type for CiGroupEnvironmentScope."
type CiGroupEnvironmentScopeConnection {
  "A list of edges."
  edges: [CiGroupEnvironmentScopeEdge]
  "A list of nodes."
  nodes: [CiGroupEnvironmentScope]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiGroupEnvironmentScopeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiGroupEnvironmentScope
}
"CI/CD variables for a group."
type CiGroupVariable implements CiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable."
  environmentScope: String
  "Indicates whether the variable is hidden."
  hidden: Boolean
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}
"The connection type for CiGroupVariable."
type CiGroupVariableConnection {
  "A list of edges."
  edges: [CiGroupVariableEdge]
  "Maximum amount of group CI/CD variables."
  limit: Int!
  "A list of nodes."
  nodes: [CiGroupVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiGroupVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiGroupVariable
}
"CI input saved for a pipeline schedule"
type CiInputsField {
  "Name of the input."
  name: String!
  "Value of the input."
  value: CiInputsValue
}
"The connection type for CiInputsField."
type CiInputsFieldConnection {
  "A list of edges."
  edges: [CiInputsFieldEdge]
  "A list of nodes."
  nodes: [CiInputsField]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiInputsFieldEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiInputsField
}
"Input for pipeline creation"
type CiInputsSpec {
  "Default value for the input, if provided."
  default: CiInputsValue
  "Description of the input."
  description: String
  "Name of the input."
  name: String!
  "Possible values that the input can take, if provided."
  options: CiInputsValue
  "Regular expression pattern that the input value must match if provided."
  regex: String
  "Indicates whether the input is required."
  required: Boolean!
  "Input data type."
  type: CiInputsType!
}
"CI/CD variables for a GitLab instance."
type CiInstanceVariable implements CiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable. Deprecated in GitLab 15.3: No longer used, only available for GroupVariableType and ProjectVariableType."
  environmentScope: String @deprecated(reason: "No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in GitLab 15.3.")
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}
"The connection type for CiInstanceVariable."
type CiInstanceVariableConnection {
  "A list of edges."
  edges: [CiInstanceVariableEdge]
  "A list of nodes."
  nodes: [CiInstanceVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiInstanceVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiInstanceVariable
}
type CiJob {
  "Indicates the job is active."
  active: Boolean!
  "Whether the job is allowed to fail."
  allowFailure: Boolean!
  "Artifacts generated by the job."
  artifacts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobArtifactConnection
  "URL for browsing the artifact's archive."
  browseArtifactsPath: String
  "Indicates whether the current user can play the job."
  canPlayJob: Boolean!
  "Indicates the job can be canceled."
  cancelable: Boolean!
  "Path to the commit that triggered the job."
  commitPath: String
  "Coverage level of the job."
  coverage: Float
  "When the job was created."
  createdAt: Time!
  "Whether the job was created by a tag."
  createdByTag: Boolean!
  "Detailed status of the job."
  detailedStatus: DetailedStatus
  "Downstream pipeline for a bridge."
  downstreamPipeline: Pipeline
  "Duration of the job in seconds."
  duration: Int
  "When the job was erased."
  erasedAt: Time
  "Exit code of the job. Available for jobs that started after upgrading to GitLab 16.10 and failed with an exit code."
  exitCode: Int
  "Message on why the job failed."
  failureMessage: String
  "When a job has finished running."
  finishedAt: Time
  "ID of the job."
  id: JobID
  "Indicates the type of job."
  kind: CiJobKind!
  "Whether the job has a manual action."
  manualJob: Boolean
  "Variables added to a manual job when the job is triggered."
  manualVariables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiManualVariableConnection
  "Name of the job."
  name: String
  "References to builds that must complete before the jobs run."
  needs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiBuildNeedConnection
  "Pipeline the job belongs to."
  pipeline: PipelineInterface
  "Play path of the job."
  playPath: String
  "Indicates the job can be played."
  playable: Boolean!
  "Jobs from the previous stage."
  previousStageJobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Jobs that must complete before the job runs. Returns `BuildNeed`, which is the needed jobs if the job uses the `needs` keyword, or the previous stage jobs otherwise. Deprecated in GitLab 16.4: Replaced by previousStageJobs and needs fields."
  previousStageJobsOrNeeds(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): JobNeedUnionConnection @deprecated(reason: "Replaced by previousStageJobs and needs fields. Deprecated in GitLab 16.4.")
  "Project that the job belongs to."
  project: Project
  "When the job was enqueued and marked as pending."
  queuedAt: Time
  "How long the job was enqueued before starting."
  queuedDuration: Duration
  "Ref name of the job."
  refName: String
  "Path to the ref."
  refPath: String
  "Indicates that the job has been retried."
  retried: Boolean
  "Indicates the job can be retried."
  retryable: Boolean!
  "Runner assigned to execute the job."
  runner: CiRunner
  "Runner manager assigned to the job."
  runnerManager: CiRunnerManager
  "Indicates the job is scheduled."
  scheduled: Boolean!
  "Schedule for the build."
  scheduledAt: Time
  "Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise."
  schedulingType: String
  "Short SHA1 ID of the commit."
  shortSha: String!
  "Policy or action that initiated the job. If not set, the value is inherited from the pipeline."
  source: String
  "Stage of the job."
  stage: CiStage
  "When the job was started."
  startedAt: Time
  "Status of the job."
  status: CiJobStatus
  "Indicates the job is stuck."
  stuck: Boolean!
  "Tags for the current job."
  tags: [String!]
  "Trace generated by the job."
  trace: CiJobTrace
  "Whether the job was triggered."
  triggered: Boolean
  "Permissions for the current user on the resource"
  userPermissions: JobPermissions!
  "Web path of the job."
  webPath: String
}
type CiJobArtifact {
  "URL for downloading the artifact's file."
  downloadPath: String
  "Expiry date of the artifact."
  expireAt: Time
  "File type of the artifact."
  fileType: JobArtifactFileType
  "ID of the artifact."
  id: CiJobArtifactID!
  "File name of the artifact."
  name: String
  "Size of the artifact in bytes."
  size: BigInt!
}
"The connection type for CiJobArtifact."
type CiJobArtifactConnection {
  "A list of edges."
  edges: [CiJobArtifactEdge]
  "A list of nodes."
  nodes: [CiJobArtifact]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiJobArtifactEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJobArtifact
}
"The connection type for CiJob."
type CiJobConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [CiJobEdge]
  "A list of nodes."
  nodes: [CiJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJob
}
"Group that can access the current project by authenticating with a CI/CD job token."
type CiJobTokenAccessibleGroup {
  "Avatar URL of the group."
  avatarUrl: String
  "Full path of the group."
  fullPath: ID!
  "ID of the group."
  id: ID!
  "Name of the group."
  name: String!
  "Path of the group."
  path: String!
  "Web URL of the group."
  webUrl: String
}
"The connection type for CiJobTokenAccessibleGroup."
type CiJobTokenAccessibleGroupConnection {
  "A list of edges."
  edges: [CiJobTokenAccessibleGroupEdge]
  "A list of nodes."
  nodes: [CiJobTokenAccessibleGroup]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiJobTokenAccessibleGroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJobTokenAccessibleGroup
}
"Project that can access the current project by authenticating with a CI/CD job token."
type CiJobTokenAccessibleProject {
  "URL to avatar image file of the project."
  avatarUrl: String
  "Full path of the project."
  fullPath: ID!
  "ID of the project."
  id: ID!
  "Name of the project (without namespace)."
  name: String!
  "Path of the project."
  path: String!
  "Web URL of the project."
  webUrl: String
}
"The connection type for CiJobTokenAccessibleProject."
type CiJobTokenAccessibleProjectConnection {
  "A list of edges."
  edges: [CiJobTokenAccessibleProjectEdge]
  "A list of nodes."
  nodes: [CiJobTokenAccessibleProject]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiJobTokenAccessibleProjectEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJobTokenAccessibleProject
}
type CiJobTokenAuthLog {
  "Last authorization date time. Introduced in GitLab 17.6: **Status**: Experiment."
  lastAuthorizedAt: Time! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Origin project. Introduced in GitLab 17.6: **Status**: Experiment."
  originProject: CiJobTokenAccessibleProject! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
}
"The connection type for CiJobTokenAuthLog."
type CiJobTokenAuthLogConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiJobTokenAuthLogEdge]
  "A list of nodes."
  nodes: [CiJobTokenAuthLog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiJobTokenAuthLogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJobTokenAuthLog
}
"Autogenerated return type of CiJobTokenScopeAddGroupOrProject."
type CiJobTokenScopeAddGroupOrProjectPayload {
  "CI job token's access scope."
  ciJobTokenScope: CiJobTokenScopeType
  "Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment."
  ciJobTokenScopeAllowlistEntry: CiJobTokenScopeAllowlistEntry @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CiJobTokenScopeAddProject."
type CiJobTokenScopeAddProjectPayload {
  "CI job token's access scope."
  ciJobTokenScope: CiJobTokenScopeType
  "Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment."
  ciJobTokenScopeAllowlistEntry: CiJobTokenScopeAllowlistEntry @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type CiJobTokenScopeAllowlist {
  "Allowlist of groups that can access the current project by authenticating with a CI/CD job token."
  groupsAllowlist(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobTokenScopeAllowlistEntryConnection
  "Allowlist of projects that can access the current project by authenticating with a CI/CD job token."
  projectsAllowlist(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobTokenScopeAllowlistEntryConnection
}
"Represents an allowlist entry for the CI_JOB_TOKEN"
type CiJobTokenScopeAllowlistEntry {
  "User that added the entry."
  addedBy: UserCore
  "Indicates whether the entry is created by the autopopulation process."
  autopopulated: Boolean
  "When the entry was created."
  createdAt: Time!
  "Indicates whether default permissions are enabled (true) or fine-grained permissions are enabled (false)."
  defaultPermissions: Boolean
  "Direction of access. Defaults to INBOUND."
  direction: String
  "List of policies for the entry. Introduced in GitLab 17.5: **Status**: Experiment."
  jobTokenPolicies: [CiJobTokenScopePolicies!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
  "Project that owns the allowlist entry."
  sourceProject: Project!
  "Group or project allowed by the entry."
  target: CiJobTokenScopeTarget
}
"The connection type for CiJobTokenScopeAllowlistEntry."
type CiJobTokenScopeAllowlistEntryConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiJobTokenScopeAllowlistEntryEdge]
  "A list of nodes."
  nodes: [CiJobTokenScopeAllowlistEntry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiJobTokenScopeAllowlistEntryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJobTokenScopeAllowlistEntry
}
"Autogenerated return type of CiJobTokenScopeAutopopulateAllowlist."
type CiJobTokenScopeAutopopulateAllowlistPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Status of the autopopulation process."
  status: String!
}
"Autogenerated return type of CiJobTokenScopeClearAllowlistAutopopulations."
type CiJobTokenScopeClearAllowlistAutopopulationsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Status of the autopopulation process."
  status: String!
}
"Autogenerated return type of CiJobTokenScopeRemoveGroup."
type CiJobTokenScopeRemoveGroupPayload {
  "CI job token's access scope."
  ciJobTokenScope: CiJobTokenScopeType
  "Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment."
  ciJobTokenScopeAllowlistEntry: CiJobTokenScopeAllowlistEntry @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CiJobTokenScopeRemoveProject."
type CiJobTokenScopeRemoveProjectPayload {
  "CI job token's access scope."
  ciJobTokenScope: CiJobTokenScopeType
  "Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment."
  ciJobTokenScopeAllowlistEntry: CiJobTokenScopeAllowlistEntry @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type CiJobTokenScopeType {
  "List of IDs of groups which have been created by the  autopopulation process."
  groupAllowlistAutopopulatedIds: [GroupID!]!
  "Allowlist of groups that can access the current project by authenticating with a CI/CD job token."
  groupsAllowlist(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobTokenAccessibleGroupConnection!
  "Count of groups that can access the current project by authenticating with a CI/CD job token. The count does not include subgroups."
  groupsAllowlistCount: Int!
  "Allowlist of projects that can access the current project by authenticating with a CI/CD job token."
  inboundAllowlist(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobTokenAccessibleProjectConnection!
  "List of IDs of projects which have been created by the  autopopulation process."
  inboundAllowlistAutopopulatedIds: [ProjectID!]!
  "Count of projects that can access the current project by authenticating with a CI/CD job token. The count does not include nested projects."
  inboundAllowlistCount: Int!
  "Allow list of projects that are accessible using the current project's CI Job tokens."
  outboundAllowlist(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection!
  "Allow list of projects that can be accessed by CI Job tokens created by the project. Deprecated in GitLab 15.9: The `projects` attribute is being deprecated. Use `outbound_allowlist`."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection! @deprecated(reason: "The `projects` attribute is being deprecated. Use `outbound_allowlist`. Deprecated in GitLab 15.9.")
}
"Autogenerated return type of CiJobTokenScopeUpdatePolicies."
type CiJobTokenScopeUpdatePoliciesPayload {
  "Allowlist entry for the CI job token's access scope. Introduced in GitLab 17.6: **Status**: Experiment."
  ciJobTokenScopeAllowlistEntry: CiJobTokenScopeAllowlistEntry @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type CiJobTrace {
  "HTML summary that contains the tail lines of the trace. Returns at most 16KB of raw bytes from the trace. The returned string might start with an unexpected invalid UTF-8 code point due to truncation. Introduced in GitLab 15.11: **Status**: Experiment."
  htmlSummary(
    "Number of tail lines to return, up to a maximum of 100 lines."
    lastLines: Int = 10
  ): String! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
}
"CI/CD variables given to a manual job."
type CiManualVariable implements CiVariable {
  "Scope defining the environments that can use the variable. Deprecated in GitLab 15.3: No longer used, only available for GroupVariableType and ProjectVariableType."
  environmentScope: String @deprecated(reason: "No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in GitLab 15.3.")
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}
"The connection type for CiManualVariable."
type CiManualVariableConnection {
  "A list of edges."
  edges: [CiManualVariableEdge]
  "A list of nodes."
  nodes: [CiManualVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiManualVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiManualVariable
}
"Information about an asynchronous pipeline creation request"
type CiPipelineCreationRequest {
  "Error message if pipeline creation failed."
  error: String
  "ID of the created pipeline if creation was successful."
  pipelineId: CiPipelineID
  "Current status of the pipeline creation."
  status: CiPipelineCreationStatus!
}
"CI/CD variables for a project."
type CiProjectVariable implements CiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable."
  environmentScope: String
  "Indicates whether the variable is hidden."
  hidden: Boolean
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}
"The connection type for CiProjectVariable."
type CiProjectVariableConnection {
  "A list of edges."
  edges: [CiProjectVariableEdge]
  "Maximum amount of project CI/CD variables."
  limit: Int!
  "A list of nodes."
  nodes: [CiProjectVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiProjectVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiProjectVariable
}
type CiRunner {
  "Access level of the runner."
  accessLevel: CiRunnerAccessLevel!
  "Indicates the runner is allowed to receive jobs. Deprecated in GitLab 14.8: Use paused."
  active: Boolean! @deprecated(reason: "Use paused. Deprecated in GitLab 14.8.")
  "Admin URL of the runner. Only available for administrators."
  adminUrl: String
  "Timestamp of last contact from the runner."
  contactedAt: Time
  "Timestamp of creation of the runner."
  createdAt: Time
  "User that created the runner."
  createdBy: UserCore
  "Type of runner registration. Introduced in GitLab 17.0: **Status**: Experiment."
  creationMethod: CiRunnerCreationMethod @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  "Runner creation state. Used to determine if a runner has been registered and has contacted the GitLab instance. Introduced in GitLab 17.11: **Status**: Experiment."
  creationState: CiRunnerCreationState @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.11.")
  "Description of the runner."
  description: String
  "Admin form URL of the runner. Only available for administrators."
  editAdminUrl: String
  "Ephemeral authentication token used for runner manager registration. Only available for the creator of the runner for a limited time during registration. Introduced in GitLab 15.9: **Status**: Experiment."
  ephemeralAuthenticationToken: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  "URL of the registration page of the runner manager. Only available for the creator of the runner for a limited time during registration. Introduced in GitLab 15.11: **Status**: Experiment."
  ephemeralRegisterUrl: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
  "Groups the runner is associated with. For group runners only."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupInterfaceConnection
  "ID of the runner."
  id: CiRunnerID!
  """
  Number of jobs processed by the runner (limited to 1000, plus one to indicate that more items exist).
  `jobCount` is an optimized version of `jobs { count }`, and can be requested for multiple runners on the same request.
  """
  jobCount: Int
  "Job execution status of the runner. Introduced in GitLab 15.7: **Status**: Experiment."
  jobExecutionStatus: CiRunnerJobExecutionStatus @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.7.")
  "Jobs assigned to the runner. This field can only be resolved for one runner in any single request."
  jobs(
    "Filter jobs by status."
    statuses: [CiJobStatus!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Indicates the runner is locked."
  locked: Boolean
  "Runner's maintenance notes."
  maintenanceNote: String
  "GitLab Flavored Markdown rendering of `maintenance_note`"
  maintenanceNoteHtml: String
  "Runner managers associated with the runner configuration."
  managers(
    "Filter runner managers by system ID."
    systemId: String,
    "Filter runner managers by status."
    status: CiRunnerStatus,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiRunnerManagerConnection
  "Maximum timeout (in seconds) for jobs processed by the runner."
  maximumTimeout: Int
  "Project that owns the runner. For project runners only."
  ownerProject: ProjectInterface
  "Indicates the runner is paused and not available to run jobs."
  paused: Boolean!
  "Number of projects that the runner is associated with."
  projectCount: Int
  "Find projects the runner is associated with. For project runners only."
  projects(
    "Return only projects that the current user is a member of."
    membership: Boolean,
    "Search query, which can be for the project name, a path, or a description."
    search: String,
    "Include namespace in project search."
    searchNamespaces: Boolean,
    "Filter projects by topics."
    topics: [String!],
    "Return only personal projects."
    personal: Boolean,
    "Sort order of results. Format: `<field_name>_<sort_direction>`, for example: `id_desc` or `name_asc`"
    sort: String = "id_desc",
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "URL of the temporary registration page of the runner. Only available before the runner is registered. Only available for administrators."
  registerAdminUrl: String
  "Indicates the runner is able to run untagged jobs."
  runUntagged: Boolean!
  "Type of the runner."
  runnerType: CiRunnerType!
  "First eight characters of the runner's token used to authenticate new job requests. Used as the runner's unique ID."
  shortSha: String
  "Status of the runner."
  status: CiRunnerStatus!
  "Tags associated with the runner."
  tagList: [String!]
  "Runner token expiration time."
  tokenExpiresAt: Time
  "Permissions for the current user on the resource"
  userPermissions: RunnerPermissions!
}
"The connection type for CiRunner."
type CiRunnerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiRunnerEdge]
  "A list of nodes."
  nodes: [CiRunner]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiRunnerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "Web URL of the runner edit page. The value depends on where you put the field in the query. You can use it for projects or groups."
  editUrl: String
  "The item at the end of the edge."
  node: CiRunner
  "Web URL of the runner. The value depends on where you put the field in the query. You can use it for projects or groups."
  webUrl: String
}
type CiRunnerManager {
  "Architecture provided by the runner manager."
  architectureName: String
  "Timestamp of last contact from the runner manager."
  contactedAt: Time
  "Timestamp of creation of the runner manager."
  createdAt: Time
  "Executor last advertised by the runner."
  executorName: String
  "ID of the runner manager."
  id: CiRunnerManagerID!
  "IP address of the runner manager."
  ipAddress: String
  "Job execution status of the runner manager. Introduced in GitLab 16.3: **Status**: Experiment."
  jobExecutionStatus: CiRunnerJobExecutionStatus @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Platform provided by the runner manager."
  platformName: String
  "Revision of the runner."
  revision: String
  "Runner configuration for the runner manager."
  runner: CiRunner
  "Status of the runner manager."
  status: CiRunnerStatus!
  "System ID associated with the runner manager."
  systemId: String!
  "Version of the runner."
  version: String
}
"The connection type for CiRunnerManager."
type CiRunnerManagerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiRunnerManagerEdge]
  "A list of nodes."
  nodes: [CiRunnerManager]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiRunnerManagerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiRunnerManager
}
type CiStage {
  "Detailed status of the stage."
  detailedStatus: DetailedStatus
  "Group of jobs for the stage."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiGroupConnection
  "ID of the stage."
  id: ID!
  "Jobs for the stage."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Name of the stage."
  name: String
  "Status of the pipeline stage."
  status: String
}
"The connection type for CiStage."
type CiStageConnection {
  "A list of edges."
  edges: [CiStageEdge]
  "A list of nodes."
  nodes: [CiStage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CiStageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiStage
}
"GitLab CI/CD configuration template."
type CiTemplate {
  "Contents of the CI template."
  content: String!
  "Name of the CI template."
  name: String!
}
type ClusterAgent {
  "Recent activity for the cluster agent."
  activityEvents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentActivityEventConnection
  "Active connections for the cluster agent"
  connections(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ConnectedAgentConnection
  "Timestamp the cluster agent was created."
  createdAt: Time
  "User object, containing information about the person who created the agent."
  createdByUser: UserCore
  "ID of the cluster agent."
  id: ID!
  "Name of the cluster agent."
  name: String
  "Project the cluster agent is associated with."
  project: Project
  "Tokens associated with the cluster agent."
  tokens(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentTokenConnection
  "Timestamp the cluster agent was updated."
  updatedAt: Time
  "User access config for the cluster agent."
  userAccessAuthorizations: ClusterAgentAuthorizationUserAccess
  "Web path of the cluster agent."
  webPath: String
}
type ClusterAgentActivityEvent {
  "Agent token associated with the event."
  agentToken: ClusterAgentToken
  "Type of event."
  kind: String
  "Severity of the event."
  level: String
  "Timestamp the event was recorded."
  recordedAt: Time
  "User associated with the event."
  user: UserCore
}
"The connection type for ClusterAgentActivityEvent."
type ClusterAgentActivityEventConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ClusterAgentActivityEventEdge]
  "A list of nodes."
  nodes: [ClusterAgentActivityEvent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ClusterAgentActivityEventEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentActivityEvent
}
type ClusterAgentAuthorizationCiAccess {
  "Authorized cluster agent."
  agent: ClusterAgent
  "Configuration for the authorized project."
  config: JSON
}
"The connection type for ClusterAgentAuthorizationCiAccess."
type ClusterAgentAuthorizationCiAccessConnection {
  "A list of edges."
  edges: [ClusterAgentAuthorizationCiAccessEdge]
  "A list of nodes."
  nodes: [ClusterAgentAuthorizationCiAccess]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ClusterAgentAuthorizationCiAccessEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentAuthorizationCiAccess
}
type ClusterAgentAuthorizationUserAccess {
  "Authorized cluster agent."
  agent: ClusterAgent
  "Configuration for the authorized project."
  config: JSON
}
"The connection type for ClusterAgentAuthorizationUserAccess."
type ClusterAgentAuthorizationUserAccessConnection {
  "A list of edges."
  edges: [ClusterAgentAuthorizationUserAccessEdge]
  "A list of nodes."
  nodes: [ClusterAgentAuthorizationUserAccess]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ClusterAgentAuthorizationUserAccessEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentAuthorizationUserAccess
}
"The connection type for ClusterAgent."
type ClusterAgentConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ClusterAgentEdge]
  "A list of nodes."
  nodes: [ClusterAgent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of ClusterAgentDelete."
type ClusterAgentDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type ClusterAgentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgent
}
type ClusterAgentToken {
  "Cluster agent the token is associated with."
  clusterAgent: ClusterAgent
  "Timestamp the token was created."
  createdAt: Time
  "User who created the token."
  createdByUser: UserCore
  "Description of the token."
  description: String
  "Global ID of the token."
  id: ClustersAgentTokenID!
  "Timestamp the token was last used."
  lastUsedAt: Time
  "Name given to the token."
  name: String
  "Current status of the token."
  status: AgentTokenStatus
}
"The connection type for ClusterAgentToken."
type ClusterAgentTokenConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ClusterAgentTokenEdge]
  "A list of nodes."
  nodes: [ClusterAgentToken]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of ClusterAgentTokenCreate."
type ClusterAgentTokenCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Token secret value. Make sure you save it - you won't be able to access it again."
  secret: String
  "Token created after mutation."
  token: ClusterAgentToken
}
"An edge in a connection."
type ClusterAgentTokenEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentToken
}
"Autogenerated return type of ClusterAgentTokenRevoke."
type ClusterAgentTokenRevokePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Represents reports comparison for code quality."
type CodequalityReportsComparer {
  "Compared codequality report."
  report: CodequalityReportsComparerReport
  "Compared codequality report generation status."
  status: CodequalityReportsComparerReportGenerationStatus
}
"Represents compared code quality report."
type CodequalityReportsComparerReport {
  "All code quality degradations."
  existingErrors: [CodequalityReportsComparerReportDegradation!]
  "New code quality degradations."
  newErrors: [CodequalityReportsComparerReportDegradation!]!
  "Resolved code quality degradations."
  resolvedErrors: [CodequalityReportsComparerReportDegradation!]
  "Status of report."
  status: CodequalityReportsComparerStatus!
  "Codequality report summary."
  summary: CodequalityReportsComparerReportSummary!
}
"Represents a degradation on the compared codequality report."
type CodequalityReportsComparerReportDegradation {
  "Description of the code quality degradation."
  description: String!
  "Code quality plugin that reported the degradation."
  engineName: String
  "Relative path to the file containing the code quality degradation."
  filePath: String!
  "Unique fingerprint to identify the code quality degradation. For example, an MD5 hash."
  fingerprint: String!
  "Line on which the code quality degradation occurred."
  line: Int!
  "Severity of the code quality degradation (BLOCKER, CRITICAL, MAJOR, MINOR, INFO, UNKNOWN)."
  severity: CodeQualityDegradationSeverity!
  "URL to the file along with line number."
  webUrl: String
}
"Represents a summary of the compared codequality report."
type CodequalityReportsComparerReportSummary {
  "Count of code quality errors."
  errored: Int
  "Count of resolved code quality degradations."
  resolved: Int
  "Total count of code quality degradations."
  total: Int
}
type Commit implements Todoable {
  "Author of the commit."
  author: UserCore
  "Commit author's email."
  authorEmail: String
  "Commit authors gravatar."
  authorGravatar: String
  "Commit authors name."
  authorName: String
  "Timestamp of when the commit was authored."
  authoredDate: Time
  "Timestamp of when the commit was committed."
  committedDate: Time
  "Email of the committer."
  committerEmail: String
  "Name of the committer."
  committerName: String
  "Description of the commit message."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Diffs contained within the commit. This field can only be resolved for 10 diffs in any single request."
  diffs: [Diff!]
  "Full title of the commit message."
  fullTitle: String
  "GitLab Flavored Markdown rendering of `full_title`"
  fullTitleHtml: String
  "ID (global ID) of the commit."
  id: ID!
  "Raw commit message."
  message: String
  "Name or title of the object."
  name: String
  "Pipelines of the commit ordered latest first."
  pipelines(
    "Filter pipelines by their status."
    status: PipelineStatusEnum,
    "Filter pipelines by scope."
    scope: PipelineScopeEnum,
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by the sha of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String,
    "Pipelines updated after the date."
    updatedAfter: Time,
    "Pipelines updated before the date."
    updatedBefore: Time,
    "Filter pipelines by the user that triggered the pipeline."
    username: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "SHA1 ID of the commit."
  sha: String!
  "Short SHA1 ID of the commit."
  shortId: String!
  "Signature of the commit."
  signature: CommitSignature
  "Rendered HTML of the commit signature."
  signatureHtml: String
  "Title of the commit message."
  title: String
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Web path of the commit."
  webPath: String!
  "Web URL of the commit."
  webUrl: String!
}
"The connection type for Commit."
type CommitConnection {
  "A list of edges."
  edges: [CommitEdge]
  "A list of nodes."
  nodes: [Commit]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of CommitCreate."
type CommitCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Commit after mutation."
  commit: Commit
  "ETag path for the commit's pipeline."
  commitPipelinePath: String
  "Contents of the commit."
  content: [String!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type CommitData {
  "CSS class for age of commit."
  ageMapClass: String!
  "Link to author avatar."
  authorAvatar: String!
  "Link to the commit author."
  commitAuthorLink: String!
  "Link to the commit."
  commitLink: String!
  "Link to blame prior to the change."
  projectBlameLink: String
  "Time of commit."
  timeAgoTooltip: String!
}
"An edge in a connection."
type CommitEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Commit
}
type CommitParentNames {
  "Names of the commit parent (branch or tag)."
  names: [String!]
}
type CommitReferences {
  "Get branch names containing a given commit."
  containingBranches(
    """
    Exclude tipping refs. WARNING: This argument can be confusing, if there is a limit.
              for example set the limit to 5 and in the 5 out a total of 25 refs there is 2 tipped refs,
              then the method will only 3 refs, even though there is more.
    """
    excludeTipped: Boolean! = false,
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
  "Get tag names containing a given commit."
  containingTags(
    """
    Exclude tipping refs. WARNING: This argument can be confusing, if there is a limit.
              for example set the limit to 5 and in the 5 out a total of 25 refs there is 2 tipped refs,
              then the method will only 3 refs, even though there is more.
    """
    excludeTipped: Boolean! = false,
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
  "Get branch names tipping at a given commit."
  tippingBranches(
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
  "Get tag names tipping at a given commit."
  tippingTags(
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
}
"Composer metadata"
type ComposerMetadata {
  "Data of the Composer JSON file."
  composerJson: PackageComposerJsonType!
  "Target SHA of the package."
  targetSha: String!
}
"Conan file metadata"
type ConanFileMetadata implements PackageFileMetadata {
  "Type of the Conan file."
  conanFileType: ConanMetadatumFileTypeEnum!
  "Reference of the Conan package."
  conanPackageReference: String
  "Date of creation."
  createdAt: Time!
  "ID of the metadatum."
  id: PackagesConanFileMetadatumID!
  "Revision of the package."
  packageRevision: String
  "Revision of the Conan recipe."
  recipeRevision: String!
  "Date of most recent update."
  updatedAt: Time!
}
"Conan metadata"
type ConanMetadata {
  "Date of creation."
  createdAt: Time!
  "ID of the metadatum."
  id: PackagesConanMetadatumID!
  "Channel of the Conan package."
  packageChannel: String!
  "Username of the Conan package."
  packageUsername: String!
  "Recipe of the Conan package."
  recipe: String!
  "Recipe path of the Conan package."
  recipePath: String!
  "Date of most recent update."
  updatedAt: Time!
}
"Autogenerated return type of ConfigureSastIac."
type ConfigureSastIacPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}
"Autogenerated return type of ConfigureSast."
type ConfigureSastPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}
"Autogenerated return type of ConfigureSecretDetection."
type ConfigureSecretDetectionPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}
"Connection details for an Agent"
type ConnectedAgent {
  "When the connection was established."
  connectedAt: Time
  "ID of the connection."
  connectionId: BigInt
  "Information about the Agent."
  metadata: AgentMetadata
  "Agent warnings list."
  warnings: [AgentWarning!]
}
"The connection type for ConnectedAgent."
type ConnectedAgentConnection {
  "A list of edges."
  edges: [ConnectedAgentEdge]
  "A list of nodes."
  nodes: [ConnectedAgent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ConnectedAgentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ConnectedAgent
}
"Represents the total number of contacts for the represented states."
type ContactStateCounts {
  "Number of contacts with state `ACTIVE`"
  active: Int
  "Number of contacts with state `ALL`"
  all: Int
  "Number of contacts with state `INACTIVE`"
  inactive: Int
}
"A tag expiration policy designed to keep only the images that matter most"
type ContainerExpirationPolicy {
  "This container expiration policy schedule."
  cadence: ContainerExpirationPolicyCadenceEnum!
  "Timestamp of when the container expiration policy was created."
  createdAt: Time!
  "Indicates whether the container expiration policy is enabled."
  enabled: Boolean!
  "Number of tags to retain."
  keepN: ContainerExpirationPolicyKeepEnum
  "Tags with names matching the regex pattern will expire."
  nameRegex: UntrustedRegexp
  "Tags with names matching the regex pattern will be preserved."
  nameRegexKeep: UntrustedRegexp
  "Next time that the container expiration policy will get executed."
  nextRunAt: Time
  "Tags older than the given age will expire."
  olderThan: ContainerExpirationPolicyOlderThanEnum
  "Timestamp of when the container expiration policy was updated."
  updatedAt: Time!
}
"Represents the most restrictive permissions for a container image tag"
type ContainerProtectionAccessLevel implements AccessLevelInterface {
  "Returns true when tag rule is for tag immutability. Otherwise, false. Introduced in GitLab 17.11: **Status**: Experiment."
  immutable: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.11.")
  "Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can delete tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForDelete: ContainerProtectionTagRuleAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can push tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForPush: ContainerProtectionTagRuleAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
}
"A container repository protection rule designed to prevent users with a certain access level or lower from altering the container registry."
type ContainerProtectionRepositoryRule {
  "ID of the container repository protection rule."
  id: ContainerRegistryProtectionRuleID!
  "Minimum GitLab access level required to delete container images from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForDelete: ContainerProtectionRepositoryRuleAccessLevel
  "Minimum GitLab access level required to push container images to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForPush: ContainerProtectionRepositoryRuleAccessLevel
  "Container repository path pattern protected by the protection rule. Must start with the project’s full path. For example: `my-project/*-prod-*`. Wildcard character `*` is allowed anywhere after the project’s full path."
  repositoryPathPattern: String!
}
"The connection type for ContainerProtectionRepositoryRule."
type ContainerProtectionRepositoryRuleConnection {
  "A list of edges."
  edges: [ContainerProtectionRepositoryRuleEdge]
  "A list of nodes."
  nodes: [ContainerProtectionRepositoryRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ContainerProtectionRepositoryRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContainerProtectionRepositoryRule
}
"A container repository tag protection rule designed to prevent users with a certain access level or lower from altering the container registry."
type ContainerProtectionTagRule implements AccessLevelInterface {
  "ID of the container repository tag protection rule. Introduced in GitLab 17.8: **Status**: Experiment."
  id: ContainerRegistryProtectionTagRuleID! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Returns true when tag rule is for tag immutability. Otherwise, false. Introduced in GitLab 17.11: **Status**: Experiment."
  immutable: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.11.")
  "Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can delete tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForDelete: ContainerProtectionTagRuleAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can push tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForPush: ContainerProtectionTagRuleAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "The pattern that matches container image tags to protect. For example, `v1.*`. Wildcard character `*` allowed. Introduced in GitLab 17.8: **Status**: Experiment."
  tagNamePattern: String! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Permissions for the current user on the resource"
  userPermissions: ContainerRegistryProtectionTagRulePermissions!
}
"The connection type for ContainerProtectionTagRule."
type ContainerProtectionTagRuleConnection {
  "A list of edges."
  edges: [ContainerProtectionTagRuleEdge]
  "A list of nodes."
  nodes: [ContainerProtectionTagRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ContainerProtectionTagRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContainerProtectionTagRule
}
type ContainerRegistryProtectionTagRulePermissions {
  "If `true`, the user can perform `destroy_container_registry_protection_tag_rule` on this resource"
  destroyContainerRegistryProtectionTagRule: Boolean!
}
"A container repository"
type ContainerRepository {
  "Timestamp when the container repository was created."
  createdAt: Time!
  "Tags cleanup status for the container repository."
  expirationPolicyCleanupStatus: ContainerRepositoryCleanupStatus
  "Timestamp when the cleanup done by the expiration policy was started on the container repository."
  expirationPolicyStartedAt: Time
  "ID of the container repository."
  id: ID!
  "Number of deleted tags from the last cleanup."
  lastCleanupDeletedTagsCount: Int
  "URL of the container repository."
  location: String!
  "Migration state of the container repository. Deprecated in GitLab 17.0: Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances."
  migrationState: String! @deprecated(reason: "Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances. Deprecated in GitLab 17.0.")
  "Name of the container repository."
  name: String!
  "Path of the container repository."
  path: String!
  "Project of the container registry."
  project: Project!
  "Whether any matching container protection rule exists for the container repository."
  protectionRuleExists: Boolean!
  "Status of the container repository."
  status: ContainerRepositoryStatus
  "Number of tags associated with the image."
  tagsCount: Int!
  "Timestamp when the container repository was updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryPermissions!
}
"The connection type for ContainerRepository."
type ContainerRepositoryConnection {
  "A list of edges."
  edges: [ContainerRepositoryEdge]
  "A list of nodes."
  nodes: [ContainerRepository]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Details of a container repository"
type ContainerRepositoryDetails {
  "Timestamp when the container repository was created."
  createdAt: Time!
  "Tags cleanup status for the container repository."
  expirationPolicyCleanupStatus: ContainerRepositoryCleanupStatus
  "Timestamp when the cleanup done by the expiration policy was started on the container repository."
  expirationPolicyStartedAt: Time
  "ID of the container repository."
  id: ID!
  "Number of deleted tags from the last cleanup."
  lastCleanupDeletedTagsCount: Int
  "Timestamp when a repository tag was last created or updated. Only present for repositories that had tags created or updated after GitLab 16.11."
  lastPublishedAt: Time
  "URL of the container repository."
  location: String!
  "An image manifest from the container repository."
  manifest(
    "Tag name or digest of the manifest."
    reference: String!
  ): String
  "Migration state of the container repository. Deprecated in GitLab 17.0: Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances."
  migrationState: String! @deprecated(reason: "Returns an empty string. This was used for the migration of GitLab.com, which is now complete. Not used by Self-managed instances. Deprecated in GitLab 17.0.")
  "Name of the container repository."
  name: String!
  "Path of the container repository."
  path: String!
  "Project of the container registry."
  project: Project!
  "Whether any matching container protection rule exists for the container repository."
  protectionRuleExists: Boolean!
  "Deduplicated size of the image repository in bytes. This is only available on GitLab.com for repositories created after `2021-11-04`."
  size: Float
  "Status of the container repository."
  status: ContainerRepositoryStatus
  "Tags of the container repository."
  tags(
    "Sort tags by these criteria."
    sort: ContainerRepositoryTagSort = null,
    "Search by tag name."
    name: String = null,
    "Include tag referrers."
    referrers: Boolean = null,
    "Comma-separated list of artifact types used to filter referrers. Applies only when `referrers` is set to `true`."
    referrerType: String = null,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ContainerRepositoryTagConnection
  "Number of tags associated with the image."
  tagsCount: Int!
  "Timestamp when the container repository was updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryPermissions!
}
"An edge in a connection."
type ContainerRepositoryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContainerRepository
}
type ContainerRepositoryPermissions {
  "If `true`, the user can perform `destroy_container_image` on this resource"
  destroyContainerRepository: Boolean!
}
"A referrer for a container repository tag"
type ContainerRepositoryReferrer {
  "Artifact type of the referrer."
  artifactType: String
  "Digest of the referrer."
  digest: String
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryTagPermissions!
}
"A tag from a container repository"
type ContainerRepositoryTag {
  "Timestamp when the tag was created."
  createdAt: Time
  "Digest of the tag."
  digest: String
  "URL of the tag."
  location: String!
  "Media type of the tag."
  mediaType: String
  "Name of the tag."
  name: String!
  "Path of the tag."
  path: String!
  "Minimum GitLab access level required to push and delete container image tags. If the value is `nil`, no minimum access level is enforced. Users with the Developer role or higher can push tags by default. Introduced in GitLab 17.9: **Status**: Experiment."
  protection: ContainerProtectionAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Timestamp when the tag was published."
  publishedAt: Time
  "Referrers for the tag."
  referrers: [ContainerRepositoryReferrer!]
  "Revision of the tag."
  revision: String
  "Short revision of the tag."
  shortRevision: String
  "Size of the tag."
  totalSize: BigInt
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryTagPermissions!
}
"The connection type for ContainerRepositoryTag."
type ContainerRepositoryTagConnection {
  "A list of edges."
  edges: [ContainerRepositoryTagEdge]
  "A list of nodes."
  nodes: [ContainerRepositoryTag]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ContainerRepositoryTagEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContainerRepositoryTag
}
type ContainerRepositoryTagPermissions {
  "If `true`, the user can perform `destroy_container_image_tag` on this resource"
  destroyContainerRepositoryTag: Boolean!
}
"A tag expiration policy using regex patterns to control which images to keep or expire."
type ContainerTagsExpirationPolicy {
  "Schedule of the container expiration policy."
  cadence: ContainerExpirationPolicyCadenceEnum
  "Timestamp of when the container expiration policy was created."
  createdAt: Time
  "Indicates whether the container expiration policy is enabled."
  enabled: Boolean!
  "Number of tags to retain."
  keepN: ContainerExpirationPolicyKeepEnum
  "Tags with names matching the regex pattern will expire."
  nameRegex: UntrustedRegexp
  "Tags with names matching the regex pattern will be preserved."
  nameRegexKeep: UntrustedRegexp
  "Next time that the container expiration policy will get executed."
  nextRunAt: Time
  "Tags older than the given age will expire."
  olderThan: ContainerExpirationPolicyOlderThanEnum
  "Timestamp of when the container expiration policy was updated."
  updatedAt: Time
}
"Autogenerated return type of CreateAbuseReportNote."
type CreateAbuseReportNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Abuse report note after mutation."
  note: AbuseReportNote
}
"Autogenerated return type of CreateAlertIssue."
type CreateAlertIssuePayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}
"Autogenerated return type of CreateAnnotation."
type CreateAnnotationPayload {
  "Created annotation."
  annotation: MetricsDashboardAnnotation
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CreateBoard."
type CreateBoardPayload {
  "Board after mutation."
  board: Board
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CreateBranch."
type CreateBranchPayload {
  "Branch after mutation."
  branch: Branch
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CreateClusterAgent."
type CreateClusterAgentPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Cluster agent created after mutation."
  clusterAgent: ClusterAgent
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CreateContainerProtectionRepositoryRule."
type CreateContainerProtectionRepositoryRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container repository protection rule after mutation."
  containerProtectionRepositoryRule: ContainerProtectionRepositoryRule
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CreateCustomEmoji."
type CreateCustomEmojiPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "New custom emoji."
  customEmoji: CustomEmoji
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of CreateDiffNote."
type CreateDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"Autogenerated return type of CreateDiscussion."
type CreateDiscussionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"Autogenerated return type of CreateImageDiffNote."
type CreateImageDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"Autogenerated return type of CreateIssue."
type CreateIssuePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of CreateNote."
type CreateNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"Autogenerated return type of CreatePackagesProtectionRule."
type CreatePackagesProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages protection rule after mutation."
  packageProtectionRule: PackagesProtectionRule
}
"Autogenerated return type of CreateSnippet."
type CreateSnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}
"The currently authenticated GitLab user."
type CurrentUser implements Todoable & User {
  "Indicates if the user is active."
  active: Boolean
  "Recent user activity. Introduced in GitLab 17.10: **Status**: Experiment."
  activity: ActivityStream @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests the current user is an assignee or a reviewer of.Ignored if `merge_request_dashboard` feature flag is disabled. Introduced in GitLab 17.4: **Status**: Experiment."
  assigneeOrReviewerMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Reviewer states for merge requests the current user is assigned to."
    assignedReviewStates: [MergeRequestReviewState!],
    "Reviewer states for the merge requests the current user is a reviewer of."
    reviewerReviewStates: [MergeRequestReviewState!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Most-recently viewed issues for the current user. Introduced in GitLab 17.9: **Status**: Experiment."
  recentlyViewedIssues: [Issue!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Most-recently viewed merge requests for the current user. Introduced in GitLab 17.10: **Status**: Experiment."
  recentlyViewedMergeRequests: [MergeRequest!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "User preferences for the given work item type and namespace. Introduced in GitLab 17.10: **Status**: Experiment."
  workItemPreferences(
    "Full path of the namespace the work item is created in."
    namespacePath: ID!,
    "Global ID of a work item type."
    workItemTypeId: WorkItemsTypeID
  ): WorkItemTypesUserPreference @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Find work items visible to the current user. Introduced in GitLab 17.10: **Status**: Experiment."
  workItems(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Filter work items by author username."
    authorUsername: String,
    "Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items."
    confidential: Boolean,
    "Usernames of users assigned to the work item."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with `assigneeUsernames`."
    assigneeWildcardId: AssigneeWildcardId,
    "Labels applied to the work item."
    labelName: [String!],
    "Milestone applied to the work item."
    milestoneTitle: [String!],
    "Filter by milestone ID wildcard. Incompatible with `milestoneTitle`."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported."
    myReactionEmoji: String,
    """
    List of IIDs of work items. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Current state of the work item."
    state: IssuableState,
    "Filter work items by the given work item types."
    types: [IssueType!],
    "Work items created before the timestamp."
    createdBefore: Time,
    "Work items created after the timestamp."
    createdAfter: Time,
    "Work items updated before the timestamp."
    updatedBefore: Time,
    "Work items updated after the timestamp."
    updatedAfter: Time,
    "Work items due before the timestamp."
    dueBefore: Time,
    "Work items due after the timestamp."
    dueAfter: Time,
    "Work items closed before the date."
    closedBefore: Time,
    "Work items closed after the date."
    closedAfter: Time,
    "Work items the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Negated work item arguments."
    not: NegatedWorkItemFilterInput,
    "List of arguments with inclusive `OR`."
    or: UnionedWorkItemFilterInput,
    "Sort work items by criteria."
    sort: WorkItemSort = CREATED_DESC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
}
"A custom emoji uploaded by user"
type CustomEmoji {
  "Timestamp of when the custom emoji was created."
  createdAt: Time!
  "Whether the emoji is an external link."
  external: Boolean!
  "ID of the emoji."
  id: CustomEmojiID!
  "Name of the emoji."
  name: String!
  "Link to file of the emoji."
  url: String!
  "Permissions for the current user on the resource"
  userPermissions: CustomEmojiPermissions!
}
"The connection type for CustomEmoji."
type CustomEmojiConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CustomEmojiEdge]
  "A list of nodes."
  nodes: [CustomEmoji]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type CustomEmojiEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomEmoji
}
type CustomEmojiPermissions {
  "If `true`, the user can perform `create_custom_emoji` on this resource"
  createCustomEmoji: Boolean!
  "If `true`, the user can perform `delete_custom_emoji` on this resource"
  deleteCustomEmoji: Boolean!
  "If `true`, the user can perform `read_custom_emoji` on this resource"
  readCustomEmoji: Boolean!
}
type CustomerRelationsContact {
  "State of the contact."
  active: Boolean!
  "Timestamp the contact was created."
  createdAt: Time!
  "Description of or notes for the contact."
  description: String
  "Email address of the contact."
  email: String
  "First name of the contact."
  firstName: String!
  "Internal ID of the contact."
  id: ID!
  "Last name of the contact."
  lastName: String!
  "Organization of the contact."
  organization: CustomerRelationsOrganization
  "Phone number of the contact."
  phone: String
  "Timestamp the contact was last updated."
  updatedAt: Time!
}
"The connection type for CustomerRelationsContact."
type CustomerRelationsContactConnection {
  "A list of edges."
  edges: [CustomerRelationsContactEdge]
  "A list of nodes."
  nodes: [CustomerRelationsContact]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of CustomerRelationsContactCreate."
type CustomerRelationsContactCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Contact after the mutation."
  contact: CustomerRelationsContact
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type CustomerRelationsContactEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomerRelationsContact
}
"Autogenerated return type of CustomerRelationsContactUpdate."
type CustomerRelationsContactUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Contact after the mutation."
  contact: CustomerRelationsContact
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type CustomerRelationsOrganization {
  "State of the organization."
  active: Boolean!
  "Timestamp the organization was created."
  createdAt: Time!
  "Standard billing rate for the organization."
  defaultRate: Float
  "Description of or notes for the organization."
  description: String
  "Internal ID of the organization."
  id: ID!
  "Name of the organization."
  name: String!
  "Timestamp the organization was last updated."
  updatedAt: Time!
}
"The connection type for CustomerRelationsOrganization."
type CustomerRelationsOrganizationConnection {
  "A list of edges."
  edges: [CustomerRelationsOrganizationEdge]
  "A list of nodes."
  nodes: [CustomerRelationsOrganization]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of CustomerRelationsOrganizationCreate."
type CustomerRelationsOrganizationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after the mutation."
  organization: CustomerRelationsOrganization
}
"An edge in a connection."
type CustomerRelationsOrganizationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomerRelationsOrganization
}
"Autogenerated return type of CustomerRelationsOrganizationUpdate."
type CustomerRelationsOrganizationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after the mutation."
  organization: CustomerRelationsOrganization!
}
"Autogenerated return type of DeleteAnnotation."
type DeleteAnnotationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DeleteContainerProtectionRepositoryRule."
type DeleteContainerProtectionRepositoryRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container repository protection rule that was deleted successfully."
  containerProtectionRepositoryRule: ContainerProtectionRepositoryRule
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DeleteContainerProtectionTagRule."
type DeleteContainerProtectionTagRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Deleted protection rule for container image tags. Introduced in GitLab 17.8: **Status**: Experiment."
  containerProtectionTagRule: ContainerProtectionTagRule @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"The response from the AdminSidekiqQueuesDeleteJobs mutation"
type DeleteJobsResponse {
  "Whether or not the entire queue was processed in time; if not, retrying the same request is safe."
  completed: Boolean
  "Number of matching jobs deleted."
  deletedJobs: Int
  "Queue size after processing."
  queueSize: Int
}
"Autogenerated return type of DeletePackagesProtectionRule."
type DeletePackagesProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages protection rule that was deleted successfully."
  packageProtectionRule: PackagesProtectionRule
}
"Autogenerated return type of DeletePagesDeployment."
type DeletePagesDeploymentPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted Pages Deployment."
  pagesDeployment: PagesDeployment!
}
type DeletedNote {
  "ID of the discussion for the deleted note."
  discussionId: DiscussionID
  "ID of the deleted note."
  id: NoteID!
  "Whether deleted note is the last note in the discussion."
  lastDiscussionNote: Boolean
}
"Dependency proxy blob"
type DependencyProxyBlob {
  "Date of creation."
  createdAt: Time!
  "Name of the blob."
  fileName: String!
  "Size of the blob file."
  size: String!
  "Date of most recent update."
  updatedAt: Time!
}
"The connection type for DependencyProxyBlob."
type DependencyProxyBlobConnection {
  "A list of edges."
  edges: [DependencyProxyBlobEdge]
  "A list of nodes."
  nodes: [DependencyProxyBlob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DependencyProxyBlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DependencyProxyBlob
}
"Group-level Dependency Proxy TTL policy settings"
type DependencyProxyImageTtlGroupPolicy {
  "Timestamp of creation."
  createdAt: Time
  "Indicates whether the policy is enabled or disabled."
  enabled: Boolean!
  "Number of days to retain a cached image file."
  ttl: Int
  "Timestamp of the most recent update."
  updatedAt: Time
}
"Dependency proxy manifest"
type DependencyProxyManifest {
  "Date of creation."
  createdAt: Time!
  "Digest of the manifest."
  digest: String!
  "Name of the manifest."
  fileName: String!
  "ID of the manifest."
  id: DependencyProxyManifestID!
  "Name of the image."
  imageName: String!
  "Size of the manifest file."
  size: String!
  "Status of the manifest (default, pending_destruction, processing, error)"
  status: DependencyProxyManifestStatus!
  "Date of most recent update."
  updatedAt: Time!
}
"The connection type for DependencyProxyManifest."
type DependencyProxyManifestConnection {
  "A list of edges."
  edges: [DependencyProxyManifestEdge]
  "A list of nodes."
  nodes: [DependencyProxyManifest]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DependencyProxyManifestEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DependencyProxyManifest
}
"Group-level Dependency Proxy settings"
type DependencyProxySetting {
  "Indicates whether the dependency proxy is enabled for the group."
  enabled: Boolean!
  "Identity credential used to authenticate with Docker Hub when pulling images. Can be a username (for password or personal access token (PAT)) or organization name (for organization access token (OAT))."
  identity: String
}
"The deployment of an environment"
type Deployment {
  "Commit details of the deployment."
  commit: Commit
  "When the deployment record was created."
  createdAt: Time
  "When the deployment finished."
  finishedAt: Time
  "Global ID of the deployment."
  id: ID
  "Project-level internal ID of the deployment."
  iid: String
  "Pipeline job of the deployment."
  job: CiJob
  "Git-Ref that the deployment ran on."
  ref: String
  "Path to the Git-Ref that the deployment ran on."
  refPath: String
  "Git-SHA that the deployment ran on."
  sha: String
  "Status of the deployment."
  status: DeploymentStatus
  "True or false if the deployment ran on a Git-tag."
  tag: Boolean
  "Git tags that contain this deployment. This field can only be resolved for two deployments in any single request."
  tags: [DeploymentTag!]
  "User who executed the deployment."
  triggerer: UserCore
  "When the deployment record was updated."
  updatedAt: Time
  "Permissions for the current user on the resource"
  userPermissions: DeploymentPermissions!
  "Web path to the deployment page."
  webPath: String
}
"The connection type for Deployment."
type DeploymentConnection {
  "A list of edges."
  edges: [DeploymentEdge]
  "A list of nodes."
  nodes: [Deployment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DeploymentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Deployment
}
type DeploymentPermissions {
  "If `true`, the user can perform `destroy_deployment` on this resource"
  destroyDeployment: Boolean!
  "If `true`, the user can perform `update_deployment` on this resource"
  updateDeployment: Boolean!
}
"Tags for a given deployment"
type DeploymentTag {
  "Name of the git tag."
  name: String
  "Path for the tag."
  path: String
  "Web path for the tag."
  webPath: String
}
type DescriptionVersion {
  "Content of the given description version."
  description: String
  "ID of the description version."
  id: DescriptionVersionID!
}
"A single design"
type Design implements CurrentUserTodos & DesignFields & NoteableInterface & Todoable {
  "All commenters on the noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Description of the design."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Diff refs for the design."
  diffRefs: DiffRefs!
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "How the design was changed in the current version."
  event: DesignVersionEvent!
  "Filename of the design."
  filename: String!
  "Full path to the design file."
  fullPath: ID!
  "ID of the design."
  id: ID!
  "URL of the full-sized image."
  image: String!
  "The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated"
  imageV432x230: String
  "Indicates whether the design was imported."
  imported: Boolean!
  "Import source of the design."
  importedFrom: ImportSource!
  "Issue the design belongs to."
  issue: Issue!
  "Name or title of the object."
  name: String
  "All notes on this noteable."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Total count of user-created notes for the design."
  notesCount: Int!
  "Project the design belongs to."
  project: Project!
  "All versions related to this design ordered newest first."
  versions(
    "SHA256 of the most recent acceptable version."
    earlierOrEqualToSha: String,
    "Global ID of the most recent acceptable version."
    earlierOrEqualToId: DesignManagementVersionID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignVersionConnection!
  "URL of the design."
  webUrl: String!
}
"A design pinned to a specific version. The image field reflects the design as of the associated version"
type DesignAtVersion implements DesignFields {
  "Underlying design."
  design: Design!
  "Diff refs for the design."
  diffRefs: DiffRefs!
  "How the design was changed in the current version."
  event: DesignVersionEvent!
  "Filename of the design."
  filename: String!
  "Full path to the design file."
  fullPath: ID!
  "ID of the design."
  id: ID!
  "URL of the full-sized image."
  image: String!
  "The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated"
  imageV432x230: String
  "Issue the design belongs to."
  issue: Issue!
  "Total count of user-created notes for the design."
  notesCount: Int!
  "Project the design belongs to."
  project: Project!
  "Version the design-at-versions is pinned to."
  version: DesignVersion!
}
"The connection type for DesignAtVersion."
type DesignAtVersionConnection {
  "A list of edges."
  edges: [DesignAtVersionEdge]
  "A list of nodes."
  nodes: [DesignAtVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DesignAtVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesignAtVersion
}
"A collection of designs"
type DesignCollection {
  "Copy state of the design collection."
  copyState: DesignCollectionCopyState
  "Find a specific design."
  design(
    "Find a design by its ID."
    id: DesignManagementDesignID,
    "Find a design by its filename."
    filename: String
  ): Design
  "Find a design as of a version."
  designAtVersion(
    "Global ID of the design at the version."
    id: DesignManagementDesignAtVersionID!
  ): DesignAtVersion
  "All designs for the design collection."
  designs(
    "Filters designs to only those that existed at the version. If argument is omitted or nil then all designs will reflect the latest version"
    atVersion: DesignManagementVersionID,
    "Filters designs by their filename."
    filenames: [String!],
    "Filters designs by their ID."
    ids: [DesignManagementDesignID!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignConnection!
  "Issue associated with the design collection."
  issue: Issue!
  "Project associated with the design collection."
  project: Project!
  "A specific version."
  version(
    "Global ID of the version."
    id: DesignManagementVersionID,
    "SHA256 of a specific version."
    sha: String
  ): DesignVersion
  "All versions related to all designs, ordered newest first."
  versions(
    "SHA256 of the most recent acceptable version."
    earlierOrEqualToSha: String,
    "Global ID of the most recent acceptable version."
    earlierOrEqualToId: DesignManagementVersionID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignVersionConnection!
}
"The connection type for Design."
type DesignConnection {
  "A list of edges."
  edges: [DesignEdge]
  "A list of nodes."
  nodes: [Design]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DesignEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Design
}
type DesignManagement {
  "Find a design as of a version."
  designAtVersion(
    "Global ID of the design at the version."
    id: DesignManagementDesignAtVersionID!
  ): DesignAtVersion
  "Find a version."
  version(
    "Global ID of the version."
    id: DesignManagementVersionID!
  ): DesignVersion
}
"Autogenerated return type of DesignManagementDelete."
type DesignManagementDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "New version in which the designs are deleted."
  version: DesignVersion
}
"Autogenerated return type of DesignManagementMove."
type DesignManagementMovePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Current state of the collection."
  designCollection: DesignCollection
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DesignManagementUpdate."
type DesignManagementUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Updated design."
  design: Design!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DesignManagementUpload."
type DesignManagementUploadPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Designs that were uploaded by the mutation."
  designs: [Design!]!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Any designs that were skipped from the upload due to there being no change to their content since their last version"
  skippedDesigns: [Design!]!
}
"A specific version in which designs were added, modified or deleted"
type DesignVersion {
  "Author of the version."
  author: UserCore!
  "Timestamp of when the version was created."
  createdAt: Time!
  "A particular design as of this version, provided it is visible at this version."
  designAtVersion(
    "ID of a specific design."
    designId: DesignManagementDesignID,
    "Filename of a specific design."
    filename: String,
    "ID of the DesignAtVersion."
    id: DesignManagementDesignAtVersionID
  ): DesignAtVersion!
  "All designs that were changed in the version."
  designs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignConnection!
  "All designs that are visible at this version, as of this version."
  designsAtVersion(
    "Filters designs by their filename."
    filenames: [String!],
    "Filters designs by their ID."
    ids: [DesignManagementDesignID!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignAtVersionConnection!
  "ID of the design version."
  id: ID!
  "SHA of the design version."
  sha: ID!
}
"The connection type for DesignVersion."
type DesignVersionConnection {
  "A list of edges."
  edges: [DesignVersionEdge]
  "A list of nodes."
  nodes: [DesignVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DesignVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesignVersion
}
"Autogenerated return type of DestroyBoardList."
type DestroyBoardListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "List after mutation."
  list: BoardList
}
"Autogenerated return type of DestroyBoard."
type DestroyBoardPayload {
  "Board after mutation."
  board: Board
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroyContainerRepository."
type DestroyContainerRepositoryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container repository policy after scheduling the deletion."
  containerRepository: ContainerRepository!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroyContainerRepositoryTags."
type DestroyContainerRepositoryTagsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Deleted container repository tags."
  deletedTagNames: [String!]!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroyCustomEmoji."
type DestroyCustomEmojiPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Deleted custom emoji."
  customEmoji: CustomEmoji
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroyNote."
type DestroyNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"Autogenerated return type of DestroyPackageFile."
type DestroyPackageFilePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroyPackageFiles."
type DestroyPackageFilesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroyPackage."
type DestroyPackagePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroyPackages."
type DestroyPackagesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of DestroySnippet."
type DestroySnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}
"Details of the import status of a project."
type DetailedImportStatus {
  "ID of the import state."
  id: ProjectImportStateID
  "Last error of the import."
  lastError: String
  "Time of the last successful update."
  lastSuccessfulUpdateAt: Time
  "Time of the last update."
  lastUpdateAt: Time
  "Time of the start of the last update."
  lastUpdateStartedAt: Time
  "Current status of the import."
  status: String
  "Import url."
  url: String
}
type DetailedStatus {
  "Action information for the status. This includes method, button title, icon, path, and title."
  action: StatusAction
  "Path of the details for the status."
  detailsPath: String
  "Favicon of the status."
  favicon: String
  "Group of the status. Deprecated in GitLab 16.4: The `group` attribute is deprecated. Use `name` instead."
  group: String @deprecated(reason: "The `group` attribute is deprecated. Use `name` instead. Deprecated in GitLab 16.4.")
  "Indicates if the status has further details."
  hasDetails: Boolean
  "Icon of the status. Deprecated in GitLab 16.4: The `icon` attribute is deprecated. Use `name` to identify the status to display instead."
  icon: String @deprecated(reason: "The `icon` attribute is deprecated. Use `name` to identify the status to display instead. Deprecated in GitLab 16.4.")
  "ID for a detailed status."
  id: String!
  "Human-readable label of the status (e.g. success)."
  label: String
  "Machine-readable status name (e.g. SUCCESS)."
  name: String
  "Text of the status. Deprecated in GitLab 16.4: The `text` attribute is being deprecated. Use `label` instead."
  text: String @deprecated(reason: "The `text` attribute is being deprecated. Use `label` instead. Deprecated in GitLab 16.4.")
  "Tooltip associated with the status."
  tooltip: String
}
type Diff {
  "Old file mode of the file."
  aMode: String
  "New file mode of the file."
  bMode: String
  "Indicates if the file has been removed. "
  deletedFile: String
  "Diff representation of the changes made to the file."
  diff: String
  "Indicates if the file has just been added. "
  newFile: String
  "New path of the file."
  newPath: String
  "Old path of the file."
  oldPath: String
  "Indicates if the file has been renamed."
  renamedFile: String
}
type DiffPosition {
  "Information about the branch, HEAD, and base at the time of commenting."
  diffRefs: DiffRefs!
  "Path of the file that was changed."
  filePath: String!
  "Total height of the image."
  height: Int
  "Line on HEAD SHA that was changed."
  newLine: Int
  "Path of the file on the HEAD SHA."
  newPath: String
  "Line on start SHA that was changed."
  oldLine: Int
  "Path of the file on the start SHA."
  oldPath: String
  "Type of file the position refers to."
  positionType: DiffPositionType!
  "Total width of the image."
  width: Int
  "X position of the note."
  x: Int
  "Y position of the note."
  y: Int
}
type DiffRefs {
  "Merge base of the branch the comment was made on."
  baseSha: String
  "SHA of the HEAD at the time the comment was made."
  headSha: String!
  "SHA of the branch being compared against."
  startSha: String!
}
"Changes to a single file"
type DiffStats {
  "Number of lines added to the file."
  additions: Int!
  "Number of lines deleted from the file."
  deletions: Int!
  "File path, relative to repository root."
  path: String!
}
"Aggregated summary of changes"
type DiffStatsSummary {
  "Number of lines added."
  additions: Int!
  "Number of lines changed."
  changes: Int!
  "Number of lines deleted."
  deletions: Int!
  "Number of files changed."
  fileCount: Int!
}
type Discussion implements BaseDiscussionInterface & ResolvableInterface {
  "Timestamp of the discussion's creation."
  createdAt: Time!
  "ID of the discussion."
  id: DiscussionID!
  "Object which the discussion belongs to."
  noteable: NoteableType
  "All notes in the discussion."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "ID used to reply to the discussion."
  replyId: DiscussionID!
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
  "Permissions for the current user on the resource"
  userPermissions: DiscussionPermissions!
}
"The connection type for Discussion."
type DiscussionConnection {
  "A list of edges."
  edges: [DiscussionEdge]
  "A list of nodes."
  nodes: [Discussion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type DiscussionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Discussion
}
type DiscussionPermissions {
  "If `true`, the user can perform `resolve_note` on this resource"
  resolveNote: Boolean!
}
"Autogenerated return type of DiscussionToggleResolve."
type DiscussionToggleResolvePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Discussion after mutation."
  discussion: Discussion
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of EchoCreate."
type EchoCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Messages returned to the user."
  echoes: [String!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type EgressNode {
  "Artifacts egress for that project in that period of time."
  artifactsEgress: BigInt!
  "First day of the node range. There is one node per month."
  date: String!
  "Packages egress for that project in that period of time."
  packagesEgress: BigInt!
  "Registry egress for that project in that period of time."
  registryEgress: BigInt!
  "Repository egress for that project in that period of time."
  repositoryEgress: BigInt!
  "Total egress for that project in that period of time."
  totalEgress: BigInt!
}
"The connection type for EgressNode."
type EgressNodeConnection {
  "A list of edges."
  edges: [EgressNodeEdge]
  "A list of nodes."
  nodes: [EgressNode]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type EgressNodeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EgressNode
}
type Email {
  "Timestamp the email was confirmed."
  confirmedAt: Time
  "Timestamp the email was created."
  createdAt: Time!
  "Email address."
  email: String!
  "Internal ID of the email."
  id: ID!
  "Timestamp the email was last updated."
  updatedAt: Time!
}
"The connection type for Email."
type EmailConnection {
  "A list of edges."
  edges: [EmailEdge]
  "A list of nodes."
  nodes: [Email]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type EmailEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Email
}
type EmailParticipantType {
  "Email address of the email participant. For guests, the email address is obfuscated."
  email: String!
}
"The connection type for EmailParticipantType."
type EmailParticipantTypeConnection {
  "A list of edges."
  edges: [EmailParticipantTypeEdge]
  "A list of nodes."
  nodes: [EmailParticipantType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type EmailParticipantTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EmailParticipantType
}
"Describes where code is deployed for a project"
type Environment {
  "When the environment is going to be deleted automatically."
  autoDeleteAt: Time
  "When the environment is going to be stopped automatically."
  autoStopAt: Time
  "Auto stop setting of the environment."
  autoStopSetting: AutoStopSetting
  "Cluster agent of the environment."
  clusterAgent: ClusterAgent
  "When the environment was created."
  createdAt: Time
  "Deployment freeze periods of the environment."
  deployFreezes: [CiFreezePeriod!]
  "Deployments of the environment. This field can only be resolved for one environment in any single request."
  deployments(
    "Statuses of the deployments."
    statuses: [DeploymentStatus!],
    "Order by a specified field."
    orderBy: DeploymentsOrderByInput,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DeploymentConnection
  """
  Number of deployments in the environment for display. Returns the precise number up to 999, and "999+" for counts exceeding this limit.
  """
  deploymentsDisplayCount: String
  "Description of the environment."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Folder name of the environment."
  environmentType: String
  "External URL of the environment."
  externalUrl: String
  "Flux resource path of the environment."
  fluxResourcePath: String
  "ID of the environment."
  id: ID!
  "Kubernetes namespace of the environment."
  kubernetesNamespace: String
  "Last deployment of the environment."
  lastDeployment(
    "Status of the Deployment."
    status: DeploymentStatus!
  ): Deployment
  "Most severe open alert for the environment. If multiple alerts have equal severity, the most recent is returned."
  latestOpenedMostSevereAlert: AlertManagementAlert
  "Human-readable name of the environment."
  name: String!
  "Path to the environment."
  path: String!
  "Slug of the environment."
  slug: String
  "State of the environment, for example: available/stopped."
  state: String!
  "Deployment tier of the environment."
  tier: DeploymentTier
  "When the environment was updated."
  updatedAt: Time
  "Permissions for the current user on the resource. This field can only be resolved for one environment in any single request."
  userPermissions: EnvironmentPermissions!
}
"The connection type for Environment."
type EnvironmentConnection {
  "A list of edges."
  edges: [EnvironmentEdge]
  "A list of nodes."
  nodes: [Environment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of EnvironmentCreate."
type EnvironmentCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Created environment."
  environment: Environment
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of EnvironmentDelete."
type EnvironmentDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type EnvironmentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Environment
}
type EnvironmentPermissions {
  "If `true`, the user can perform `destroy_environment` on this resource"
  destroyEnvironment: Boolean!
  "If `true`, the user can perform `stop_environment` on this resource"
  stopEnvironment: Boolean!
  "If `true`, the user can perform `update_environment` on this resource"
  updateEnvironment: Boolean!
}
"Autogenerated return type of EnvironmentStop."
type EnvironmentStopPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Environment after attempt to stop."
  environment: Environment
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of EnvironmentUpdate."
type EnvironmentUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Environment after attempt to update."
  environment: Environment
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of EnvironmentsCanaryIngressUpdate."
type EnvironmentsCanaryIngressUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Represents a stack trace"
type ErrorTrackingStackTrace {
  "Absolute path of the stack trace."
  absolutePath: String
  "Column number of the stack trace."
  columnNumber: Int
  "Context of the stack trace."
  context: [WorkItemWidgetErrorTrackingStackTraceContext!]
  "Filename of the stack trace."
  filename: String
  "Name of the function where the error occured."
  function: String
  "Line number of the stack trace."
  lineNumber: Int
}
"The connection type for ErrorTrackingStackTrace."
type ErrorTrackingStackTraceConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ErrorTrackingStackTraceEdge]
  "A list of nodes."
  nodes: [ErrorTrackingStackTrace]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ErrorTrackingStackTraceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ErrorTrackingStackTrace
}
"Representing an event"
type Event {
  "Action of the event."
  action: EventAction!
  "Author of the event."
  author: UserCore!
  "When the event was created."
  createdAt: Time!
  "ID of the event."
  id: ID!
  "Project of the event."
  project: Project
  "Target of the event."
  target: EventTargetType
  "When the event was updated."
  updatedAt: Time!
}
"The connection type for Event."
type EventConnection {
  "A list of edges."
  edges: [EventEdge]
  "A list of nodes."
  nodes: [Event]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type EventEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Event
}
type FileUpload {
  "Global ID of the upload."
  id: UploadID!
  "Path of the upload."
  path: String!
  "Size of the upload in bytes."
  size: Int!
}
"Details of the fork project compared to its upstream project."
type ForkDetails {
  "Number of commits ahead of upstream."
  ahead: Int
  "Number of commits behind upstream."
  behind: Int
  "Indicates if the fork conflicts with its upstream project."
  hasConflicts: Boolean
  "Indicates if there is a synchronization in progress."
  isSyncing: Boolean
}
"A feature flag for the GitLab instance."
type GitlabInstanceFeatureFlag {
  "Indicates whether the GitLab instance feature flag is enabled or not."
  enabled: Boolean!
  "Name of the GitLab instance feature flag."
  name: String!
}
"GPG signature for a signed commit"
type GpgSignature implements CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "ID of the GPG key."
  gpgKeyPrimaryKeyid: String
  "User email associated with the GPG key."
  gpgKeyUserEmail: String
  "User name associated with the GPG key."
  gpgKeyUserName: String
  "Project of the associated commit."
  project: Project
  "User associated with the key."
  user: UserCore
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
}
type GrafanaIntegration {
  "Timestamp of the issue's creation."
  createdAt: Time!
  "Indicates whether Grafana integration is enabled."
  enabled: Boolean!
  "URL for the Grafana host for the Grafana integration."
  grafanaUrl: String!
  "Internal ID of the Grafana integration."
  id: ID!
  "Timestamp of the issue's last activity."
  updatedAt: Time!
}
type Group implements GroupInterface & Todoable {
  "Achievements for the namespace. Returns `null` if the `achievements` feature flag is disabled. Introduced in GitLab 15.8: **Status**: Experiment."
  achievements(
    "Filter achievements by IDs."
    ids: [AchievementsAchievementID!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
  "Path for the namespace's achievements. Returns `null` if the namespace is not a group, or the `achievements` feature flag is disabled. Introduced in GitLab 17.0: **Status**: Experiment."
  achievementsPath: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  "Indicates whether Auto DevOps is enabled for all projects within the group."
  autoDevopsEnabled: Boolean
  "Search users for autocompletion"
  autocompleteUsers(
    "Query to search users by name, username, or public email."
    search: String
  ): [AutocompletedUser!]
  "Avatar URL of the group."
  avatarUrl: String
  "A single board of the group."
  board(
    "ID of the board."
    id: BoardID!
  ): Board
  "Boards of the group."
  boards(
    "Find a board by its ID."
    id: BoardID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "Namespace CI/CD settings for the namespace. Introduced in GitLab 17.9: **Status**: Experiment."
  ciCdSettings: CiCdSettings @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "List of the group's CI/CD variables."
  ciVariables(
    "Sort order of results."
    sort: CiVariableSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiGroupVariableConnection
  "Cluster agents associated with projects in the group and its subgroups."
  clusterAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentConnection
  "Counts of contacts by state for the group."
  contactStateCounts(
    "Search term to find contacts with."
    search: String,
    "State of the contacts to search for."
    state: CustomerRelationsContactState
  ): ContactStateCounts
  "Find contacts of this group."
  contacts(
    "Criteria to sort contacts by."
    sort: ContactSort = LAST_NAME_ASC,
    "Search term to find contacts with."
    search: String,
    "State of the contacts to search for."
    state: CustomerRelationsContactState,
    "Filter contacts by IDs."
    ids: [CustomerRelationsContactID!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomerRelationsContactConnection
  "Container repositories of the group."
  containerRepositories(
    "Filter the container repositories by their name."
    name: String,
    "Sort container repositories by the criteria."
    sort: ContainerRepositorySort = created_desc,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ContainerRepositoryConnection
  "Number of container repositories in the group."
  containerRepositoriesCount: Int!
  "Timestamp of the group creation."
  createdAt: Time
  "Indicates if the cross_project_pipeline feature is available for the namespace."
  crossProjectPipelineAvailable: Boolean!
  "Custom emoji in this namespace."
  customEmoji(
    "Includes custom emoji from parent groups."
    includeAncestorGroups: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomEmojiConnection
  "Data transfer data point for a specific period. This is mocked data under a development feature flag."
  dataTransfer(
    "Retain egress data for one year. Data for the current month will increase dynamically as egress occurs."
    from: Date,
    "End date for the data."
    to: Date
  ): GroupDataTransfer
  "Number of dependency proxy blobs cached in the group."
  dependencyProxyBlobCount: Int!
  "Dependency Proxy blobs."
  dependencyProxyBlobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DependencyProxyBlobConnection
  "Number of dependency proxy images cached in the group."
  dependencyProxyImageCount: Int!
  "Prefix for pulling images when using the dependency proxy."
  dependencyProxyImagePrefix: String!
  "Dependency proxy TTL policy for the group."
  dependencyProxyImageTtlPolicy: DependencyProxyImageTtlGroupPolicy
  "Dependency Proxy manifests."
  dependencyProxyManifests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DependencyProxyManifestConnection
  "Dependency Proxy settings for the group."
  dependencyProxySetting: DependencyProxySetting
  "Total size of the dependency proxy cached images."
  dependencyProxyTotalSize: String!
  "Total size of the dependency proxy cached images in bytes, encoded as a string."
  dependencyProxyTotalSizeBytes: BigInt!
  "Total size of the dependency proxy cached images in bytes. Deprecated in GitLab 16.1: Use `dependencyProxyTotalSizeBytes`."
  dependencyProxyTotalSizeInBytes: Int! @deprecated(reason: "Use `dependencyProxyTotalSizeBytes`. Deprecated in GitLab 16.1.")
  "List of descendant groups of this group."
  descendantGroups(
    "List of descendant groups of the parent group."
    includeParentDescendants: Boolean = true,
    "Limit result to groups owned by authenticated user."
    owned: Boolean,
    "Search query for group name or group full path."
    search: String,
    "Filter groups by IDs."
    ids: [ID!],
    "Sort groups by given criteria."
    sort: GroupSort = NAME_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Count of direct descendant groups of the group."
  descendantGroupsCount: Int!
  "Description of the namespace."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Indicates if a group has email notifications disabled."
  emailsDisabled: Boolean
  "Indicates if a group has email notifications enabled."
  emailsEnabled: Boolean
  "Environment scopes of the group."
  environmentScopes(
    "Name of the environment scope."
    name: String,
    "Search query for environment scope name."
    search: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiGroupEnvironmentScopeConnection
  "Full name of the group."
  fullName: String
  "Full path of the namespace."
  fullPath: ID!
  "A membership of a user within this group."
  groupMembers(
    "Search query."
    search: String,
    "sort query."
    sort: MemberSort,
    "Filter members by the given member relations."
    relations: [GroupMemberRelation!] = [DIRECT, INHERITED],
    "Filter members by the given access levels."
    accessLevels: [AccessLevelEnum!],
    "Filter members by enterprise users."
    enterprise: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Count of direct members of the group."
  groupMembersCount: Int!
  "ID of the group."
  id: ID
  "Import source users of the namespace. This field can only be resolved for one namespace in any single request. Introduced in GitLab 17.2: **Status**: Experiment."
  importSourceUsers(
    "Filter mapping of users on source instance to users on destination instance by status."
    statuses: [ImportSourceUserStatus!],
    "Query to search mappings by name or username of users on source instance."
    search: String,
    "Sort mapping of users on source instance to users on destination instance by the criteria."
    sort: SourceUserSort = SOURCE_NAME_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ImportSourceUserConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  "Indicates if delayed group deletion is enabled. Introduced in GitLab 16.11: **Status**: Experiment."
  isAdjournedDeletionEnabled: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Indicates if group is linked to a subscription."
  isLinkedToSubscription: Boolean
  "Issues for projects in this group."
  issues(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    """
    ID of a user assigned to the issues. Wildcard values "NONE" and "ANY" are supported.
    """
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Issues closed after the date."
    closedAfter: Time,
    "Issues closed before the date."
    closedBefore: Time,
    """
    Filter for confidential issues. If "false", excludes confidential issues. If "true", returns only confidential issues.
    """
    confidential: Boolean,
    "Issues created after the date."
    createdAfter: Time,
    "Issues created before the date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "Return issues due on or after the given time."
    dueAfter: Time,
    "Return issues due on or before the given time."
    dueBefore: Time,
    """
    IID of the issue. For example, "1".
    """
    iid: String,
    """
    List of IIDs of issues. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Labels applied to the issue."
    labelName: [String],
    "Milestone applied to the issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    """
    Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.
    """
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Issues the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after the date."
    updatedAfter: Time,
    "Issues updated before the date."
    updatedBefore: Time,
    "Sort issues by the criteria."
    sort: IssueSort = created_desc,
    "Current state of the issue."
    state: IssuableState,
    "Include issues belonging to subgroups"
    includeSubgroups: Boolean = false,
    "Return issues from archived projects"
    includeArchived: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssueConnection
  "Label available on the group."
  label(
    "Title of the label."
    title: String!
  ): Label
  "Labels available on this group."
  labels(
    "Exact match on title. Cannot be used with `searchTerm`. `searchIn` will be ignored if `title` argument is provided."
    title: String,
    "Search term to find labels with."
    searchTerm: String,
    "Specify which fields to search in. Ignored if using `title`."
    searchIn: [LabelSearchFieldList!]! = [TITLE, DESCRIPTION],
    "Include labels from ancestor groups."
    includeAncestorGroups: Boolean = false,
    "Include labels from descendant groups."
    includeDescendantGroups: Boolean = false,
    "Include only group level labels."
    onlyGroupLabels: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Indicates if Large File Storage (LFS) is enabled for namespace."
  lfsEnabled: Boolean
  "Indicates if math rendering limits are locked for all descendant groups."
  lockMathRenderingLimitsEnabled: Boolean
  "Date when group was scheduled to be deleted. Introduced in GitLab 16.11: **Status**: Experiment."
  markedForDeletionOn: Time @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Indicates if math rendering limits are used for the group."
  mathRenderingLimitsEnabled: Boolean
  "Maximum access level of the current user in the group."
  maxAccessLevel: AccessLevel!
  "Indicates if a group is disabled from getting mentioned."
  mentionsDisabled: Boolean
  "Merge requests for projects in this group."
  mergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    "Include merge requests belonging to subgroups"
    includeSubgroups: Boolean = false,
    "Return merge requests from archived projects"
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Milestones of the group."
  milestones(
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    """
    Array of global milestone IDs, e.g., `"gid://gitlab/Milestone/1"`.
    """
    ids: [ID!],
    "Filter milestones by state."
    state: MilestoneStateEnum,
    "Title of the milestone."
    title: String,
    "Search string for the title."
    searchTitle: String,
    "Date the milestone contains."
    containingDate: Time,
    "Sort milestones by the criteria."
    sort: MilestoneSort = DUE_DATE_ASC,
    "Include milestones from all parent groups."
    includeAncestors: Boolean,
    "Include milestones from all subgroups and subprojects."
    includeDescendants: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MilestoneConnection
  "Name of the group."
  name: String
  "Path for editing group at the organization level. Introduced in GitLab 17.1: **Status**: Experiment."
  organizationEditPath: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  "Counts of organizations by status for the group."
  organizationStateCounts(
    "Search term to find organizations with."
    search: String,
    "State of the organizations to search for."
    state: CustomerRelationsOrganizationState
  ): OrganizationStateCounts
  "Find organizations of this group."
  organizations(
    "Criteria to sort organizations by."
    sort: OrganizationSort = NAME_ASC,
    "Search term used to find organizations with."
    search: String,
    "State of the organization to search for."
    state: CustomerRelationsOrganizationState,
    "Filter organizations by IDs."
    ids: [CustomerRelationsOrganizationID!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomerRelationsOrganizationConnection
  "Package settings for the namespace."
  packageSettings: PackageSettings
  "Packages of the group. This field can only be resolved for one group in any single request."
  packages(
    "Sort packages by the criteria."
    sort: PackageGroupSort = CREATED_DESC,
    "Search a package by name."
    packageName: String = null,
    "Filter a package by type."
    packageType: PackageTypeEnum = null,
    """
    Filter a package by version. If used in combination with `include_versionless`,
              then no versionless packages are returned.
    """
    packageVersion: String = null,
    "Filter a package by status."
    status: PackageStatus = null,
    "Include versionless packages."
    includeVersionless: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageConnection
  "List of the namespaces's Pages Deployments."
  pagesDeployments(
    "Filter by active or inactive state."
    active: Boolean,
    "Sort results."
    sort: Sort,
    """
    Filter deployments that are
    versioned or unversioned.
    """
    versioned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PagesDeploymentConnection
  "Parent group."
  parent: Group
  "Path of the namespace."
  path: String!
  "Date when group will be deleted if delayed group deletion is enabled. Introduced in GitLab 16.11: **Status**: Experiment."
  permanentDeletionDate: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Pipeline analytics."
  pipelineAnalytics: PipelineAnalytics
  "Permission level required to create projects in the group."
  projectCreationLevel: String
  "Projects within this namespace. Returns projects from the parent group if namespace is project."
  projects(
    "Include also subgroup projects."
    includeSubgroups: Boolean = false,
    "Include also archived projects."
    includeArchived: Boolean = true,
    "Include projects that are not aimed for deletion."
    notAimedForDeletion: Boolean = false,
    "Search project with most similar names or paths."
    search: String = null,
    "Sort projects by the criteria."
    sort: NamespaceProjectSort = null,
    "Filter projects by IDs."
    ids: [ID!] = null,
    "Return only projects with issues enabled."
    withIssuesEnabled: Boolean,
    "Return only projects with merge requests enabled."
    withMergeRequestsEnabled: Boolean,
    "Return only projects that use the namespace domain for pages projects."
    withNamespaceDomainPages: Boolean,
    "Return only archived projects."
    archivedOnly: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection!
  "Count of direct projects in the group."
  projectsCount: Int!
  "List of recently visited boards of the group. Maximum size is 4."
  recentIssueBoards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "Releases belonging to projects in the group."
  releases(
    "Sort group releases by given criteria."
    sort: GroupReleaseSort = RELEASED_AT_DESC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseConnection
  "Indicates if users can request access to namespace."
  requestAccessEnabled: Boolean
  "Indicates if all users in the group are required to set up two-factor authentication."
  requireTwoFactorAuthentication: Boolean
  "Aggregated storage statistics of the namespace. Only available for root namespaces."
  rootStorageStatistics: RootStorageStatistics
  "Find runners visible to the current user."
  runners(
    "Filter runners by `paused` (true) or `active` (false) status."
    paused: Boolean,
    "Filter runners by status."
    status: CiRunnerStatus,
    "Filter runners by type."
    type: CiRunnerType,
    "Filter by tags associated with the runner (comma-separated or array)."
    tagList: [String!],
    "Filter by full token or partial text in description field."
    search: String,
    "Sort order of results."
    sort: CiRunnerSort,
    "Filter by upgrade status."
    upgradeStatus: CiRunnerUpgradeStatus,
    "Filter runners by creator ID."
    creatorId: UserID,
    "Control which runners to include in the results."
    membership: CiRunnerMembershipFilter = DESCENDANTS,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiRunnerConnection
  "Indicates if sharing a project with another group within the group is prevented."
  shareWithGroupLock: Boolean
  "Shared runners availability for the namespace and its descendants."
  sharedRunnersSetting: SharedRunnersSetting
  "Data needed to render the sidebar for the namespace. Introduced in GitLab 17.6: **Status**: Experiment."
  sidebar: NamespaceSidebar @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Permission level required to create subgroups within the group."
  subgroupCreationLevel: String
  "Timelog categories for the namespace. Introduced in GitLab 15.3: **Status**: Experiment."
  timelogCategories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimeTrackingTimelogCategoryConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.3.")
  "Time logged on issues and merge requests in the group and its subgroups."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection!
  "Time before two-factor authentication is enforced."
  twoFactorGracePeriod: Int
  "Timestamp of when the group was last updated."
  updatedAt: Time
  "Permissions for the current user on the resource"
  userPermissions: GroupPermissions!
  "Visibility of the namespace."
  visibility: String
  "Web URL of the group."
  webUrl: String!
  "Find a work item by IID directly associated with the group. Returns `null` if the `namespace_level_work_items` feature flag is disabled. Introduced in GitLab 16.4: **Status**: Experiment."
  workItem(
    "IID of the work item."
    iid: String!
  ): WorkItem @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "Work item description templates available to the namespace. Introduced in GitLab 17.6: **Status**: Experiment."
  workItemDescriptionTemplates(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemDescriptionTemplateConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Counts of work items by state for the namespace. Returns `null` if the `namespace_level_work_items` feature flag is disabled. Introduced in GitLab 16.7: **Status**: Experiment."
  workItemStateCounts(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Filter work items by author username."
    authorUsername: String,
    "Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items."
    confidential: Boolean,
    "Usernames of users assigned to the work item."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with `assigneeUsernames`."
    assigneeWildcardId: AssigneeWildcardId,
    "Labels applied to the work item."
    labelName: [String!],
    "Milestone applied to the work item."
    milestoneTitle: [String!],
    "Filter by milestone ID wildcard. Incompatible with `milestoneTitle`."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported."
    myReactionEmoji: String,
    """
    List of IIDs of work items. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Current state of the work item."
    state: IssuableState,
    "Filter work items by the given work item types."
    types: [IssueType!],
    "Work items created before the timestamp."
    createdBefore: Time,
    "Work items created after the timestamp."
    createdAfter: Time,
    "Work items updated before the timestamp."
    updatedBefore: Time,
    "Work items updated after the timestamp."
    updatedAfter: Time,
    "Work items due before the timestamp."
    dueBefore: Time,
    "Work items due after the timestamp."
    dueAfter: Time,
    "Work items closed before the date."
    closedBefore: Time,
    "Work items closed after the date."
    closedAfter: Time,
    "Work items the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Negated work item arguments."
    not: NegatedWorkItemFilterInput,
    "List of arguments with inclusive `OR`."
    or: UnionedWorkItemFilterInput,
    """
    IID of the work item. For example, "1".
    """
    iid: String,
    "Sort work items by criteria."
    sort: WorkItemSort = CREATED_DESC,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Include work items from ancestor groups."
    includeAncestors: Boolean = false,
    "Include work items from descendant groups and projects."
    includeDescendants: Boolean = false
  ): WorkItemStateCountsType @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  "Work item types available to the group."
  workItemTypes(
    "Filter work item types by the given name."
    name: IssueType,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemTypeConnection
  "Work items that belong to the namespace. Introduced in GitLab 16.3: **Status**: Experiment."
  workItems(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Filter work items by author username."
    authorUsername: String,
    "Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items."
    confidential: Boolean,
    "Usernames of users assigned to the work item."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with `assigneeUsernames`."
    assigneeWildcardId: AssigneeWildcardId,
    "Labels applied to the work item."
    labelName: [String!],
    "Milestone applied to the work item."
    milestoneTitle: [String!],
    "Filter by milestone ID wildcard. Incompatible with `milestoneTitle`."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported."
    myReactionEmoji: String,
    """
    List of IIDs of work items. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Current state of the work item."
    state: IssuableState,
    "Filter work items by the given work item types."
    types: [IssueType!],
    "Work items created before the timestamp."
    createdBefore: Time,
    "Work items created after the timestamp."
    createdAfter: Time,
    "Work items updated before the timestamp."
    updatedBefore: Time,
    "Work items updated after the timestamp."
    updatedAfter: Time,
    "Work items due before the timestamp."
    dueBefore: Time,
    "Work items due after the timestamp."
    dueAfter: Time,
    "Work items closed before the date."
    closedBefore: Time,
    "Work items closed after the date."
    closedAfter: Time,
    "Work items the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Negated work item arguments."
    not: NegatedWorkItemFilterInput,
    "List of arguments with inclusive `OR`."
    or: UnionedWorkItemFilterInput,
    """
    IID of the work item. For example, "1".
    """
    iid: String,
    "Sort work items by criteria."
    sort: WorkItemSort = CREATED_DESC,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Include work items from ancestor groups."
    includeAncestors: Boolean = false,
    "Include work items from descendant groups and projects."
    includeDescendants: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
}
"The connection type for Group."
type GroupConnection {
  "A list of edges."
  edges: [GroupEdge]
  "A list of nodes."
  nodes: [Group]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
type GroupDataTransfer {
  "Data nodes."
  egressNodes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EgressNodeConnection
}
"An edge in a connection."
type GroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Group
}
"The connection type for GroupInterface."
type GroupInterfaceConnection {
  "A list of edges."
  edges: [GroupInterfaceEdge]
  "A list of nodes."
  nodes: [GroupInterface]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type GroupInterfaceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GroupInterface
}
"Represents a Group Membership"
type GroupMember implements MemberInterface {
  "GitLab::Access level."
  accessLevel: AccessLevel
  "Date and time the membership was created."
  createdAt: Time
  "User that authorized membership."
  createdBy: UserCore
  "Date and time the membership expires."
  expiresAt: Time
  "Group that a user is a member of."
  group: Group
  "ID of the member."
  id: ID!
  "Find a merge request."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Group notification email for user. Only available for admins."
  notificationEmail: String
  "Date and time the membership was last updated."
  updatedAt: Time
  "User that is associated with the member object."
  user: UserCore
  "Permissions for the current user on the resource"
  userPermissions: GroupPermissions!
}
"Autogenerated return type of GroupMemberBulkUpdate."
type GroupMemberBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Group members after mutation."
  groupMembers: [GroupMember!]
}
"The connection type for GroupMember."
type GroupMemberConnection {
  "A list of edges."
  edges: [GroupMemberEdge]
  "A list of nodes."
  nodes: [GroupMember]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type GroupMemberEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GroupMember
}
type GroupPermissions {
  "If `true`, the user can perform `create_custom_emoji` on this resource"
  createCustomEmoji: Boolean!
  "If `true`, the user can perform `create_projects` on this resource"
  createProjects: Boolean!
  "If `true`, the user can perform `read_group` on this resource"
  readGroup: Boolean!
  "If `true`, the user can perform `remove_group` on this resource"
  removeGroup: Boolean!
  "If `true`, the user can perform `view_edit_page` on this resource"
  viewEditPage: Boolean!
}
"Autogenerated return type of GroupUpdate."
type GroupUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Group after update."
  group: Group
}
type Groups {
  "Commit responsible for specified group."
  commit: Commit!
  "HTML data derived from commit needed to present blame."
  commitData: CommitData
  "Starting line number for the commit group."
  lineno: Int!
  "Array of lines added for the commit group."
  lines: [String!]!
  "Number of contiguous lines which the blame spans for the commit group."
  span: Int!
}
"Helm file metadata"
type HelmFileMetadata implements PackageFileMetadata {
  "Channel of the Helm chart."
  channel: String!
  "Date of creation."
  createdAt: Time!
  "Metadata of the Helm chart."
  metadata: PackageHelmMetadataType!
  "Date of most recent update."
  updatedAt: Time!
}
"Autogenerated return type of HttpIntegrationCreate."
type HttpIntegrationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}
"Autogenerated return type of HttpIntegrationDestroy."
type HttpIntegrationDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}
"Autogenerated return type of HttpIntegrationResetToken."
type HttpIntegrationResetTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}
"Autogenerated return type of HttpIntegrationUpdate."
type HttpIntegrationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}
"IDE settings and feature flags."
type Ide {
  "Indicates whether AI assisted code suggestions are enabled."
  codeSuggestionsEnabled: Boolean!
}
type ImportSourceUser {
  "Timestamp of when the source user was created."
  createdAt: Time!
  "Global ID of the mapping of a user on source instance to a user on destination instance."
  id: ImportSourceUserID!
  "Name of the importer."
  importType: ImportSource!
  "Placeholder user associated with the import source user."
  placeholderUser: UserCore
  "User that contributions are reassigned to."
  reassignToUser: UserCore
  "User that did the reassignment."
  reassignedByUser: UserCore
  "Error message if reassignment failed."
  reassignmentError: String
  "Source instance hostname."
  sourceHostname: String!
  "Name of user in the source instance."
  sourceName: String
  "ID of the user in the source instance."
  sourceUserIdentifier: String!
  "Username of user in the source instance."
  sourceUsername: String
  "Status of the mapping."
  status: ImportSourceUserStatus!
}
"Autogenerated return type of ImportSourceUserCancelReassignment."
type ImportSourceUserCancelReassignmentPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mapping of a user on source instance to a user on destination instance after mutation."
  importSourceUser: ImportSourceUser
}
"The connection type for ImportSourceUser."
type ImportSourceUserConnection {
  "A list of edges."
  edges: [ImportSourceUserEdge]
  "A list of nodes."
  nodes: [ImportSourceUser]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ImportSourceUserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ImportSourceUser
}
"Autogenerated return type of ImportSourceUserKeepAllAsPlaceholder."
type ImportSourceUserKeepAllAsPlaceholderPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Number of successfully updated mappings of users on source instance to their destination users."
  updatedImportSourceUserCount: Int
}
"Autogenerated return type of ImportSourceUserKeepAsPlaceholder."
type ImportSourceUserKeepAsPlaceholderPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mapping of a user on source instance to a user on destination instance after mutation."
  importSourceUser: ImportSourceUser
}
"Autogenerated return type of ImportSourceUserReassign."
type ImportSourceUserReassignPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mapping of a user on source instance to a user on destination instance after mutation."
  importSourceUser: ImportSourceUser
}
"Autogenerated return type of ImportSourceUserResendNotification."
type ImportSourceUserResendNotificationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mapping of a user on source instance to a user on destination instance after mutation."
  importSourceUser: ImportSourceUser
}
"CI/CD variables a project inherites from its parent group and ancestors."
type InheritedCiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable."
  environmentScope: String
  "Indicates the path to the CI/CD settings of the group the variable belongs to."
  groupCiCdSettingsPath: String
  "Indicates group the variable belongs to."
  groupName: String
  "Indicates whether the variable is hidden."
  hidden: Boolean
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Type of the variable."
  variableType: CiVariableType
}
"The connection type for InheritedCiVariable."
type InheritedCiVariableConnection {
  "A list of edges."
  edges: [InheritedCiVariableEdge]
  "A list of nodes."
  nodes: [InheritedCiVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type InheritedCiVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: InheritedCiVariable
}
"An integration to override the level settings of instance specific integrations."
type IntegrationExclusion {
  "Group that has been excluded from the instance specific integration."
  group: Group
  "Project that has been excluded from the instance specific integration."
  project: Project
}
"The connection type for IntegrationExclusion."
type IntegrationExclusionConnection {
  "A list of edges."
  edges: [IntegrationExclusionEdge]
  "A list of nodes."
  nodes: [IntegrationExclusion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of IntegrationExclusionCreate."
type IntegrationExclusionCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Integration exclusions created by the mutation."
  exclusions: [IntegrationExclusion!]
}
"Autogenerated return type of IntegrationExclusionDelete."
type IntegrationExclusionDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project no longer excluded due to the mutation."
  exclusions: [IntegrationExclusion!]
}
"An edge in a connection."
type IntegrationExclusionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: IntegrationExclusion
}
type Issue implements CurrentUserTodos & NoteableInterface & Todoable {
  "Alert associated to the issue. Deprecated in GitLab 15.6: Use `alert_management_alerts`."
  alertManagementAlert: AlertManagementAlert @deprecated(reason: "Use `alert_management_alerts`. Deprecated in GitLab 15.6.")
  "Alert Management alerts associated to this issue."
  alertManagementAlerts(
    """
    IID of the alert. For example, "1".
    """
    iid: String,
    "Alerts with the specified statues. For example, `[TRIGGERED]`."
    statuses: [AlertManagementStatus!],
    "Sort alerts by the criteria."
    sort: AlertManagementAlertSort,
    "Filter query for given domain."
    domain: AlertManagementDomainFilter! = operations,
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Username of a user assigned to the issue."
    assigneeUsername: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AlertManagementAlertConnection
  "Assignees of the issue."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "User that created the issue."
  author: UserCore!
  "Issue the issue was closed as a duplicate of."
  closedAsDuplicateOf: Issue
  "Timestamp of when the issue was closed."
  closedAt: Time
  "All commenters on the noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Indicates the issue is confidential."
  confidential: Boolean!
  "User specific email address for the issue."
  createNoteEmail: String
  "Timestamp of when the issue was created."
  createdAt: Time!
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Customer relations contacts of the issue."
  customerRelationsContacts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomerRelationsContactConnection
  "Description of the issue."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Collection of design images associated with the issue."
  designCollection: DesignCollection
  "Indicates discussion is locked on the issue."
  discussionLocked: Boolean!
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Number of downvotes the issue has received."
  downvotes: Int!
  "Due date of the issue."
  dueDate: Time
  "Indicates if the parent project or group has email notifications disabled: `true` if email notifications are disabled. Deprecated in GitLab 16.3: Use `emails_enabled`."
  emailsDisabled: Boolean! @deprecated(reason: "Use `emails_enabled`. Deprecated in GitLab 16.3.")
  "Indicates if the parent project or group has email notifications disabled: `false` if email notifications are disabled."
  emailsEnabled: Boolean!
  "Escalation status of the issue."
  escalationStatus: IssueEscalationStatus
  "Email address of non-GitLab user reporting the issue. For guests, the email address is obfuscated."
  externalAuthor: String
  "Indicates the issue is hidden because the author has been banned."
  hidden: Boolean
  "Human-readable time estimate of the issue."
  humanTimeEstimate: String
  "Human-readable total time reported as spent on the issue."
  humanTotalTimeSpent: String
  "ID of the issue."
  id: ID!
  "Internal ID of the issue."
  iid: String!
  "Labels of the issue."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Work items linked to the issue. Introduced in GitLab 17.8: **Status**: Experiment."
  linkedWorkItems(
    "Filter by link type. Supported values: RELATED. Returns all types if omitted."
    filter: WorkItemRelatedLinkType,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LinkedWorkItemTypeConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Number of merge requests that close the issue on merge."
  mergeRequestsCount: Int!
  "Milestone of the issue."
  milestone: Milestone
  "Indicates if issue got moved from other project."
  moved: Boolean
  "Updated Issue after it got moved to another project."
  movedTo: Issue
  "Name or title of the object."
  name: String
  "All notes on this noteable."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "List of participants in the issue."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "ID of the issue project."
  projectId: Int
  "Internal reference of the issue. Returned in shortened format by default."
  reference(
    "Boolean option specifying whether the reference should be returned in full."
    full: Boolean = false
  ): String!
  "Merge requests related to the issue. This field can only be resolved for one issue in any single request."
  relatedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Relative position of the issue (used for positioning in epic tree and issue boards)."
  relativePosition: Int
  "Severity level of the incident."
  severity: IssuableSeverity
  "State of the issue."
  state: IssueState!
  "Indicates the currently logged in user is subscribed to the issue."
  subscribed: Boolean!
  "Task completion status of the issue."
  taskCompletionStatus: TaskCompletionStatus!
  "Time estimate of the issue."
  timeEstimate: Int!
  "Timelogs on the issue."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection!
  "Title of the issue."
  title: String!
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Total time (in seconds) reported as spent on the issue."
  totalTimeSpent: Int!
  "Type of the issue."
  type: IssueType
  "Timestamp of when the issue was last updated."
  updatedAt: Time!
  "User that last updated the issue."
  updatedBy: UserCore
  "Number of upvotes the issue has received."
  upvotes: Int!
  "Number of user discussions in the issue."
  userDiscussionsCount: Int!
  "Number of user notes of the issue."
  userNotesCount: Int!
  "Permissions for the current user on the resource"
  userPermissions: IssuePermissions!
  "Web path of the issue."
  webPath: String!
  "Web URL of the issue."
  webUrl: String!
}
"The connection type for Issue."
type IssueConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [IssueEdge]
  "A list of nodes."
  nodes: [Issue]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type IssueEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Issue
}
"Autogenerated return type of IssueLinkAlerts."
type IssueLinkAlertsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueMoveList."
type IssueMoveListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueMove."
type IssueMovePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Check permissions for the current user on a issue"
type IssuePermissions {
  "If `true`, the user can perform `admin_issue` on this resource"
  adminIssue: Boolean!
  "If `true`, the user can perform `admin_issue_relation` on this resource"
  adminIssueRelation: Boolean!
  "If `true`, the user can perform `clone_issue` on this resource"
  cloneIssue: Boolean!
  "If `true`, the user can perform `create_design` on this resource"
  createDesign: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `destroy_design` on this resource"
  destroyDesign: Boolean!
  "If `true`, the user can perform `move_design` on this resource"
  moveDesign: Boolean!
  "If `true`, the user can perform `move_issue` on this resource"
  moveIssue: Boolean!
  "If `true`, the user can perform `read_design` on this resource"
  readDesign: Boolean!
  "If `true`, the user can perform `read_issue` on this resource"
  readIssue: Boolean!
  "If `true`, the user can perform `reopen_issue` on this resource"
  reopenIssue: Boolean!
  "If `true`, the user can perform `update_design` on this resource"
  updateDesign: Boolean!
  "If `true`, the user can perform `update_issue` on this resource"
  updateIssue: Boolean!
}
"Autogenerated return type of IssueSetAssignees."
type IssueSetAssigneesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueSetConfidential."
type IssueSetConfidentialPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueSetCrmContacts."
type IssueSetCrmContactsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueSetDueDate."
type IssueSetDueDatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueSetEscalationStatus."
type IssueSetEscalationStatusPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueSetLocked."
type IssueSetLockedPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueSetSeverity."
type IssueSetSeverityPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssueSetSubscription."
type IssueSetSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Represents total number of issues for the represented statuses"
type IssueStatusCountsType {
  "Number of issues with status ALL for the project"
  all: Int
  "Number of issues with status CLOSED for the project"
  closed: Int
  "Number of issues with status OPENED for the project"
  opened: Int
}
"Autogenerated return type of IssueUnlinkAlert."
type IssueUnlinkAlertPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of IssuesBulkUpdate."
type IssuesBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Number of issues that were successfully updated."
  updatedIssueCount: Int
}
type JiraImport {
  "Timestamp of when the Jira import was created."
  createdAt: Time
  "Count of issues that failed to import."
  failedToImportCount: Int!
  "Count of issues that were successfully imported."
  importedIssuesCount: Int!
  "Project key for the imported Jira project."
  jiraProjectKey: String!
  "Timestamp of when the Jira import was scheduled."
  scheduledAt: Time
  "User that started the Jira import."
  scheduledBy: UserCore
  "Total count of issues that were attempted to import."
  totalIssueCount: Int!
}
"The connection type for JiraImport."
type JiraImportConnection {
  "A list of edges."
  edges: [JiraImportEdge]
  "A list of nodes."
  nodes: [JiraImport]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type JiraImportEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: JiraImport
}
"Autogenerated return type of JiraImportStart."
type JiraImportStartPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Jira import data after mutation."
  jiraImport: JiraImport
}
"Autogenerated return type of JiraImportUsers."
type JiraImportUsersPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Users returned from Jira, matched by email and name if possible."
  jiraUsers: [JiraUser!]
}
type JiraProject {
  "Key of the Jira project."
  key: String!
  "Name of the Jira project."
  name: String
  "ID of the Jira project."
  projectId: Int!
}
"The connection type for JiraProject."
type JiraProjectConnection {
  "A list of edges."
  edges: [JiraProjectEdge]
  "A list of nodes."
  nodes: [JiraProject]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type JiraProjectEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: JiraProject
}
type JiraService implements Service {
  "Indicates if the service is active."
  active: Boolean
  "List of all Jira projects fetched through Jira REST API."
  projects(
    "Project name or key."
    name: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): JiraProjectConnection
  "Type of the service."
  serviceType: ServiceType
  "Class name of the service."
  type: String
}
type JiraUser {
  "ID of the matched GitLab user."
  gitlabId: Int
  "Name of the matched GitLab user."
  gitlabName: String
  "Username of the matched GitLab user."
  gitlabUsername: String
  "Account ID of the Jira user."
  jiraAccountId: String!
  "Display name of the Jira user."
  jiraDisplayName: String!
  "Email of the Jira user, returned only for users with public emails."
  jiraEmail: String
}
"Autogenerated return type of JobArtifactsDestroy."
type JobArtifactsDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of artifacts deleted."
  destroyedArtifactsCount: Int!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job with artifacts to be deleted."
  job: CiJob
}
"Autogenerated return type of JobCancel."
type JobCancelPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}
"The connection type for JobNeedUnion."
type JobNeedUnionConnection {
  "A list of edges."
  edges: [JobNeedUnionEdge]
  "A list of nodes."
  nodes: [JobNeedUnion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type JobNeedUnionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: JobNeedUnion
}
type JobPermissions {
  "If `true`, the user can perform `cancel_build` on this resource"
  cancelBuild: Boolean!
  "If `true`, the user can perform `read_build` on this resource"
  readBuild: Boolean!
  "If `true`, the user can perform `read_job_artifacts` on this resource"
  readJobArtifacts: Boolean!
  "If `true`, the user can perform `update_build` on this resource"
  updateBuild: Boolean!
}
"Autogenerated return type of JobPlay."
type JobPlayPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}
"Autogenerated return type of JobRetry."
type JobRetryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}
"Autogenerated return type of JobUnschedule."
type JobUnschedulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}
type Kas {
  "Indicates whether the Kubernetes agent server is enabled."
  enabled: Boolean!
  "URL used by the Kubernetes tooling to communicate with the KAS Kubernetes API proxy."
  externalK8sProxyUrl: String
  "URL used by the agents to communicate with the server."
  externalUrl: String
  "KAS version."
  version: String
}
"Represents an SSH key."
type Key implements Todoable {
  "Timestamp of when the key was created."
  createdAt: Time!
  "Timestamp of when the key expires. It's null if it never expires."
  expiresAt: Time!
  "ID of the key."
  id: ID!
  "Public key of the key pair."
  key: String!
  "Name or title of the object."
  name: String
  "Title of the key."
  title: String!
  "URL of the object."
  webUrl: String
}
type Label implements LabelInterface {
  "Background color of the label."
  color: String!
  "When the label was created."
  createdAt: Time!
  "Description of the label (Markdown rendered as HTML for caching)."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Global ID of the label."
  id: LabelID!
  "Indicates this label is locked for merge requests that have been merged."
  lockOnMerge: Boolean!
  "Text color of the label."
  textColor: String!
  "Content of the label."
  title: String!
  "When the label was last updated."
  updatedAt: Time!
}
"The connection type for Label."
type LabelConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [LabelEdge]
  "A list of nodes."
  nodes: [Label]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of LabelCreate."
type LabelCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Label after mutation."
  label: Label
}
"An edge in a connection."
type LabelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Label
}
type LinkedWorkItemType {
  "Timestamp the link was created."
  linkCreatedAt: Time!
  "Global ID of the link."
  linkId: WorkItemsRelatedWorkItemLinkID!
  "Type of link."
  linkType: String!
  "Timestamp the link was updated."
  linkUpdatedAt: Time!
  "Linked work item."
  workItem: WorkItem
  "State of the linked work item."
  workItemState: WorkItemState!
}
"The connection type for LinkedWorkItemType."
type LinkedWorkItemTypeConnection {
  "A list of edges."
  edges: [LinkedWorkItemTypeEdge]
  "A list of nodes."
  nodes: [LinkedWorkItemType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type LinkedWorkItemTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: LinkedWorkItemType
}
"Represents links to perform actions on the candidate"
type MLCandidateLinks {
  "Path to the artifact."
  artifactPath: String
  "Path to the details page of the candidate."
  showPath: String
}
"Represents links to perform actions on the model"
type MLModelLinks {
  "Path to the details page of the model."
  showPath: String
}
"Represents links to perform actions on the model version"
type MLModelVersionLinks {
  "File upload path for the machine learning model."
  importPath: String
  "Path to the package of the model version."
  packagePath: String
  "Path to the details page of the model version."
  showPath: String
}
"Autogenerated return type of MarkAsSpamSnippet."
type MarkAsSpamSnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}
"Maven metadata"
type MavenMetadata {
  "App group of the Maven package."
  appGroup: String!
  "App name of the Maven package."
  appName: String!
  "App version of the Maven package."
  appVersion: String
  "Date of creation."
  createdAt: Time!
  "ID of the metadatum."
  id: PackagesMavenMetadatumID!
  "Path of the Maven package."
  path: String!
  "Date of most recent update."
  updatedAt: Time!
}
"The connection type for MemberInterface."
type MemberInterfaceConnection {
  "A list of edges."
  edges: [MemberInterfaceEdge]
  "A list of nodes."
  nodes: [MemberInterface]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MemberInterfaceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MemberInterface
}
"Defines which user roles, users, or groups can merge into a protected branch."
type MergeAccessLevel {
  "GitLab::Access level."
  accessLevel: Int!
  "Human readable representation for the access level."
  accessLevelDescription: String!
}
"The connection type for MergeAccessLevel."
type MergeAccessLevelConnection {
  "A list of edges."
  edges: [MergeAccessLevelEdge]
  "A list of nodes."
  nodes: [MergeAccessLevel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MergeAccessLevelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeAccessLevel
}
type MergeRequest implements CurrentUserTodos & NoteableInterface & Todoable {
  "Indicates if members of the target project can push to the fork."
  allowCollaboration: Boolean
  "Allows assigning multiple users to a merge request."
  allowsMultipleAssignees: Boolean!
  "Allows assigning multiple reviewers to a merge request."
  allowsMultipleReviewers: Boolean!
  "Indicates if the merge request has all the required approvals."
  approved: Boolean!
  "Users who approved the merge request."
  approvedBy(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Assignees of the merge request."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestAssigneeConnection
  "User who created the merge request."
  author: MergeRequestAuthor
  "Indicates if auto merge is enabled for the merge request."
  autoMergeEnabled: Boolean!
  "Selected auto merge strategy."
  autoMergeStrategy: String
  "Array of available auto merge strategies."
  availableAutoMergeStrategies: [String!]
  "List of emoji reactions associated with the merge request."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Timestamp of when the merge request was closed, null if not closed."
  closedAt: Time
  "Code quality reports comparison reported on the merge request."
  codequalityReportsComparer: CodequalityReportsComparer
  "All commenters on the noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Number of commits in the merge request."
  commitCount: Int
  "Merge request commits."
  commits(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CommitConnection
  "Merge request commits excluding merge commits."
  commitsWithoutMergeCommits(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CommitConnection
  "Users who have added commits to the merge request."
  committers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Indicates if the merge request has conflicts."
  conflicts: Boolean!
  "Timestamp of when the merge request was created."
  createdAt: Time!
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Default merge commit message of the merge request."
  defaultMergeCommitMessage: String
  "Default squash commit message of the merge request."
  defaultSquashCommitMessage: String
  "Description of the merge request (Markdown rendered as HTML for caching)."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Detailed merge status of the merge request."
  detailedMergeStatus: DetailedMergeStatus
  "Diff head SHA of the merge request."
  diffHeadSha: String
  "References of the base SHA, the head SHA, and the start SHA for the merge request."
  diffRefs: DiffRefs
  "Details about which files were changed in the merge request."
  diffStats(
    "Specific file path."
    path: String
  ): [DiffStats!]
  "Summary of which files were changed in the merge request."
  diffStatsSummary: DiffStatsSummary
  "Indicates if comments on the merge request are locked to members only."
  discussionLocked: Boolean!
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Indicates if the source branch is behind the target branch."
  divergedFromTargetBranch: Boolean!
  "Number of downvotes for the merge request."
  downvotes: Int!
  "Indicates if the merge request is a draft."
  draft: Boolean!
  "Indicates if the project settings will lead to source branch deletion after merge."
  forceRemoveSourceBranch: Boolean
  "Indicates if the merge request has CI."
  hasCi: Boolean!
  "Pipeline running on the branch HEAD of the merge request."
  headPipeline: Pipeline
  "Indicates the merge request is hidden because the author has been banned."
  hidden: Boolean
  "Human-readable time estimate of the merge request."
  humanTimeEstimate: String
  "Human-readable total time reported as spent on the merge request."
  humanTotalTimeSpent: String
  "ID of the merge request."
  id: ID!
  "Internal ID of the merge request."
  iid: String!
  "Commit SHA of the merge request if merge is in progress."
  inProgressMergeCommitSha: String
  "Labels of the merge request."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Date after which the merge request can be merged."
  mergeAfter: Time
  "SHA of the merge request commit (set once merged)."
  mergeCommitSha: String
  "Error message due to a merge error."
  mergeError: String
  "Indicates if a merge is currently occurring."
  mergeOngoing: Boolean!
  "Status of the merge request. Deprecated in GitLab 14.0: This was renamed."
  mergeStatus: String @deprecated(reason: "This was renamed. Please use `MergeRequest.mergeStatusEnum`. Deprecated in GitLab 14.0.")
  "Merge status of the merge request."
  mergeStatusEnum: MergeStatus
  "User who merged the merge request or set it to auto-merge."
  mergeUser: UserCore
  "Indicates if the merge has been set to auto-merge. Deprecated in GitLab 17.11: This was renamed."
  mergeWhenPipelineSucceeds: Boolean @deprecated(reason: "This was renamed. Please use `MergeRequest.autoMergeEnabled`. Deprecated in GitLab 17.11.")
  "Status of all mergeability checks of the merge request. Introduced in GitLab 16.5: **Status**: Experiment."
  mergeabilityChecks: [MergeRequestMergeabilityCheck!]! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.5.")
  "Indicates if the merge request is mergeable."
  mergeable: Boolean!
  "Indicates if all discussions in the merge request have been resolved, allowing the merge request to be merged."
  mergeableDiscussionsState: Boolean
  "Timestamp of when the merge request was merged, null if not merged."
  mergedAt: Time
  "Milestone of the merge request."
  milestone: Milestone
  "Name or title of the object."
  name: String
  "All notes on this noteable."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Participants in the merge request. This includes the author, assignees, reviewers, and users mentioned in notes."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestParticipantConnection
  "Pipelines for the merge request. Note: for performance reasons, no more than the most recent 500 pipelines will be returned."
  pipelines(
    "Filter pipelines by their status."
    status: PipelineStatusEnum,
    "Filter pipelines by scope."
    scope: PipelineScopeEnum,
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by the sha of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String,
    "Pipelines updated after the date."
    updatedAfter: Time,
    "Pipelines updated before the date."
    updatedBefore: Time,
    "Filter pipelines by the user that triggered the pipeline."
    username: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Timestamp of when the merge request was prepared."
  preparedAt: Time
  "Alias for target_project."
  project: Project!
  "ID of the merge request project."
  projectId: Int!
  "Rebase commit SHA of the merge request."
  rebaseCommitSha: String
  "Indicates if there is a rebase currently in progress for the merge request."
  rebaseInProgress: Boolean!
  "Internal reference of the merge request. Returned in shortened format by default."
  reference(
    "Boolean option specifying whether the reference should be returned in full."
    full: Boolean = false
  ): String!
  "Number of user discussions that are resolvable in the merge request."
  resolvableDiscussionsCount: Int
  "Number of user discussions that are resolved in the merge request."
  resolvedDiscussionsCount: Int
  "Indicates if merge request was retargeted."
  retargeted: Boolean
  "Users from whom a review has been requested."
  reviewers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestReviewerConnection
  "Indicates if the merge request is created by @GitLab-Security-Bot. Deprecated in GitLab 16.11: Security Auto Fix experiment feature was removed. It was always hidden behind `security_auto_fix` feature flag."
  securityAutoFix: Boolean @deprecated(reason: "Security Auto Fix experiment feature was removed. It was always hidden behind `security_auto_fix` feature flag. Deprecated in GitLab 16.11.")
  "Indicates if the merge request will be rebased."
  shouldBeRebased: Boolean!
  "Indicates if the source branch of the merge request will be deleted after merge."
  shouldRemoveSourceBranch: Boolean
  "Source branch of the merge request."
  sourceBranch: String!
  "Indicates if the source branch of the merge request exists."
  sourceBranchExists: Boolean!
  "Indicates if the source branch is protected."
  sourceBranchProtected: Boolean!
  "Source project of the merge request."
  sourceProject: Project
  "ID of the merge request source project."
  sourceProjectId: Int
  "Indicates if the merge request is set to be squashed when merged. [Project settings](https://docs.gitlab.com/ee/user/project/merge_requests/squash_and_merge.html#configure-squash-options-for-a-project) may override this value. Use `squash_on_merge` instead to take project squash options into account."
  squash: Boolean!
  "Indicates if the merge request will be squashed when merged."
  squashOnMerge: Boolean!
  "Indicates if `squashReadOnly` is enabled."
  squashReadOnly: Boolean!
  "State of the merge request."
  state: MergeRequestState!
  "Indicates if the currently logged in user is subscribed to the merge request."
  subscribed: Boolean!
  "Indicates if the merge request supports locked labels."
  supportsLockOnMerge: Boolean!
  "Target branch of the merge request."
  targetBranch: String!
  "Indicates if the target branch of the merge request exists."
  targetBranchExists: Boolean!
  "Path to the target branch of the merge request."
  targetBranchPath: String
  "Target project of the merge request."
  targetProject: Project!
  "ID of the merge request target project."
  targetProjectId: Int!
  "Completion status of tasks"
  taskCompletionStatus: TaskCompletionStatus!
  "Time estimate of the merge request."
  timeEstimate: Int!
  "Timelogs on the merge request."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection!
  "Title of the merge request."
  title: String!
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Total time (in seconds) reported as spent on the merge request."
  totalTimeSpent: Int!
  "Timestamp of when the merge request was last updated."
  updatedAt: Time!
  "Number of upvotes for the merge request."
  upvotes: Int!
  "Number of user discussions in the merge request."
  userDiscussionsCount: Int
  "User notes count of the merge request."
  userNotesCount: Int
  "Permissions for the current user on the resource"
  userPermissions: MergeRequestPermissions!
  "Web path of the merge request."
  webPath: String!
  "Web URL of the merge request."
  webUrl: String
}
"Autogenerated return type of MergeRequestAccept."
type MergeRequestAcceptPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"A user assigned to a merge request."
type MergeRequestAssignee implements Todoable & User {
  "Indicates if the user is active."
  active: Boolean
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of the user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
"The connection type for MergeRequestAssignee."
type MergeRequestAssigneeConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestAssigneeEdge]
  "A list of nodes."
  nodes: [MergeRequestAssignee]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MergeRequestAssigneeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestAssignee
}
"The author of the merge request."
type MergeRequestAuthor implements Todoable & User {
  "Indicates if the user is active."
  active: Boolean
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of the user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
"The connection type for MergeRequest."
type MergeRequestConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestEdge]
  "A list of nodes."
  nodes: [MergeRequest]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total sum of time to merge, in seconds, for the collection of merge requests."
  totalTimeToMerge: Float
}
"Autogenerated return type of MergeRequestCreate."
type MergeRequestCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"An edge in a connection."
type MergeRequestEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequest
}
"Mergeability check of the merge request."
type MergeRequestMergeabilityCheck {
  "Identifier of the mergeability check."
  identifier: MergeabilityCheckIdentifier!
  "Status of the mergeability check."
  status: MergeabilityCheckStatus!
}
"A user participating in a merge request."
type MergeRequestParticipant implements Todoable & User {
  "Indicates if the user is active."
  active: Boolean
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of the user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
"The connection type for MergeRequestParticipant."
type MergeRequestParticipantConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestParticipantEdge]
  "A list of nodes."
  nodes: [MergeRequestParticipant]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MergeRequestParticipantEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestParticipant
}
"Check permissions for the current user on a merge request"
type MergeRequestPermissions {
  "If `true`, the user can perform `admin_merge_request` on this resource"
  adminMergeRequest: Boolean!
  "If `true`, the user can perform `can_approve` on this resource"
  canApprove: Boolean!
  "If `true`, the user can perform `can_merge` on this resource"
  canMerge: Boolean!
  "If `true`, the user can perform `cherry_pick_on_current_merge_request` on this resource"
  cherryPickOnCurrentMergeRequest: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `push_to_source_branch` on this resource"
  pushToSourceBranch: Boolean!
  "If `true`, the user can perform `read_merge_request` on this resource"
  readMergeRequest: Boolean!
  "If `true`, the user can perform `remove_source_branch` on this resource"
  removeSourceBranch: Boolean!
  "If `true`, the user can perform `revert_on_current_merge_request` on this resource"
  revertOnCurrentMergeRequest: Boolean!
  "If `true`, the user can perform `update_merge_request` on this resource"
  updateMergeRequest: Boolean!
}
"A user assigned to a merge request as a reviewer."
type MergeRequestReviewer implements Todoable & User {
  "Indicates if the user is active."
  active: Boolean
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of the user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
"The connection type for MergeRequestReviewer."
type MergeRequestReviewerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestReviewerEdge]
  "A list of nodes."
  nodes: [MergeRequestReviewer]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MergeRequestReviewerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestReviewer
}
"Autogenerated return type of MergeRequestReviewerRereview."
type MergeRequestReviewerRereviewPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestSetAssignees."
type MergeRequestSetAssigneesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestSetDraft."
type MergeRequestSetDraftPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestSetLabels."
type MergeRequestSetLabelsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestSetLocked."
type MergeRequestSetLockedPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestSetMilestone."
type MergeRequestSetMilestonePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestSetReviewers."
type MergeRequestSetReviewersPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestSetSubscription."
type MergeRequestSetSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
"Autogenerated return type of MergeRequestUpdate."
type MergeRequestUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}
type Metadata {
  "Enterprise edition."
  enterprise: Boolean!
  "Feature flags for the GitLab instance. Introduced in GitLab 17.4: **Status**: Experiment."
  featureFlags(
    "Names of the feature flags to lookup (maximum of 20)."
    names: [String!]!
  ): [GitlabInstanceFeatureFlag!]! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  "Metadata about KAS."
  kas: Kas!
  "Revision."
  revision: String!
  "Version."
  version: String!
}
type MetricsDashboardAnnotation {
  "Description of the annotation."
  description: String
  "Timestamp marking end of annotated time span."
  endingAt: Time
  "ID of the annotation."
  id: ID!
  "ID of a dashboard panel to which the annotation should be scoped."
  panelId: String
  "Timestamp marking start of annotated time span."
  startingAt: Time
}
"Represents a milestone"
type Milestone {
  "Timestamp of milestone creation."
  createdAt: Time!
  "Description of the milestone."
  description: String
  "Timestamp of the milestone due date."
  dueDate: Time
  "Expired state of the milestone (a milestone is expired when the due date is past the current date). Defaults to `false` when due date has not been set."
  expired: Boolean!
  "Group of the milestone."
  group: Group
  "Indicates if milestone is at group level."
  groupMilestone: Boolean!
  "ID of the milestone."
  id: ID!
  "Internal ID of the milestone."
  iid: ID!
  "Project of the milestone."
  project: Project
  "Indicates if milestone is at project level."
  projectMilestone: Boolean!
  "Releases associated with the milestone."
  releases(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseConnection
  "Timestamp of the milestone start date."
  startDate: Time
  "State of the milestone."
  state: MilestoneStateEnum!
  "Milestone statistics."
  stats: MilestoneStats
  "Indicates if milestone is at subgroup level."
  subgroupMilestone: Boolean!
  "Title of the milestone."
  title: String!
  "Upcoming state of the milestone (a milestone is upcoming when the start date is in the future). Defaults to `false` when start date has not been set."
  upcoming: Boolean!
  "Timestamp of last milestone update."
  updatedAt: Time!
  "Web path of the milestone."
  webPath: String!
}
"The connection type for Milestone."
type MilestoneConnection {
  "A list of edges."
  edges: [MilestoneEdge]
  "A list of nodes."
  nodes: [Milestone]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MilestoneEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Milestone
}
"Contains statistics about a milestone"
type MilestoneStats {
  "Number of closed issues associated with the milestone."
  closedIssuesCount: Int
  "Total number of issues associated with the milestone."
  totalIssuesCount: Int
}
"Candidate for a model version in the model registry"
type MlCandidate {
  "Map of links to perform actions on the candidate."
  _links: MLCandidateLinks!
  "CI information about the job that created the candidate."
  ciJob: CiJob
  "Date of creation."
  createdAt: Time!
  "User that created the candidate."
  creator: UserCore
  "MLflow uuid for the candidate."
  eid: String!
  "ID of the candidate."
  id: MlCandidateID!
  "IID of the candidate scoped to project."
  iid: Int!
  "Metadata entries for the candidate."
  metadata(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlCandidateMetadataConnection!
  "Metrics for the candidate."
  metrics(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlCandidateMetricConnection!
  "Name of the candidate."
  name: String
  "Parameters for the candidate."
  params(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlCandidateParamConnection!
  "Candidate status."
  status: String
}
"The connection type for MlCandidate."
type MlCandidateConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlCandidateEdge]
  "A list of nodes."
  nodes: [MlCandidate]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MlCandidateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlCandidate
}
"Metadata for a candidate in the model registry"
type MlCandidateMetadata {
  "ID of the metadata."
  id: MlCandidateMetadataID!
  "Name of the metadata entry."
  name: String
  "Value set for the metadata entry."
  value: String!
}
"The connection type for MlCandidateMetadata."
type MlCandidateMetadataConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlCandidateMetadataEdge]
  "A list of nodes."
  nodes: [MlCandidateMetadata]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MlCandidateMetadataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlCandidateMetadata
}
"Metric for a candidate in the model registry"
type MlCandidateMetric {
  "ID of the metric."
  id: MlCandidateMetricID!
  "Name of the metric."
  name: String
  "Step at which the metric was measured."
  step: Int!
  "Value set for the metric."
  value: Float!
}
"The connection type for MlCandidateMetric."
type MlCandidateMetricConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlCandidateMetricEdge]
  "A list of nodes."
  nodes: [MlCandidateMetric]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MlCandidateMetricEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlCandidateMetric
}
"Parameter for a candidate in the model registry"
type MlCandidateParam {
  "ID of the parameter."
  id: MlCandidateParamID!
  "Name of the parameter."
  name: String
  "Value set for the parameter."
  value: String!
}
"The connection type for MlCandidateParam."
type MlCandidateParamConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlCandidateParamEdge]
  "A list of nodes."
  nodes: [MlCandidateParam]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MlCandidateParamEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlCandidateParam
}
"Machine learning experiment in model experiments"
type MlExperiment {
  "Number of candidates in the experiment."
  candidateCount: Int!
  "Candidates of the experiment."
  candidates(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlCandidateConnection
  "Timestamp of when the experiment was created."
  createdAt: Time!
  "User who created the experiment."
  creator: UserCore
  "ID of the experiment."
  id: MlExperimentID!
  "ID of the model."
  modelId: MlModelID
  "Name of the experiment."
  name: String!
  "Web URL of the experiment."
  path: String!
  "Timestamp of when the experiment was updated."
  updatedAt: Time!
}
"The connection type for MlExperiment."
type MlExperimentConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlExperimentEdge]
  "A list of nodes."
  nodes: [MlExperiment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type MlExperimentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlExperiment
}
"Machine learning model in the model registry"
type MlModel {
  "Map of links to perform actions on the model."
  _links: MLModelLinks!
  "User that created the model."
  author: UserCore
  "Count of candidates in the model."
  candidateCount: Int
  "Version candidates of the model."
  candidates(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlCandidateConnection
  "Date of creation."
  createdAt: Time!
  "Path to default experiment page for the model."
  defaultExperimentPath: String
  "Description of the model."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "ID of the model."
  id: MlModelID!
  "Latest version of the model."
  latestVersion: MlModelVersion
  "Name of the model."
  name: String!
  "Version of the model."
  version(
    "Id of the version to be fetched."
    modelVersionId: MlModelVersionID
  ): MlModelVersion
  "Count of versions in the model."
  versionCount: Int
  "Versions of the model."
  versions(
    "Search for versions where the name includes the string."
    version: String,
    "Ordering column. Default is created_at."
    orderBy: MlModelVersionsOrderBy,
    "Ordering column. Default is desc."
    sort: SortDirectionEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlModelVersionConnection
}
"The connection type for MlModel."
type MlModelConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlModelEdge]
  "A list of nodes."
  nodes: [MlModel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of MlModelCreate."
type MlModelCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Model after mutation."
  model: MlModel
}
"Autogenerated return type of MlModelDelete."
type MlModelDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Model after mutation."
  model: MlModel
}
"Autogenerated return type of MlModelDestroy."
type MlModelDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Model deletion result message."
  message: String
  "Model after mutation."
  model: MlModel
}
"An edge in a connection."
type MlModelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlModel
}
"Autogenerated return type of MlModelEdit."
type MlModelEditPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Model after mutation."
  model: MlModel
}
"Version of a machine learning model"
type MlModelVersion {
  "Map of links to perform actions on the model version."
  _links: MLModelVersionLinks!
  "Number of files in the package."
  artifactsCount: Int
  "User that created the model version."
  author: UserCore
  "Metrics, params and metadata for the model version."
  candidate: MlCandidate!
  "Date of creation."
  createdAt: Time!
  "Description of the version."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "ID of the model version."
  id: MlModelVersionID!
  "Package for model version artifacts."
  packageId: PackagesPackageID!
  "Name of the version."
  version: String!
}
"The connection type for MlModelVersion."
type MlModelVersionConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlModelVersionEdge]
  "A list of nodes."
  nodes: [MlModelVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of MlModelVersionCreate."
type MlModelVersionCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Model after mutation."
  modelVersion: MlModelVersion
}
"Autogenerated return type of MlModelVersionDelete."
type MlModelVersionDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted model version."
  modelVersion: MlModelVersion
}
"An edge in a connection."
type MlModelVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlModelVersion
}
"Autogenerated return type of MlModelVersionEdit."
type MlModelVersionEditPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Model after mutation."
  modelVersion: MlModelVersion
}
type Mutation {
  abuseReportLabelCreate(
    "Parameters for AbuseReportLabelCreate"
    input: AbuseReportLabelCreateInput!
  ): AbuseReportLabelCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  achievementsAward(
    "Parameters for AchievementsAward"
    input: AchievementsAwardInput!
  ): AchievementsAwardPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  achievementsCreate(
    "Parameters for AchievementsCreate"
    input: AchievementsCreateInput!
  ): AchievementsCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
  achievementsDelete(
    "Parameters for AchievementsDelete"
    input: AchievementsDeleteInput!
  ): AchievementsDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
  achievementsRevoke(
    "Parameters for AchievementsRevoke"
    input: AchievementsRevokeInput!
  ): AchievementsRevokePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  achievementsUpdate(
    "Parameters for AchievementsUpdate"
    input: AchievementsUpdateInput!
  ): AchievementsUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
  adminSidekiqQueuesDeleteJobs(
    "Parameters for AdminSidekiqQueuesDeleteJobs"
    input: AdminSidekiqQueuesDeleteJobsInput!
  ): AdminSidekiqQueuesDeleteJobsPayload
  alertSetAssignees(
    "Parameters for AlertSetAssignees"
    input: AlertSetAssigneesInput!
  ): AlertSetAssigneesPayload
  alertTodoCreate(
    "Parameters for AlertTodoCreate"
    input: AlertTodoCreateInput!
  ): AlertTodoCreatePayload
  artifactDestroy(
    "Parameters for ArtifactDestroy"
    input: ArtifactDestroyInput!
  ): ArtifactDestroyPayload
  awardEmojiAdd(
    "Parameters for AwardEmojiAdd"
    input: AwardEmojiAddInput!
  ): AwardEmojiAddPayload
  awardEmojiRemove(
    "Parameters for AwardEmojiRemove"
    input: AwardEmojiRemoveInput!
  ): AwardEmojiRemovePayload
  awardEmojiToggle(
    "Parameters for AwardEmojiToggle"
    input: AwardEmojiToggleInput!
  ): AwardEmojiTogglePayload
  boardListCreate(
    "Parameters for BoardListCreate"
    input: BoardListCreateInput!
  ): BoardListCreatePayload
  branchDelete(
    "Parameters for BranchDelete"
    input: BranchDeleteInput!
  ): BranchDeletePayload
  branchRuleCreate(
    "Parameters for BranchRuleCreate"
    input: BranchRuleCreateInput!
  ): BranchRuleCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  branchRuleDelete(
    "Parameters for BranchRuleDelete"
    input: BranchRuleDeleteInput!
  ): BranchRuleDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.9.")
  "Update a squash option for a branch rule Introduced in GitLab 17.9: **Status**: Experiment."
  branchRuleSquashOptionUpdate(
    "Parameters for BranchRuleSquashOptionUpdate"
    input: BranchRuleSquashOptionUpdateInput!
  ): BranchRuleSquashOptionUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  branchRuleUpdate(
    "Parameters for BranchRuleUpdate"
    input: BranchRuleUpdateInput!
  ): BranchRuleUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  bulkDestroyJobArtifacts(
    "Parameters for BulkDestroyJobArtifacts"
    input: BulkDestroyJobArtifactsInput!
  ): BulkDestroyJobArtifactsPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  bulkRunnerDelete(
    "Parameters for BulkRunnerDelete"
    input: BulkRunnerDeleteInput!
  ): BulkRunnerDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.3.")
  catalogResourcesCreate(
    "Parameters for CatalogResourcesCreate"
    input: CatalogResourcesCreateInput!
  ): CatalogResourcesCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
  catalogResourcesDestroy(
    "Parameters for CatalogResourcesDestroy"
    input: CatalogResourcesDestroyInput!
  ): CatalogResourcesDestroyPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  ciJobTokenScopeAddGroupOrProject(
    "Parameters for CiJobTokenScopeAddGroupOrProject"
    input: CiJobTokenScopeAddGroupOrProjectInput!
  ): CiJobTokenScopeAddGroupOrProjectPayload
  ciJobTokenScopeAddProject(
    "Parameters for CiJobTokenScopeAddProject"
    input: CiJobTokenScopeAddProjectInput!
  ): CiJobTokenScopeAddProjectPayload
  ciJobTokenScopeAutopopulateAllowlist(
    "Parameters for CiJobTokenScopeAutopopulateAllowlist"
    input: CiJobTokenScopeAutopopulateAllowlistInput!
  ): CiJobTokenScopeAutopopulateAllowlistPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  ciJobTokenScopeClearAllowlistAutopopulations(
    "Parameters for CiJobTokenScopeClearAllowlistAutopopulations"
    input: CiJobTokenScopeClearAllowlistAutopopulationsInput!
  ): CiJobTokenScopeClearAllowlistAutopopulationsPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  ciJobTokenScopeRemoveGroup(
    "Parameters for CiJobTokenScopeRemoveGroup"
    input: CiJobTokenScopeRemoveGroupInput!
  ): CiJobTokenScopeRemoveGroupPayload
  ciJobTokenScopeRemoveProject(
    "Parameters for CiJobTokenScopeRemoveProject"
    input: CiJobTokenScopeRemoveProjectInput!
  ): CiJobTokenScopeRemoveProjectPayload
  ciJobTokenScopeUpdatePolicies(
    "Parameters for CiJobTokenScopeUpdatePolicies"
    input: CiJobTokenScopeUpdatePoliciesInput!
  ): CiJobTokenScopeUpdatePoliciesPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  clusterAgentDelete(
    "Parameters for ClusterAgentDelete"
    input: ClusterAgentDeleteInput!
  ): ClusterAgentDeletePayload
  clusterAgentTokenCreate(
    "Parameters for ClusterAgentTokenCreate"
    input: ClusterAgentTokenCreateInput!
  ): ClusterAgentTokenCreatePayload
  clusterAgentTokenRevoke(
    "Parameters for ClusterAgentTokenRevoke"
    input: ClusterAgentTokenRevokeInput!
  ): ClusterAgentTokenRevokePayload
  commitCreate(
    "Parameters for CommitCreate"
    input: CommitCreateInput!
  ): CommitCreatePayload
  """
  Configure SAST for a project by enabling SAST in a new or modified
  `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
  create a Merge Request are a part of the response.
  """
  configureSast(
    "Parameters for ConfigureSast"
    input: ConfigureSastInput!
  ): ConfigureSastPayload
  """
  Enable SAST IaC for a project in a new or
  modified `.gitlab-ci.yml` file in a new branch. The new
  branch and a URL to create a merge request are a part of the
  response.
  """
  configureSastIac(
    "Parameters for ConfigureSastIac"
    input: ConfigureSastIacInput!
  ): ConfigureSastIacPayload
  """
  Configure Secret Detection for a project by enabling Secret Detection
  in a new or modified `.gitlab-ci.yml` file in a new branch. The new
  branch and a URL to create a Merge Request are a part of the
  response.
  """
  configureSecretDetection(
    "Parameters for ConfigureSecretDetection"
    input: ConfigureSecretDetectionInput!
  ): ConfigureSecretDetectionPayload
  "Creates an abuse report Note."
  createAbuseReportNote(
    "Parameters for CreateAbuseReportNote"
    input: CreateAbuseReportNoteInput!
  ): CreateAbuseReportNotePayload
  createAlertIssue(
    "Parameters for CreateAlertIssue"
    input: CreateAlertIssueInput!
  ): CreateAlertIssuePayload
  createAnnotation(
    "Parameters for CreateAnnotation"
    input: CreateAnnotationInput!
  ): CreateAnnotationPayload @deprecated(reason: "Underlying feature was removed in 16.0. Deprecated in GitLab 16.0.")
  createBoard(
    "Parameters for CreateBoard"
    input: CreateBoardInput!
  ): CreateBoardPayload
  createBranch(
    "Parameters for CreateBranch"
    input: CreateBranchInput!
  ): CreateBranchPayload
  createClusterAgent(
    "Parameters for CreateClusterAgent"
    input: CreateClusterAgentInput!
  ): CreateClusterAgentPayload
  "Creates a repository protection rule to restrict access to a project's container registry."
  createContainerProtectionRepositoryRule(
    "Parameters for CreateContainerProtectionRepositoryRule"
    input: CreateContainerProtectionRepositoryRuleInput!
  ): CreateContainerProtectionRepositoryRulePayload
  "Creates a protection rule to control which user roles can modify container image tags matching a specified pattern. Introduced in GitLab 17.8: **Status**: Experiment."
  createContainerProtectionTagRule(
    "Parameters for createContainerProtectionTagRule"
    input: createContainerProtectionTagRuleInput!
  ): createContainerProtectionTagRulePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  createCustomEmoji(
    "Parameters for CreateCustomEmoji"
    input: CreateCustomEmojiInput!
  ): CreateCustomEmojiPayload
  createDiffNote(
    "Parameters for CreateDiffNote"
    input: CreateDiffNoteInput!
  ): CreateDiffNotePayload
  createDiscussion(
    "Parameters for CreateDiscussion"
    input: CreateDiscussionInput!
  ): CreateDiscussionPayload
  createImageDiffNote(
    "Parameters for CreateImageDiffNote"
    input: CreateImageDiffNoteInput!
  ): CreateImageDiffNotePayload
  createIssue(
    "Parameters for CreateIssue"
    input: CreateIssueInput!
  ): CreateIssuePayload
  """
  Creates a Note.
  If the body of the Note contains only quick actions,
  the Note will be destroyed during an update, and no Note will be
  returned.
  """
  createNote(
    "Parameters for CreateNote"
    input: CreateNoteInput!
  ): CreateNotePayload
  "Creates a protection rule to restrict access to project packages."
  createPackagesProtectionRule(
    "Parameters for CreatePackagesProtectionRule"
    input: CreatePackagesProtectionRuleInput!
  ): CreatePackagesProtectionRulePayload
  createSnippet(
    "Parameters for CreateSnippet"
    input: CreateSnippetInput!
  ): CreateSnippetPayload
  customerRelationsContactCreate(
    "Parameters for CustomerRelationsContactCreate"
    input: CustomerRelationsContactCreateInput!
  ): CustomerRelationsContactCreatePayload
  customerRelationsContactUpdate(
    "Parameters for CustomerRelationsContactUpdate"
    input: CustomerRelationsContactUpdateInput!
  ): CustomerRelationsContactUpdatePayload
  customerRelationsOrganizationCreate(
    "Parameters for CustomerRelationsOrganizationCreate"
    input: CustomerRelationsOrganizationCreateInput!
  ): CustomerRelationsOrganizationCreatePayload
  customerRelationsOrganizationUpdate(
    "Parameters for CustomerRelationsOrganizationUpdate"
    input: CustomerRelationsOrganizationUpdateInput!
  ): CustomerRelationsOrganizationUpdatePayload
  deleteAnnotation(
    "Parameters for DeleteAnnotation"
    input: DeleteAnnotationInput!
  ): DeleteAnnotationPayload @deprecated(reason: "Underlying feature was removed in 16.0. Deprecated in GitLab 16.0.")
  "Deletes a container repository protection rule."
  deleteContainerProtectionRepositoryRule(
    "Parameters for DeleteContainerProtectionRepositoryRule"
    input: DeleteContainerProtectionRepositoryRuleInput!
  ): DeleteContainerProtectionRepositoryRulePayload
  "Deletes a protection rule that controls which user roles can modify container image tags matching a specified pattern. Introduced in GitLab 17.8: **Status**: Experiment."
  deleteContainerProtectionTagRule(
    "Parameters for DeleteContainerProtectionTagRule"
    input: DeleteContainerProtectionTagRuleInput!
  ): DeleteContainerProtectionTagRulePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Deletes a protection rule for packages."
  deletePackagesProtectionRule(
    "Parameters for DeletePackagesProtectionRule"
    input: DeletePackagesProtectionRuleInput!
  ): DeletePackagesProtectionRulePayload
  "Deletes a Pages deployment. Introduced in GitLab 17.1: **Status**: Experiment."
  deletePagesDeployment(
    "Parameters for DeletePagesDeployment"
    input: DeletePagesDeploymentInput!
  ): DeletePagesDeploymentPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  designManagementDelete(
    "Parameters for DesignManagementDelete"
    input: DesignManagementDeleteInput!
  ): DesignManagementDeletePayload
  designManagementMove(
    "Parameters for DesignManagementMove"
    input: DesignManagementMoveInput!
  ): DesignManagementMovePayload
  designManagementUpdate(
    "Parameters for DesignManagementUpdate"
    input: DesignManagementUpdateInput!
  ): DesignManagementUpdatePayload
  designManagementUpload(
    "Parameters for DesignManagementUpload"
    input: DesignManagementUploadInput!
  ): DesignManagementUploadPayload
  destroyBoard(
    "Parameters for DestroyBoard"
    input: DestroyBoardInput!
  ): DestroyBoardPayload
  destroyBoardList(
    "Parameters for DestroyBoardList"
    input: DestroyBoardListInput!
  ): DestroyBoardListPayload
  destroyContainerRepository(
    "Parameters for DestroyContainerRepository"
    input: DestroyContainerRepositoryInput!
  ): DestroyContainerRepositoryPayload
  destroyContainerRepositoryTags(
    "Parameters for DestroyContainerRepositoryTags"
    input: DestroyContainerRepositoryTagsInput!
  ): DestroyContainerRepositoryTagsPayload
  destroyCustomEmoji(
    "Parameters for DestroyCustomEmoji"
    input: DestroyCustomEmojiInput!
  ): DestroyCustomEmojiPayload
  destroyNote(
    "Parameters for DestroyNote"
    input: DestroyNoteInput!
  ): DestroyNotePayload
  destroyPackage(
    "Parameters for DestroyPackage"
    input: DestroyPackageInput!
  ): DestroyPackagePayload
  destroyPackageFile(
    "Parameters for DestroyPackageFile"
    input: DestroyPackageFileInput!
  ): DestroyPackageFilePayload
  destroyPackageFiles(
    "Parameters for DestroyPackageFiles"
    input: DestroyPackageFilesInput!
  ): DestroyPackageFilesPayload
  destroyPackages(
    "Parameters for DestroyPackages"
    input: DestroyPackagesInput!
  ): DestroyPackagesPayload
  destroySnippet(
    "Parameters for DestroySnippet"
    input: DestroySnippetInput!
  ): DestroySnippetPayload
  "Toggles the resolved state of a discussion"
  discussionToggleResolve(
    "Parameters for DiscussionToggleResolve"
    input: DiscussionToggleResolveInput!
  ): DiscussionToggleResolvePayload
  """
  A mutation that does not perform any changes.
  
  This is expected to be used for testing of endpoints, to verify
  that a user has mutation access.
  """
  echoCreate(
    "Parameters for EchoCreate"
    input: EchoCreateInput!
  ): EchoCreatePayload
  "Create an environment."
  environmentCreate(
    "Parameters for EnvironmentCreate"
    input: EnvironmentCreateInput!
  ): EnvironmentCreatePayload
  "Delete an environment."
  environmentDelete(
    "Parameters for EnvironmentDelete"
    input: EnvironmentDeleteInput!
  ): EnvironmentDeletePayload
  "Stop an environment."
  environmentStop(
    "Parameters for EnvironmentStop"
    input: EnvironmentStopInput!
  ): EnvironmentStopPayload
  "Update an environment."
  environmentUpdate(
    "Parameters for EnvironmentUpdate"
    input: EnvironmentUpdateInput!
  ): EnvironmentUpdatePayload
  "**Deprecated** This endpoint is planned to be removed along with certificate-based clusters. [See this epic](https://gitlab.com/groups/gitlab-org/configure/-/epics/8) for more information."
  environmentsCanaryIngressUpdate(
    "Parameters for EnvironmentsCanaryIngressUpdate"
    input: EnvironmentsCanaryIngressUpdateInput!
  ): EnvironmentsCanaryIngressUpdatePayload
  groupMemberBulkUpdate(
    "Parameters for GroupMemberBulkUpdate"
    input: GroupMemberBulkUpdateInput!
  ): GroupMemberBulkUpdatePayload
  groupUpdate(
    "Parameters for GroupUpdate"
    input: GroupUpdateInput!
  ): GroupUpdatePayload
  httpIntegrationCreate(
    "Parameters for HttpIntegrationCreate"
    input: HttpIntegrationCreateInput!
  ): HttpIntegrationCreatePayload
  httpIntegrationDestroy(
    "Parameters for HttpIntegrationDestroy"
    input: HttpIntegrationDestroyInput!
  ): HttpIntegrationDestroyPayload
  httpIntegrationResetToken(
    "Parameters for HttpIntegrationResetToken"
    input: HttpIntegrationResetTokenInput!
  ): HttpIntegrationResetTokenPayload
  httpIntegrationUpdate(
    "Parameters for HttpIntegrationUpdate"
    input: HttpIntegrationUpdateInput!
  ): HttpIntegrationUpdatePayload
  importSourceUserCancelReassignment(
    "Parameters for ImportSourceUserCancelReassignment"
    input: ImportSourceUserCancelReassignmentInput!
  ): ImportSourceUserCancelReassignmentPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  importSourceUserKeepAllAsPlaceholder(
    "Parameters for ImportSourceUserKeepAllAsPlaceholder"
    input: ImportSourceUserKeepAllAsPlaceholderInput!
  ): ImportSourceUserKeepAllAsPlaceholderPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  importSourceUserKeepAsPlaceholder(
    "Parameters for ImportSourceUserKeepAsPlaceholder"
    input: ImportSourceUserKeepAsPlaceholderInput!
  ): ImportSourceUserKeepAsPlaceholderPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  importSourceUserReassign(
    "Parameters for ImportSourceUserReassign"
    input: ImportSourceUserReassignInput!
  ): ImportSourceUserReassignPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  importSourceUserResendNotification(
    "Parameters for ImportSourceUserResendNotification"
    input: ImportSourceUserResendNotificationInput!
  ): ImportSourceUserResendNotificationPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  integrationExclusionCreate(
    "Parameters for IntegrationExclusionCreate"
    input: IntegrationExclusionCreateInput!
  ): IntegrationExclusionCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  integrationExclusionDelete(
    "Parameters for IntegrationExclusionDelete"
    input: IntegrationExclusionDeleteInput!
  ): IntegrationExclusionDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  issueLinkAlerts(
    "Parameters for IssueLinkAlerts"
    input: IssueLinkAlertsInput!
  ): IssueLinkAlertsPayload
  issueMove(
    "Parameters for IssueMove"
    input: IssueMoveInput!
  ): IssueMovePayload
  issueMoveList(
    "Parameters for IssueMoveList"
    input: IssueMoveListInput!
  ): IssueMoveListPayload
  issueSetAssignees(
    "Parameters for IssueSetAssignees"
    input: IssueSetAssigneesInput!
  ): IssueSetAssigneesPayload
  issueSetConfidential(
    "Parameters for IssueSetConfidential"
    input: IssueSetConfidentialInput!
  ): IssueSetConfidentialPayload
  issueSetCrmContacts(
    "Parameters for IssueSetCrmContacts"
    input: IssueSetCrmContactsInput!
  ): IssueSetCrmContactsPayload
  issueSetDueDate(
    "Parameters for IssueSetDueDate"
    input: IssueSetDueDateInput!
  ): IssueSetDueDatePayload
  issueSetEscalationStatus(
    "Parameters for IssueSetEscalationStatus"
    input: IssueSetEscalationStatusInput!
  ): IssueSetEscalationStatusPayload
  issueSetLocked(
    "Parameters for IssueSetLocked"
    input: IssueSetLockedInput!
  ): IssueSetLockedPayload
  issueSetSeverity(
    "Parameters for IssueSetSeverity"
    input: IssueSetSeverityInput!
  ): IssueSetSeverityPayload
  issueSetSubscription(
    "Parameters for IssueSetSubscription"
    input: IssueSetSubscriptionInput!
  ): IssueSetSubscriptionPayload
  issueUnlinkAlert(
    "Parameters for IssueUnlinkAlert"
    input: IssueUnlinkAlertInput!
  ): IssueUnlinkAlertPayload
  "Allows updating several properties for a set of issues. Does nothing if the `bulk_update_issues_mutation` feature flag is disabled. Introduced in GitLab 15.9: **Status**: Experiment."
  issuesBulkUpdate(
    "Parameters for IssuesBulkUpdate"
    input: IssuesBulkUpdateInput!
  ): IssuesBulkUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  jiraImportStart(
    "Parameters for JiraImportStart"
    input: JiraImportStartInput!
  ): JiraImportStartPayload
  jiraImportUsers(
    "Parameters for JiraImportUsers"
    input: JiraImportUsersInput!
  ): JiraImportUsersPayload
  jobArtifactsDestroy(
    "Parameters for JobArtifactsDestroy"
    input: JobArtifactsDestroyInput!
  ): JobArtifactsDestroyPayload
  jobCancel(
    "Parameters for JobCancel"
    input: JobCancelInput!
  ): JobCancelPayload
  jobPlay(
    "Parameters for JobPlay"
    input: JobPlayInput!
  ): JobPlayPayload
  jobRetry(
    "Parameters for JobRetry"
    input: JobRetryInput!
  ): JobRetryPayload
  jobUnschedule(
    "Parameters for JobUnschedule"
    input: JobUnscheduleInput!
  ): JobUnschedulePayload
  labelCreate(
    "Parameters for LabelCreate"
    input: LabelCreateInput!
  ): LabelCreatePayload
  markAsSpamSnippet(
    "Parameters for MarkAsSpamSnippet"
    input: MarkAsSpamSnippetInput!
  ): MarkAsSpamSnippetPayload
  """
  Accepts a merge request.
  When accepted, the source branch will be scheduled to merge into the target branch, either
  immediately if possible, or using one of the automatic merge strategies.
  
  [In GitLab 16.5](https://gitlab.com/gitlab-org/gitlab/-/issues/421510), the merging happens asynchronously.
  This results in `mergeRequest` and `state` not updating after a mutation request,
  because the merging may not have happened yet.
  """
  mergeRequestAccept(
    "Parameters for MergeRequestAccept"
    input: MergeRequestAcceptInput!
  ): MergeRequestAcceptPayload
  mergeRequestCreate(
    "Parameters for MergeRequestCreate"
    input: MergeRequestCreateInput!
  ): MergeRequestCreatePayload
  mergeRequestReviewerRereview(
    "Parameters for MergeRequestReviewerRereview"
    input: MergeRequestReviewerRereviewInput!
  ): MergeRequestReviewerRereviewPayload
  mergeRequestSetAssignees(
    "Parameters for MergeRequestSetAssignees"
    input: MergeRequestSetAssigneesInput!
  ): MergeRequestSetAssigneesPayload
  mergeRequestSetDraft(
    "Parameters for MergeRequestSetDraft"
    input: MergeRequestSetDraftInput!
  ): MergeRequestSetDraftPayload
  mergeRequestSetLabels(
    "Parameters for MergeRequestSetLabels"
    input: MergeRequestSetLabelsInput!
  ): MergeRequestSetLabelsPayload
  mergeRequestSetLocked(
    "Parameters for MergeRequestSetLocked"
    input: MergeRequestSetLockedInput!
  ): MergeRequestSetLockedPayload
  mergeRequestSetMilestone(
    "Parameters for MergeRequestSetMilestone"
    input: MergeRequestSetMilestoneInput!
  ): MergeRequestSetMilestonePayload
  mergeRequestSetReviewers(
    "Parameters for MergeRequestSetReviewers"
    input: MergeRequestSetReviewersInput!
  ): MergeRequestSetReviewersPayload
  mergeRequestSetSubscription(
    "Parameters for MergeRequestSetSubscription"
    input: MergeRequestSetSubscriptionInput!
  ): MergeRequestSetSubscriptionPayload
  "Update attributes of a merge request"
  mergeRequestUpdate(
    "Parameters for MergeRequestUpdate"
    input: MergeRequestUpdateInput!
  ): MergeRequestUpdatePayload
  mlModelCreate(
    "Parameters for MlModelCreate"
    input: MlModelCreateInput!
  ): MlModelCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.8.")
  mlModelDelete(
    "Parameters for MlModelDelete"
    input: MlModelDeleteInput!
  ): MlModelDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  mlModelDestroy(
    "Parameters for MlModelDestroy"
    input: MlModelDestroyInput!
  ): MlModelDestroyPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.10.")
  mlModelEdit(
    "Parameters for MlModelEdit"
    input: MlModelEditInput!
  ): MlModelEditPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.3.")
  mlModelVersionCreate(
    "Parameters for MlModelVersionCreate"
    input: MlModelVersionCreateInput!
  ): MlModelVersionCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  mlModelVersionDelete(
    "Parameters for MlModelVersionDelete"
    input: MlModelVersionDeleteInput!
  ): MlModelVersionDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  mlModelVersionEdit(
    "Parameters for MlModelVersionEdit"
    input: MlModelVersionEditInput!
  ): MlModelVersionEditPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  namespaceSettingsUpdate(
    "Parameters for NamespaceSettingsUpdate"
    input: NamespaceSettingsUpdateInput!
  ): NamespaceSettingsUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Convert a standard comment to a resolvable thread."
  noteConvertToThread(
    "Parameters for NoteConvertToThread"
    input: NoteConvertToThreadInput!
  ): NoteConvertToThreadPayload
  organizationCreate(
    "Parameters for OrganizationCreate"
    input: OrganizationCreateInput!
  ): OrganizationCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  organizationUpdate(
    "Parameters for OrganizationUpdate"
    input: OrganizationUpdateInput!
  ): OrganizationUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  organizationUserUpdate(
    "Parameters for OrganizationUserUpdate"
    input: OrganizationUserUpdateInput!
  ): OrganizationUserUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
  pagesMarkOnboardingComplete(
    "Parameters for PagesMarkOnboardingComplete"
    input: PagesMarkOnboardingCompleteInput!
  ): PagesMarkOnboardingCompletePayload
  pipelineCancel(
    "Parameters for PipelineCancel"
    input: PipelineCancelInput!
  ): PipelineCancelPayload
  pipelineCreate(
    "Parameters for PipelineCreate"
    input: PipelineCreateInput!
  ): PipelineCreatePayload
  pipelineDestroy(
    "Parameters for PipelineDestroy"
    input: PipelineDestroyInput!
  ): PipelineDestroyPayload
  pipelineRetry(
    "Parameters for PipelineRetry"
    input: PipelineRetryInput!
  ): PipelineRetryPayload
  pipelineScheduleCreate(
    "Parameters for PipelineScheduleCreate"
    input: PipelineScheduleCreateInput!
  ): PipelineScheduleCreatePayload
  pipelineScheduleDelete(
    "Parameters for PipelineScheduleDelete"
    input: PipelineScheduleDeleteInput!
  ): PipelineScheduleDeletePayload
  pipelineSchedulePlay(
    "Parameters for PipelineSchedulePlay"
    input: PipelineSchedulePlayInput!
  ): PipelineSchedulePlayPayload
  pipelineScheduleTakeOwnership(
    "Parameters for PipelineScheduleTakeOwnership"
    input: PipelineScheduleTakeOwnershipInput!
  ): PipelineScheduleTakeOwnershipPayload
  pipelineScheduleUpdate(
    "Parameters for PipelineScheduleUpdate"
    input: PipelineScheduleUpdateInput!
  ): PipelineScheduleUpdatePayload
  pipelineTriggerCreate(
    "Parameters for PipelineTriggerCreate"
    input: PipelineTriggerCreateInput!
  ): PipelineTriggerCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  pipelineTriggerDelete(
    "Parameters for PipelineTriggerDelete"
    input: PipelineTriggerDeleteInput!
  ): PipelineTriggerDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  pipelineTriggerUpdate(
    "Parameters for PipelineTriggerUpdate"
    input: PipelineTriggerUpdateInput!
  ): PipelineTriggerUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  projectBlobsRemove(
    "Parameters for projectBlobsRemove"
    input: projectBlobsRemoveInput!
  ): projectBlobsRemovePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  projectCiCdSettingsUpdate(
    "Parameters for ProjectCiCdSettingsUpdate"
    input: ProjectCiCdSettingsUpdateInput!
  ): ProjectCiCdSettingsUpdatePayload
  "Updates multiple members of a project. To use this mutation, you must have at least the Maintainer role."
  projectMemberBulkUpdate(
    "Parameters for ProjectMemberBulkUpdate"
    input: ProjectMemberBulkUpdateInput!
  ): ProjectMemberBulkUpdatePayload
  projectSyncFork(
    "Parameters for ProjectSyncFork"
    input: ProjectSyncForkInput!
  ): ProjectSyncForkPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  projectTextReplace(
    "Parameters for projectTextReplace"
    input: projectTextReplaceInput!
  ): projectTextReplacePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  prometheusIntegrationCreate(
    "Parameters for PrometheusIntegrationCreate"
    input: PrometheusIntegrationCreateInput!
  ): PrometheusIntegrationCreatePayload
  prometheusIntegrationResetToken(
    "Parameters for PrometheusIntegrationResetToken"
    input: PrometheusIntegrationResetTokenInput!
  ): PrometheusIntegrationResetTokenPayload
  prometheusIntegrationUpdate(
    "Parameters for PrometheusIntegrationUpdate"
    input: PrometheusIntegrationUpdateInput!
  ): PrometheusIntegrationUpdatePayload
  releaseAssetLinkCreate(
    "Parameters for ReleaseAssetLinkCreate"
    input: ReleaseAssetLinkCreateInput!
  ): ReleaseAssetLinkCreatePayload
  releaseAssetLinkDelete(
    "Parameters for ReleaseAssetLinkDelete"
    input: ReleaseAssetLinkDeleteInput!
  ): ReleaseAssetLinkDeletePayload
  releaseAssetLinkUpdate(
    "Parameters for ReleaseAssetLinkUpdate"
    input: ReleaseAssetLinkUpdateInput!
  ): ReleaseAssetLinkUpdatePayload
  releaseCreate(
    "Parameters for ReleaseCreate"
    input: ReleaseCreateInput!
  ): ReleaseCreatePayload
  releaseDelete(
    "Parameters for ReleaseDelete"
    input: ReleaseDeleteInput!
  ): ReleaseDeletePayload
  releaseUpdate(
    "Parameters for ReleaseUpdate"
    input: ReleaseUpdateInput!
  ): ReleaseUpdatePayload
  """
  Repositions a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`)
  """
  repositionImageDiffNote(
    "Parameters for RepositionImageDiffNote"
    input: RepositionImageDiffNoteInput!
  ): RepositionImageDiffNotePayload
  "Restores a Pages deployment that has been scheduled for deletion. Introduced in GitLab 17.1: **Status**: Experiment."
  restorePagesDeployment(
    "Parameters for RestorePagesDeployment"
    input: RestorePagesDeploymentInput!
  ): RestorePagesDeploymentPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  runnerBulkPause(
    "Parameters for RunnerBulkPause"
    input: RunnerBulkPauseInput!
  ): RunnerBulkPausePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.11.")
  runnerCacheClear(
    "Parameters for RunnerCacheClear"
    input: RunnerCacheClearInput!
  ): RunnerCacheClearPayload
  runnerCreate(
    "Parameters for RunnerCreate"
    input: RunnerCreateInput!
  ): RunnerCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  runnerDelete(
    "Parameters for RunnerDelete"
    input: RunnerDeleteInput!
  ): RunnerDeletePayload
  runnerUpdate(
    "Parameters for RunnerUpdate"
    input: RunnerUpdateInput!
  ): RunnerUpdatePayload
  runnersRegistrationTokenReset(
    "Parameters for RunnersRegistrationTokenReset"
    input: RunnersRegistrationTokenResetInput!
  ): RunnersRegistrationTokenResetPayload @deprecated(reason: "Underlying feature was deprecated in 15.6 and will be removed in 18.0. Deprecated in GitLab 17.7.")
  savedReplyCreate(
    "Parameters for SavedReplyCreate"
    input: SavedReplyCreateInput!
  ): SavedReplyCreatePayload
  savedReplyDestroy(
    "Parameters for SavedReplyDestroy"
    input: SavedReplyDestroyInput!
  ): SavedReplyDestroyPayload
  savedReplyUpdate(
    "Parameters for SavedReplyUpdate"
    input: SavedReplyUpdateInput!
  ): SavedReplyUpdatePayload
  starProject(
    "Parameters for StarProject"
    input: StarProjectInput!
  ): StarProjectPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  tagCreate(
    "Parameters for TagCreate"
    input: TagCreateInput!
  ): TagCreatePayload
  tagDelete(
    "Parameters for TagDelete"
    input: TagDeleteInput!
  ): TagDeletePayload
  terraformStateDelete(
    "Parameters for TerraformStateDelete"
    input: TerraformStateDeleteInput!
  ): TerraformStateDeletePayload
  terraformStateLock(
    "Parameters for TerraformStateLock"
    input: TerraformStateLockInput!
  ): TerraformStateLockPayload
  terraformStateUnlock(
    "Parameters for TerraformStateUnlock"
    input: TerraformStateUnlockInput!
  ): TerraformStateUnlockPayload
  timelineEventCreate(
    "Parameters for TimelineEventCreate"
    input: TimelineEventCreateInput!
  ): TimelineEventCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.6.")
  timelineEventDestroy(
    "Parameters for TimelineEventDestroy"
    input: TimelineEventDestroyInput!
  ): TimelineEventDestroyPayload
  timelineEventPromoteFromNote(
    "Parameters for TimelineEventPromoteFromNote"
    input: TimelineEventPromoteFromNoteInput!
  ): TimelineEventPromoteFromNotePayload
  timelineEventTagCreate(
    "Parameters for TimelineEventTagCreate"
    input: TimelineEventTagCreateInput!
  ): TimelineEventTagCreatePayload
  timelineEventUpdate(
    "Parameters for TimelineEventUpdate"
    input: TimelineEventUpdateInput!
  ): TimelineEventUpdatePayload
  timelogCreate(
    "Parameters for TimelogCreate"
    input: TimelogCreateInput!
  ): TimelogCreatePayload
  timelogDelete(
    "Parameters for TimelogDelete"
    input: TimelogDeleteInput!
  ): TimelogDeletePayload
  todoCreate(
    "Parameters for TodoCreate"
    input: TodoCreateInput!
  ): TodoCreatePayload
  todoDeleteMany(
    "Parameters for TodoDeleteMany"
    input: TodoDeleteManyInput!
  ): TodoDeleteManyPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.11.")
  todoMarkDone(
    "Parameters for TodoMarkDone"
    input: TodoMarkDoneInput!
  ): TodoMarkDonePayload
  todoResolveMany(
    "Parameters for TodoResolveMany"
    input: TodoResolveManyInput!
  ): TodoResolveManyPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  todoRestore(
    "Parameters for TodoRestore"
    input: TodoRestoreInput!
  ): TodoRestorePayload
  todoRestoreMany(
    "Parameters for TodoRestoreMany"
    input: TodoRestoreManyInput!
  ): TodoRestoreManyPayload
  todoSnooze(
    "Parameters for TodoSnooze"
    input: TodoSnoozeInput!
  ): TodoSnoozePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  todoSnoozeMany(
    "Parameters for TodoSnoozeMany"
    input: TodoSnoozeManyInput!
  ): TodoSnoozeManyPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  todoUnSnooze(
    "Parameters for TodoUnSnooze"
    input: TodoUnSnoozeInput!
  ): TodoUnSnoozePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  todoUnsnoozeMany(
    "Parameters for TodoUnsnoozeMany"
    input: TodoUnsnoozeManyInput!
  ): TodoUnsnoozeManyPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  todosMarkAllDone(
    "Parameters for TodosMarkAllDone"
    input: TodosMarkAllDoneInput!
  ): TodosMarkAllDonePayload
  "Updates an abuse report Note. Introduced in GitLab 17.5: **Status**: Experiment."
  updateAbuseReportNote(
    "Parameters for UpdateAbuseReportNote"
    input: UpdateAbuseReportNoteInput!
  ): UpdateAbuseReportNotePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
  updateAlertStatus(
    "Parameters for UpdateAlertStatus"
    input: UpdateAlertStatusInput!
  ): UpdateAlertStatusPayload
  updateBoard(
    "Parameters for UpdateBoard"
    input: UpdateBoardInput!
  ): UpdateBoardPayload
  updateBoardList(
    "Parameters for UpdateBoardList"
    input: UpdateBoardListInput!
  ): UpdateBoardListPayload
  updateContainerExpirationPolicy(
    "Parameters for UpdateContainerExpirationPolicy"
    input: UpdateContainerExpirationPolicyInput!
  ): UpdateContainerExpirationPolicyPayload
  "Updates a container repository protection rule that controls who can modify container images based on user roles."
  updateContainerProtectionRepositoryRule(
    "Parameters for UpdateContainerProtectionRepositoryRule"
    input: UpdateContainerProtectionRepositoryRuleInput!
  ): UpdateContainerProtectionRepositoryRulePayload
  "Updates a protection rule that controls which user roles can modify container image tags matching a specified pattern. Introduced in GitLab 17.8: **Status**: Experiment."
  updateContainerProtectionTagRule(
    "Parameters for UpdateContainerProtectionTagRule"
    input: UpdateContainerProtectionTagRuleInput!
  ): UpdateContainerProtectionTagRulePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "These settings can be adjusted only by the group Owner."
  updateDependencyProxyImageTtlGroupPolicy(
    "Parameters for UpdateDependencyProxyImageTtlGroupPolicy"
    input: UpdateDependencyProxyImageTtlGroupPolicyInput!
  ): UpdateDependencyProxyImageTtlGroupPolicyPayload
  "These settings can be adjusted only by the group Owner."
  updateDependencyProxySettings(
    "Parameters for UpdateDependencyProxySettings"
    input: UpdateDependencyProxySettingsInput!
  ): UpdateDependencyProxySettingsPayload
  """
  Updates a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`).
  If the body of the Note contains only quick actions,
  the Note will be destroyed during an update, and no Note will be
  returned.
  
  """
  updateImageDiffNote(
    "Parameters for UpdateImageDiffNote"
    input: UpdateImageDiffNoteInput!
  ): UpdateImageDiffNotePayload
  updateIssue(
    "Parameters for UpdateIssue"
    input: UpdateIssueInput!
  ): UpdateIssuePayload
  "These settings can be adjusted only by the group Owner."
  updateNamespacePackageSettings(
    "Parameters for UpdateNamespacePackageSettings"
    input: UpdateNamespacePackageSettingsInput!
  ): UpdateNamespacePackageSettingsPayload
  """
  Updates a Note.
  If the body of the Note contains only quick actions,
  the Note will be destroyed during an update, and no Note will be
  returned.
  """
  updateNote(
    "Parameters for UpdateNote"
    input: UpdateNoteInput!
  ): UpdateNotePayload
  updatePackagesCleanupPolicy(
    "Parameters for UpdatePackagesCleanupPolicy"
    input: UpdatePackagesCleanupPolicyInput!
  ): UpdatePackagesCleanupPolicyPayload
  "Updates a package protection rule to restrict access to project packages. You can prevent users without certain permissions from altering packages."
  updatePackagesProtectionRule(
    "Parameters for UpdatePackagesProtectionRule"
    input: UpdatePackagesProtectionRuleInput!
  ): UpdatePackagesProtectionRulePayload
  updateSnippet(
    "Parameters for UpdateSnippet"
    input: UpdateSnippetInput!
  ): UpdateSnippetPayload
  "Deletes an upload."
  uploadDelete(
    "Parameters for UploadDelete"
    input: UploadDeleteInput!
  ): UploadDeletePayload
  userAchievementPrioritiesUpdate(
    "Parameters for UserAchievementPrioritiesUpdate"
    input: UserAchievementPrioritiesUpdateInput!
  ): UserAchievementPrioritiesUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.5.")
  userAchievementsDelete(
    "Parameters for UserAchievementsDelete"
    input: UserAchievementsDeleteInput!
  ): UserAchievementsDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.1.")
  userAchievementsUpdate(
    "Parameters for UserAchievementsUpdate"
    input: UserAchievementsUpdateInput!
  ): UserAchievementsUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.3.")
  userCalloutCreate(
    "Parameters for UserCalloutCreate"
    input: UserCalloutCreateInput!
  ): UserCalloutCreatePayload
  userPreferencesUpdate(
    "Parameters for UserPreferencesUpdate"
    input: UserPreferencesUpdateInput!
  ): UserPreferencesUpdatePayload
  userSetNamespaceCommitEmail(
    "Parameters for UserSetNamespaceCommitEmail"
    input: UserSetNamespaceCommitEmailInput!
  ): UserSetNamespaceCommitEmailPayload
  "Adds a closing merge request to a work item Introduced in GitLab 17.1: **Status**: Experiment."
  workItemAddClosingMergeRequest(
    "Parameters for WorkItemAddClosingMergeRequest"
    input: WorkItemAddClosingMergeRequestInput!
  ): WorkItemAddClosingMergeRequestPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  "Add linked items to the work item. Introduced in GitLab 16.3: **Status**: Experiment."
  workItemAddLinkedItems(
    "Parameters for WorkItemAddLinkedItems"
    input: WorkItemAddLinkedItemsInput!
  ): WorkItemAddLinkedItemsPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Allows updating several properties for a set of issues. Does nothing if the `bulk_update_issues_mutation` feature flag is disabled. Introduced in GitLab 17.4: **Status**: Experiment."
  workItemBulkUpdate(
    "Parameters for WorkItemBulkUpdate"
    input: WorkItemBulkUpdateInput!
  ): WorkItemBulkUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  "Converts the work item to a new type Introduced in GitLab 15.11: **Status**: Experiment."
  workItemConvert(
    "Parameters for WorkItemConvert"
    input: WorkItemConvertInput!
  ): WorkItemConvertPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
  "Creates a work item. Introduced in GitLab 15.1: **Status**: Experiment."
  workItemCreate(
    "Parameters for WorkItemCreate"
    input: WorkItemCreateInput!
  ): WorkItemCreatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.1.")
  "Creates a work item from a task in another work item's description. Introduced in GitLab 15.1: **Status**: Experiment."
  workItemCreateFromTask(
    "Parameters for WorkItemCreateFromTask"
    input: WorkItemCreateFromTaskInput!
  ): WorkItemCreateFromTaskPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.1.")
  "Deletes a work item. Introduced in GitLab 15.1: **Status**: Experiment."
  workItemDelete(
    "Parameters for WorkItemDelete"
    input: WorkItemDeleteInput!
  ): WorkItemDeletePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.1.")
  workItemExport(
    "Parameters for WorkItemExport"
    input: WorkItemExportInput!
  ): WorkItemExportPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Remove items linked to the work item. Introduced in GitLab 16.3: **Status**: Experiment."
  workItemRemoveLinkedItems(
    "Parameters for WorkItemRemoveLinkedItems"
    input: WorkItemRemoveLinkedItemsInput!
  ): WorkItemRemoveLinkedItemsPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  workItemSubscribe(
    "Parameters for WorkItemSubscribe"
    input: WorkItemSubscribeInput!
  ): WorkItemSubscribePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Updates a work item by Global ID. Introduced in GitLab 15.1: **Status**: Experiment."
  workItemUpdate(
    "Parameters for WorkItemUpdate"
    input: WorkItemUpdateInput!
  ): WorkItemUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.1.")
  "Create or Update user preferences for a work item type and namespace. Introduced in GitLab 17.10: **Status**: Experiment."
  workItemUserPreferenceUpdate(
    "Parameters for WorkItemUserPreferenceUpdate"
    input: WorkItemUserPreferenceUpdateInput!
  ): WorkItemUserPreferenceUpdatePayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Reorder a work item in the hierarchy tree. Introduced in GitLab 17.3: **Status**: Experiment."
  workItemsHierarchyReorder(
    "Parameters for workItemsHierarchyReorder"
    input: workItemsHierarchyReorderInput!
  ): workItemsHierarchyReorderPayload @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.3.")
}
type Namespace implements Todoable {
  "Achievements for the namespace. Returns `null` if the `achievements` feature flag is disabled. Introduced in GitLab 15.8: **Status**: Experiment."
  achievements(
    "Filter achievements by IDs."
    ids: [AchievementsAchievementID!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.8.")
  "Path for the namespace's achievements. Returns `null` if the namespace is not a group, or the `achievements` feature flag is disabled. Introduced in GitLab 17.0: **Status**: Experiment."
  achievementsPath: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  "URL to avatar image file of the namespace."
  avatarUrl: String
  "Namespace CI/CD settings for the namespace. Introduced in GitLab 17.9: **Status**: Experiment."
  ciCdSettings: CiCdSettings @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Indicates if the cross_project_pipeline feature is available for the namespace."
  crossProjectPipelineAvailable: Boolean!
  "Description of the namespace."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Full name of the namespace."
  fullName: String!
  "Full path of the namespace."
  fullPath: ID!
  "ID of the namespace."
  id: ID!
  "Import source users of the namespace. This field can only be resolved for one namespace in any single request. Introduced in GitLab 17.2: **Status**: Experiment."
  importSourceUsers(
    "Filter mapping of users on source instance to users on destination instance by status."
    statuses: [ImportSourceUserStatus!],
    "Query to search mappings by name or username of users on source instance."
    search: String,
    "Sort mapping of users on source instance to users on destination instance by the criteria."
    sort: SourceUserSort = SOURCE_NAME_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ImportSourceUserConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  "Indicates if Large File Storage (LFS) is enabled for namespace."
  lfsEnabled: Boolean
  "Name of the namespace."
  name: String!
  "Package settings for the namespace."
  packageSettings: PackageSettings
  "List of the namespaces's Pages Deployments."
  pagesDeployments(
    "Filter by active or inactive state."
    active: Boolean,
    "Sort results."
    sort: Sort,
    """
    Filter deployments that are
    versioned or unversioned.
    """
    versioned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PagesDeploymentConnection
  "Path of the namespace."
  path: String!
  "Projects within this namespace. Returns projects from the parent group if namespace is project."
  projects(
    "Include also subgroup projects."
    includeSubgroups: Boolean = false,
    "Include also archived projects."
    includeArchived: Boolean = true,
    "Include projects that are not aimed for deletion."
    notAimedForDeletion: Boolean = false,
    "Search project with most similar names or paths."
    search: String = null,
    "Sort projects by the criteria."
    sort: NamespaceProjectSort = null,
    "Filter projects by IDs."
    ids: [ID!] = null,
    "Return only projects with issues enabled."
    withIssuesEnabled: Boolean,
    "Return only projects with merge requests enabled."
    withMergeRequestsEnabled: Boolean,
    "Return only projects that use the namespace domain for pages projects."
    withNamespaceDomainPages: Boolean,
    "Return only archived projects."
    archivedOnly: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection!
  "Indicates if users can request access to namespace."
  requestAccessEnabled: Boolean
  "Aggregated storage statistics of the namespace. Only available for root namespaces."
  rootStorageStatistics: RootStorageStatistics
  "Shared runners availability for the namespace and its descendants."
  sharedRunnersSetting: SharedRunnersSetting
  "Data needed to render the sidebar for the namespace. Introduced in GitLab 17.6: **Status**: Experiment."
  sidebar: NamespaceSidebar @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Timelog categories for the namespace. Introduced in GitLab 15.3: **Status**: Experiment."
  timelogCategories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimeTrackingTimelogCategoryConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.3.")
  "Permissions for the current user on the resource"
  userPermissions: NamespacePermissions!
  "Visibility of the namespace."
  visibility: String
  "URL of the object."
  webUrl: String
  "Find a work item by IID directly associated with the namespace(project or group).  Returns `null` for group level work items if the `namespace_level_work_items` feature flag is disabled. Introduced in GitLab 16.10: **Status**: Experiment."
  workItem(
    "IID of the work item."
    iid: String!
  ): WorkItem @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.10.")
  "Work item description templates available to the namespace. Introduced in GitLab 17.6: **Status**: Experiment."
  workItemDescriptionTemplates(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemDescriptionTemplateConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Work item types available to the namespace. Introduced in GitLab 17.2: **Status**: Experiment."
  workItemTypes(
    "Filter work item types by the given name."
    name: IssueType,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemTypeConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
}
type NamespaceCommitEmail {
  "Timestamp the namespace commit email was created."
  createdAt: Time!
  "Email."
  email: Email!
  "Internal ID of the namespace commit email."
  id: ID!
  "Namespace."
  namespace: Namespace!
  "Timestamp the namespace commit email was last updated."
  updatedAt: Time!
}
"The connection type for NamespaceCommitEmail."
type NamespaceCommitEmailConnection {
  "A list of edges."
  edges: [NamespaceCommitEmailEdge]
  "A list of nodes."
  nodes: [NamespaceCommitEmail]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type NamespaceCommitEmailEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: NamespaceCommitEmail
}
"The connection type for Namespace."
type NamespaceConnection {
  "A list of edges."
  edges: [NamespaceEdge]
  "A list of nodes."
  nodes: [Namespace]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type NamespaceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Namespace
}
type NamespacePermissions {
  "If `true`, the user can perform `read_namespace` on this resource"
  readNamespace: Boolean!
}
"Autogenerated return type of NamespaceSettingsUpdate."
type NamespaceSettingsUpdatePayload {
  "Namespace CI/CD settings after mutation."
  ciCdSettings: CiCdSettings!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type NamespaceSidebar {
  "Number of open issues of the namespace."
  openIssuesCount: Int
  "Number of open merge requests of the namespace."
  openMergeRequestsCount: Int
}
"Describes where code is deployed for a project organized by folder."
type NestedEnvironment {
  "Latest environment in the folder."
  environment: Environment
  "Human-readable name of the environment."
  name: String!
  "Number of environments nested in the folder."
  size: Int!
}
"The connection type for NestedEnvironment."
type NestedEnvironmentConnection {
  "A list of edges."
  edges: [NestedEnvironmentEdge]
  "A list of nodes."
  nodes: [NestedEnvironment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type NestedEnvironmentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: NestedEnvironment
}
type Note implements BaseNoteInterface & ResolvableInterface {
  "User who wrote the note."
  author: UserCore
  "Indicates whether the note author is a contributor."
  authorIsContributor: Boolean
  "List of emoji reactions associated with the note."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Content of the note."
  body: String!
  "First line of the note content."
  bodyFirstLineHtml: String!
  "GitLab Flavored Markdown rendering of the content of the note."
  bodyHtml: String
  "Timestamp of the note creation."
  createdAt: Time!
  "Discussion the note is a part of."
  discussion: Discussion
  "Email address of non-GitLab user adding the note. For guests, the email address is obfuscated."
  externalAuthor: String
  "ID of the note."
  id: NoteID!
  "Indicates whether the note was imported."
  imported: Boolean
  "Indicates if the note is internal."
  internal: Boolean
  "Timestamp when note was last edited."
  lastEditedAt: Time
  "User who last edited the note."
  lastEditedBy: UserCore
  "Max access level of the note author in the project."
  maxAccessLevelOfAuthor: String
  "Position of the note on a diff."
  position: DiffPosition
  "Project associated with the note."
  project: Project
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
  "Indicates whether the note was created by the system or by a user."
  system: Boolean!
  "Name of the icon corresponding to a system note."
  systemNoteIconName: String
  "Metadata for the given note if it is a system note."
  systemNoteMetadata: SystemNoteMetadata
  "Timestamp of the note's last activity."
  updatedAt: Time!
  "URL to view the note in the Web UI."
  url: String
  "Permissions for the current user on the resource"
  userPermissions: NotePermissions!
}
"The connection type for Note."
type NoteConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [NoteEdge]
  "A list of nodes."
  nodes: [Note]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of NoteConvertToThread."
type NoteConvertToThreadPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"An edge in a connection."
type NoteEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Note
}
type NotePermissions {
  "If `true`, the user can perform `admin_note` on this resource"
  adminNote: Boolean!
  "If `true`, the user can perform `award_emoji` on this resource"
  awardEmoji: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `read_note` on this resource"
  readNote: Boolean!
  "If `true`, the user can perform `reposition_note` on this resource"
  repositionNote: Boolean!
  "If `true`, the user can perform `resolve_note` on this resource"
  resolveNote: Boolean!
}
"Nuget dependency link metadata"
type NugetDependencyLinkMetadata {
  "ID of the metadatum."
  id: PackagesNugetDependencyLinkMetadatumID!
  "Target framework of the dependency link package."
  targetFramework: String!
}
"Nuget metadata"
type NugetMetadata {
  "Icon URL of the Nuget package."
  iconUrl: String
  "ID of the metadatum."
  id: PackagesNugetMetadatumID!
  "License URL of the Nuget package."
  licenseUrl: String
  "Project URL of the Nuget package."
  projectUrl: String
}
type Organization {
  "Avatar URL of the organization. Introduced in GitLab 16.7: **Status**: Experiment."
  avatarUrl: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  "Description of the organization. Introduced in GitLab 16.7: **Status**: Experiment."
  description: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  "GitLab Flavored Markdown rendering of `description` Introduced in GitLab 16.7: **Status**: Experiment."
  descriptionHtml: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  "Groups within this organization that the user has access to. Introduced in GitLab 16.4: **Status**: Experiment."
  groups(
    "Filter groups by IDs."
    ids: [ID!],
    "Only include top-level groups."
    topLevelOnly: Boolean = false,
    "Only include groups where the current user has an owner role."
    ownedOnly: Boolean = false,
    "Search query for group name or group full path."
    search: String,
    "Sort order of results. Format: `<field_name>_<sort_direction>`, for example: `id_desc` or `name_asc`"
    sort: String = "name_asc",
    "Full path of the parent group."
    parentPath: ID,
    """
    When `true`, returns all accessible groups. When `false`, returns only groups where the user is a member.
    Unauthenticated requests always return all public groups. The `owned_only` argument takes precedence.
    """
    allAvailable: Boolean = true,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "ID of the organization. Introduced in GitLab 16.4: **Status**: Experiment."
  id: ID! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "Name of the organization. Introduced in GitLab 16.4: **Status**: Experiment."
  name: String! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "Users with access to the organization. Introduced in GitLab 16.4: **Status**: Experiment."
  organizationUsers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationUserConnection! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "Path of the organization. Introduced in GitLab 16.4: **Status**: Experiment."
  path: String! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "Projects within this organization that the user has access to. Introduced in GitLab 16.8: **Status**: Experiment."
  projects(
    "Return only projects that the current user is a member of."
    membership: Boolean,
    "Search query, which can be for the project name, a path, or a description."
    search: String,
    "Include namespace in project search."
    searchNamespaces: Boolean,
    "Filter projects by topics."
    topics: [String!],
    "Return only personal projects."
    personal: Boolean,
    "Sort order of results. Format: `<field_name>_<sort_direction>`, for example: `id_desc` or `name_asc`"
    sort: String = "id_desc",
    "Filter projects by IDs."
    ids: [ID!],
    "Filter projects by full paths. You cannot provide more than 50 full paths."
    fullPaths: [String!],
    "Return only projects with issues enabled."
    withIssuesEnabled: Boolean,
    "Return only projects with merge requests enabled."
    withMergeRequestsEnabled: Boolean,
    "Filter projects by archived status."
    archived: ProjectArchived,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Return only projects that are trending."
    trending: Boolean,
    "Exclude projects that are marked for deletion."
    notAimedForDeletion: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.8.")
  "Web URL of the organization. Introduced in GitLab 16.6: **Status**: Experiment."
  webUrl: String! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
}
"The connection type for Organization."
type OrganizationConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [OrganizationEdge]
  "A list of nodes."
  nodes: [Organization]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of OrganizationCreate."
type OrganizationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after mutation."
  organization: Organization
}
"An edge in a connection."
type OrganizationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Organization
}
"Represents the total number of organizations for the represented states."
type OrganizationStateCounts {
  "Number of organizations with state `ACTIVE`"
  active: Int
  "Number of organizations with state `ALL`"
  all: Int
  "Number of organizations with state `INACTIVE`"
  inactive: Int
}
"Autogenerated return type of OrganizationUpdate."
type OrganizationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after mutation."
  organization: Organization
}
"A user with access to the organization."
type OrganizationUser {
  "Access level of the user in the organization. Introduced in GitLab 16.11: **Status**: Experiment."
  accessLevel: OrganizationUserAccess! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Badges describing the user within the organization. Introduced in GitLab 16.4: **Status**: Experiment."
  badges: [OrganizationUserBadge!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "ID of the organization user. Introduced in GitLab 16.4: **Status**: Experiment."
  id: ID! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "Whether the user is the last owner of the organization. Introduced in GitLab 16.11: **Status**: Experiment."
  isLastOwner: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "User that is associated with the organization. Introduced in GitLab 16.4: **Status**: Experiment."
  user: UserCore! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "Permissions for the current user on the resource"
  userPermissions: OrganizationUserPermissions!
}
"Represents the access level of a relationship between a User and Organization that it is related to"
type OrganizationUserAccess {
  "Integer representation of access level. Introduced in GitLab 16.11: **Status**: Experiment."
  integerValue: Int @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "String representation of access level. Introduced in GitLab 16.11: **Status**: Experiment."
  stringValue: OrganizationUserAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
}
"An organization user badge."
type OrganizationUserBadge {
  "Badge text."
  text: String!
  "Badge variant."
  variant: String!
}
"The connection type for OrganizationUser."
type OrganizationUserConnection {
  "A list of edges."
  edges: [OrganizationUserEdge]
  "A list of nodes."
  nodes: [OrganizationUser]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type OrganizationUserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OrganizationUser
}
type OrganizationUserPermissions {
  "If `true`, the user can perform `admin_organization` on this resource"
  adminOrganization: Boolean!
  "If `true`, the user can perform `delete_user` on this resource"
  deleteUser: Boolean!
  "If `true`, the user can perform `remove_user` on this resource"
  removeUser: Boolean!
}
"Autogenerated return type of OrganizationUserUpdate."
type OrganizationUserUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization user after mutation. Introduced in GitLab 17.5: **Status**: Experiment."
  organizationUser: OrganizationUser @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
}
"Represents a package with pipelines in the package registry"
type Package {
  "Map of links to perform actions on the package."
  _links: PackageLinks!
  "Date of creation."
  createdAt: Time!
  "ID of the package."
  id: PackagesPackageID!
  "Package metadata."
  metadata: PackageMetadata
  "Name of the package."
  name: String!
  "Package type."
  packageType: PackageTypeEnum!
  """
                Pipelines that built the package. Max page size 20.
  """
  pipelines(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Project where the package is stored."
  project: Project!
  "Whether any matching package protection rule exists for the package."
  protectionRuleExists: Boolean!
  "Package status."
  status: PackageStatus!
  "Status message."
  statusMessage: String
  "Package tags."
  tags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageTagConnection
  "Date of most recent update."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PackagePermissions!
  "Version string."
  version: String
}
"Represents a package in the package registry"
type PackageBase {
  "Map of links to perform actions on the package."
  _links: PackageLinks!
  "Date of creation."
  createdAt: Time!
  "ID of the package."
  id: PackagesPackageID!
  "Package metadata."
  metadata: PackageMetadata
  "Name of the package."
  name: String!
  "Package type."
  packageType: PackageTypeEnum!
  "Project where the package is stored."
  project: Project!
  "Whether any matching package protection rule exists for the package."
  protectionRuleExists: Boolean!
  "Package status."
  status: PackageStatus!
  "Status message."
  statusMessage: String
  "Package tags."
  tags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageTagConnection
  "Date of most recent update."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PackagePermissions!
  "Version string."
  version: String
}
"The connection type for PackageBase."
type PackageBaseConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PackageBaseEdge]
  "A list of nodes."
  nodes: [PackageBase]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PackageBaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageBase
}
"Represents a composer JSON file"
type PackageComposerJsonType {
  "License set in the Composer JSON file."
  license: String
  "Name set in the Composer JSON file."
  name: String
  "Type set in the Composer JSON file."
  type: String
  "Version set in the Composer JSON file."
  version: String
}
"The connection type for Package."
type PackageConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PackageEdge]
  "A list of nodes."
  nodes: [Package]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Represents a package dependency."
type PackageDependency {
  "ID of the dependency."
  id: PackagesDependencyID!
  "Name of the dependency."
  name: String!
  "Version pattern of the dependency."
  versionPattern: String!
}
"Represents a package dependency link"
type PackageDependencyLink {
  "Dependency."
  dependency: PackageDependency
  "Dependency type."
  dependencyType: PackageDependencyType!
  "ID of the dependency link."
  id: PackagesDependencyLinkID!
  "Dependency link metadata."
  metadata: DependencyLinkMetadata
}
"The connection type for PackageDependencyLink."
type PackageDependencyLinkConnection {
  "A list of edges."
  edges: [PackageDependencyLinkEdge]
  "A list of nodes."
  nodes: [PackageDependencyLink]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PackageDependencyLinkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageDependencyLink
}
"Represents a package details in the Package Registry"
type PackageDetailsType {
  "Map of links to perform actions on the package."
  _links: PackageLinks!
  "Url of the Composer setup endpoint."
  composerConfigRepositoryUrl: String
  "Url of the Composer endpoint."
  composerUrl: String
  "Url of the Conan project endpoint."
  conanUrl: String
  "Date of creation."
  createdAt: Time!
  "Dependency link."
  dependencyLinks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageDependencyLinkConnection
  "ID of the package."
  id: PackagesPackageID!
  "Last time that a file of the package was downloaded."
  lastDownloadedAt: Time
  "Url of the Maven project endpoint."
  mavenUrl: String
  "Package metadata."
  metadata: PackageMetadata
  "Name of the package."
  name: String!
  "Url of the NPM project endpoint."
  npmUrl: String
  "Url of the Nuget project endpoint."
  nugetUrl: String
  "Package files."
  packageFiles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageFileConnection
  "Package type."
  packageType: PackageTypeEnum!
  """
                Pipelines that built the package. Max page size 20.
  """
  pipelines(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Project where the package is stored."
  project: Project!
  "Whether any matching package protection rule exists for the package."
  protectionRuleExists: Boolean!
  "Indicates if there is public access to the package."
  publicPackage: Boolean
  "Url of the PyPi project setup endpoint."
  pypiSetupUrl: String
  "Url of the PyPi project endpoint."
  pypiUrl: String
  "Package status."
  status: PackageStatus!
  "Status message."
  statusMessage: String
  "Package tags."
  tags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageTagConnection
  "Date of most recent update."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PackagePermissions!
  "Version string."
  version: String
  "Other versions of the package."
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageBaseConnection
}
"An edge in a connection."
type PackageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Package
}
"Represents a package file"
type PackageFile {
  "Created date."
  createdAt: Time!
  "Download path of the package file."
  downloadPath: String!
  "Md5 of the package file."
  fileMd5: String
  "File metadata."
  fileMetadata: PackageFileMetadata
  "Name of the package file."
  fileName: String!
  "Sha1 of the package file."
  fileSha1: String
  "Sha256 of the package file."
  fileSha256: String
  "ID of the file."
  id: PackagesPackageFileID!
  "Size of the package file."
  size: String!
  "Updated date."
  updatedAt: Time!
}
"The connection type for PackageFile."
type PackageFileConnection {
  "A list of edges."
  edges: [PackageFileEdge]
  "A list of nodes."
  nodes: [PackageFile]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PackageFileEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageFile
}
"Represents a Helm dependency"
type PackageHelmDependencyType {
  "Alias of the dependency."
  alias: String
  "Condition of the dependency."
  condition: String
  "Indicates the dependency is enabled."
  enabled: Boolean
  "Import-values of the dependency."
  importValues: [JSON!]
  "Name of the dependency."
  name: String
  "Repository of the dependency."
  repository: String
  "Tags of the dependency."
  tags: [String!]
  "Version of the dependency."
  version: String
}
"Represents a Helm maintainer"
type PackageHelmMaintainerType {
  "Email of the maintainer."
  email: String
  "Name of the maintainer."
  name: String
  "URL of the maintainer."
  url: String
}
"Represents the contents of a Helm Chart.yml file"
type PackageHelmMetadataType {
  "Annotations for the chart."
  annotations: JSON
  "API version of the chart."
  apiVersion: String!
  "App version of the chart."
  appVersion: String
  "Condition for the chart."
  condition: String
  "Dependencies of the chart."
  dependencies: [PackageHelmDependencyType!]
  "Indicates if the chart is deprecated."
  deprecated: Boolean
  "Description of the chart."
  description: String
  "URL of the home page."
  home: String
  "URL to an SVG or PNG image for the chart."
  icon: String
  "Keywords for the chart."
  keywords: [String!]
  "Kubernetes versions for the chart."
  kubeVersion: String
  "Maintainers of the chart."
  maintainers: [PackageHelmMaintainerType!]
  "Name of the chart."
  name: String!
  "URLs of the source code for the chart."
  sources: [String!]
  "Tags for the chart."
  tags: String
  "Type of the chart."
  type: String
  "Version of the chart."
  version: String!
}
"Represents links to perform actions on the package"
type PackageLinks {
  "Path to the package details page."
  webPath: String
}
type PackagePermissions {
  "If `true`, the user can perform `destroy_package` on this resource"
  destroyPackage: Boolean!
}
"Namespace-level Package Registry settings"
type PackageSettings {
  "When generic_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  genericDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate generic packages are allowed for the namespace."
  genericDuplicatesAllowed: Boolean!
  "Indicates whether Maven package forwarding is locked for all descendent namespaces."
  lockMavenPackageRequestsForwarding: Boolean!
  "Indicates whether npm package forwarding is locked for all descendent namespaces."
  lockNpmPackageRequestsForwarding: Boolean!
  "Indicates whether PyPI package forwarding is locked for all descendent namespaces."
  lockPypiPackageRequestsForwarding: Boolean!
  "When maven_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  mavenDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate Maven packages are allowed for the namespace."
  mavenDuplicatesAllowed: Boolean!
  "Indicates whether Maven package forwarding is allowed for the namespace."
  mavenPackageRequestsForwarding: Boolean
  "Indicates whether Maven package forwarding settings are locked by a parent namespace."
  mavenPackageRequestsForwardingLocked: Boolean!
  "Indicates whether npm package forwarding is allowed for the namespace."
  npmPackageRequestsForwarding: Boolean
  "Indicates whether npm package forwarding settings are locked by a parent namespace."
  npmPackageRequestsForwardingLocked: Boolean!
  "When nuget_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. "
  nugetDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate NuGet packages are allowed for the namespace."
  nugetDuplicatesAllowed: Boolean!
  "Indicates whether the NuGet symbol server is enabled for the namespace."
  nugetSymbolServerEnabled: Boolean!
  "Indicates whether PyPI package forwarding is allowed for the namespace."
  pypiPackageRequestsForwarding: Boolean
  "Indicates whether PyPI package forwarding settings are locked by a parent namespace."
  pypiPackageRequestsForwardingLocked: Boolean!
  "When terraform_module_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  terraformModuleDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate Terraform packages are allowed for the namespace."
  terraformModuleDuplicatesAllowed: Boolean!
}
"Represents a package tag"
type PackageTag {
  "Created date."
  createdAt: Time!
  "ID of the tag."
  id: ID!
  "Name of the tag."
  name: String!
  "Updated date."
  updatedAt: Time!
}
"The connection type for PackageTag."
type PackageTagConnection {
  "A list of edges."
  edges: [PackageTagEdge]
  "A list of nodes."
  nodes: [PackageTag]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PackageTagEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageTag
}
"A packages cleanup policy designed to keep only packages and packages assets that matter most"
type PackagesCleanupPolicy {
  "Number of duplicated package files to retain."
  keepNDuplicatedPackageFiles: PackagesCleanupKeepDuplicatedPackageFilesEnum!
  "Next time that the packages cleanup policy will be executed."
  nextRunAt: Time
}
"A packages protection rule designed to protect packages from being pushed by users with a certain access level."
type PackagesProtectionRule {
  "Global ID of the package protection rule."
  id: PackagesProtectionRuleID!
  "Minimum GitLab access required to delete packages from the package registry. Valid values include `OWNER` or `ADMIN`. If the value is `nil`, the default minimum access level is `MAINTAINER`. Available only when feature flag `packages_protected_packages_delete` is enabled. Introduced in GitLab 17.10: **Status**: Experiment."
  minimumAccessLevelForDelete: PackagesProtectionRuleAccessLevelForDelete @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Minimum GitLab access required to push packages to the package registry. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForPush: PackagesProtectionRuleAccessLevel
  "Package name protected by the protection rule. For example, `@my-scope/my-package-*`. Wildcard character `*` allowed."
  packageNamePattern: String!
  "Package type protected by the protection rule. For example, `NPM`, `PYPI`."
  packageType: PackagesProtectionRulePackageType!
}
"The connection type for PackagesProtectionRule."
type PackagesProtectionRuleConnection {
  "A list of edges."
  edges: [PackagesProtectionRuleEdge]
  "A list of nodes."
  nodes: [PackagesProtectionRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PackagesProtectionRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackagesProtectionRule
}
"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}
"Represents a pages deployment."
type PagesDeployment {
  "Whether the deployment is currently active."
  active: Boolean!
  "ID of the CI build that created the deployment."
  ciBuildId: ID
  "Time the deployment was created."
  createdAt: ISO8601DateTime!
  "Time the deployment was deleted."
  deletedAt: ISO8601DateTime
  "Time the deployment will expire."
  expiresAt: ISO8601DateTime
  "Number of files that were published with the deployment."
  fileCount: Int
  "ID of the Pages Deployment."
  id: ID!
  "URL path Prefix that points to the deployment."
  pathPrefix: String
  "Project the deployment belongs to."
  project: Project!
  "Path within the build assets that functions as the root directory for Pages sites."
  rootDirectory: String
  "Size of the storage used."
  size: Int
  "Time the deployment was last updated."
  updatedAt: ISO8601DateTime!
  "Publicly accessible URL of the deployment."
  url: String!
}
"The connection type for PagesDeployment."
type PagesDeploymentConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PagesDeploymentEdge]
  "A list of nodes."
  nodes: [PagesDeployment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PagesDeploymentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PagesDeployment
}
"Autogenerated return type of PagesMarkOnboardingComplete."
type PagesMarkOnboardingCompletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Indicates the new onboarding_complete state of the project's Pages metadata."
  onboardingComplete: Boolean!
}
type Pipeline implements PipelineInterface {
  "Indicates if the pipeline is active."
  active: Boolean!
  "Base SHA of the source branch."
  beforeSha: String
  "Specifies if a pipeline can be canceled."
  cancelable: Boolean!
  "If the pipeline is a child or not."
  child: Boolean!
  "Git commit of the pipeline."
  commit: Commit
  "Path to the commit that triggered the pipeline."
  commitPath: String
  "Timestamp of the pipeline's commit."
  committedAt: Time
  "Indicates if a pipeline is complete."
  complete: Boolean!
  "Configuration source of the pipeline (UNKNOWN_SOURCE, REPOSITORY_SOURCE, AUTO_DEVOPS_SOURCE, WEBIDE_SOURCE, REMOTE_SOURCE, EXTERNAL_PROJECT_SOURCE, BRIDGE_SOURCE, PARAMETER_SOURCE, COMPLIANCE_SOURCE, SECURITY_POLICIES_DEFAULT_SOURCE, PIPELINE_EXECUTION_POLICY_FORCED)"
  configSource: PipelineConfigSourceEnum
  "Coverage percentage."
  coverage: Float
  "Timestamp of the pipeline's creation."
  createdAt: Time!
  "Detailed status of the pipeline."
  detailedStatus: DetailedStatus!
  "Pipelines the pipeline will trigger."
  downstream(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Duration of the pipeline in seconds."
  duration: Int
  "Pipeline error messages."
  errorMessages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineMessageConnection
  "Reason why the pipeline failed."
  failureReason: String
  "Timestamp of the pipeline's completion."
  finishedAt: Time
  "ID of the pipeline."
  id: ID!
  "Internal ID of the pipeline."
  iid: String!
  "Specific job in the pipeline, either by name or ID."
  job(
    "ID of the job."
    id: JobID,
    "Name of the job."
    name: String
  ): CiJob
  "Job artifacts of the pipeline."
  jobArtifacts: [CiJobArtifact!]
  "Jobs belonging to the pipeline."
  jobs(
    "Filter jobs by kind."
    jobKind: CiJobKind,
    "Filter jobs by retry-status."
    retried: Boolean,
    "Filter jobs by the type of security report they produce."
    securityReportTypes: [SecurityReportTypeEnum!],
    "Filter jobs by status."
    statuses: [CiJobStatus!],
    "Filter jobs by when they are executed."
    whenExecuted: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "If the pipeline is the latest one or not."
  latest: Boolean!
  "CI/CD variables added to a manual pipeline."
  manualVariables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineManualVariableConnection
  "MR which the Pipeline is attached to."
  mergeRequest: MergeRequest
  "Event type of the pipeline associated with a merge request."
  mergeRequestEventType: PipelineMergeRequestEventType
  "Name of the pipeline."
  name: String
  "Relative path to the pipeline's page."
  path: String
  "Project the pipeline belongs to."
  project: Project
  "How long the pipeline was queued before starting."
  queuedDuration: Duration
  "Reference to the branch from which the pipeline was triggered."
  ref: String
  "Reference path to the branch from which the pipeline was triggered."
  refPath: String
  "Reference text from the presenter."
  refText: String!
  "Specifies if a pipeline's jobs can be retried."
  retryable: Boolean!
  "SHA of the pipeline's commit."
  sha(
    "Format of the SHA."
    format: ShaFormat
  ): String
  "Source of the pipeline."
  source: String
  "Job where pipeline was triggered from."
  sourceJob: CiJob
  "Stages of the pipeline."
  stages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiStageConnection
  "Timestamp when the pipeline was started."
  startedAt: Time
  "Status of the pipeline (CREATED, WAITING_FOR_RESOURCE, PREPARING, WAITING_FOR_CALLBACK, PENDING, RUNNING, FAILED, SUCCESS, CANCELED, CANCELING, SKIPPED, MANUAL, SCHEDULED)"
  status: PipelineStatusEnum!
  "If the pipeline is stuck."
  stuck: Boolean!
  "Summary of the test report generated by the pipeline."
  testReportSummary: TestReportSummary!
  "A specific test suite in a pipeline test report."
  testSuite(
    "IDs of the builds used to run the test suite."
    buildIds: [ID!]!
  ): TestSuite
  "Total number of jobs in the pipeline."
  totalJobs: Int!
  "If the pipeline was created by a Trigger request."
  trigger: Boolean!
  "Path that triggered the pipeline."
  triggeredByPath: String
  "Type of the pipeline."
  type: String!
  "Timestamp of the pipeline's last activity."
  updatedAt: Time!
  "Pipeline that triggered the pipeline."
  upstream: Pipeline
  "Pipeline user."
  user: UserCore
  "Permissions for the current user on the resource"
  userPermissions: PipelinePermissions!
  "Indicates if the pipeline has jobs with `needs` dependencies."
  usesNeeds: Boolean
  "Pipeline warning messages."
  warningMessages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineMessageConnection
  "Indicates if a pipeline has warnings."
  warnings: Boolean!
  "Pipeline YAML errors."
  yamlErrorMessages: String
  "If the pipeline has YAML errors."
  yamlErrors: Boolean!
}
type PipelineAnalytics {
  "Pipeline analytics for the specified filter. Introduced in GitLab 17.5: **Status**: Experiment."
  aggregate: PipelineAnalyticsPeriod @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
  "Labels for the monthly pipeline count. Only available for projects."
  monthPipelinesLabels: [String!]
  "Total monthly successful pipeline count. Only available for projects."
  monthPipelinesSuccessful: [Int!]
  "Total monthly pipeline count. Only available for projects."
  monthPipelinesTotals: [Int!]
  "Pipeline times labels. Only available for projects."
  pipelineTimesLabels: [String!]
  "Pipeline times. Only available for projects."
  pipelineTimesValues: [Int!]
  "Pipeline analytics shown over time based on the specified filter. Data is aggregated in UTC, with adaptive resolution: hourly for 7-day windows or less, daily for longer periods. Introduced in GitLab 17.9: **Status**: Experiment."
  timeSeries(
    "Periodicity of aggregated data."
    period: AnalyticsAggregationPeriod!
  ): [PipelineAnalyticsPeriod!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Labels for the weekly pipeline count. Only available for projects."
  weekPipelinesLabels: [String!]
  "Total weekly successful pipeline count. Only available for projects."
  weekPipelinesSuccessful: [Int!]
  "Total weekly pipeline count. Only available for projects."
  weekPipelinesTotals: [Int!]
  "Labels for the yearly pipeline count. Only available for projects."
  yearPipelinesLabels: [String!]
  "Total yearly successful pipeline count. Only available for projects."
  yearPipelinesSuccessful: [Int!]
  "Total yearly pipeline count. Only available for projects."
  yearPipelinesTotals: [Int!]
}
type PipelineAnalyticsPeriod {
  "Pipeline count, optionally filtered by status. Introduced in GitLab 17.5: **Status**: Experiment."
  count(
    "Filter pipeline totals by status. If not specified, totals for all pipeline statuses are returned."
    status: PipelineAnalyticsJobStatus! = ANY
  ): BigInt @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
  "Pipeline duration statistics. Introduced in GitLab 17.5: **Status**: Experiment."
  durationStatistics: CiDurationStatistics @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
  "Data point label (UTC time). Introduced in GitLab 17.5: **Status**: Experiment."
  label: Date @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
}
"Autogenerated return type of PipelineCancel."
type PipelineCancelPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"The connection type for Pipeline."
type PipelineConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PipelineEdge]
  "A list of nodes."
  nodes: [Pipeline]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Represents pipeline counts for the project"
type PipelineCounts {
  "Total number of pipelines for the project."
  all: Int
  "Number of pipelines with scope FINISHED for the project"
  finished: Int
  "Number of pipelines with scope PENDING for the project"
  pending: Int
  "Number of pipelines with scope RUNNING for the project"
  running: Int
}
"Autogenerated return type of PipelineCreate."
type PipelineCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Pipeline created after mutation. Null if `async: true`."
  pipeline: Pipeline
  "ID for checking the pipeline creation status. Null if `async: false`. Introduced in GitLab 17.8: **Status**: Experiment."
  requestId: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
}
"Autogenerated return type of PipelineDestroy."
type PipelineDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type PipelineEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Pipeline
}
"CI/CD variables added to a manual pipeline."
type PipelineManualVariable {
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Value of the variable."
  value: String
}
"The connection type for PipelineManualVariable."
type PipelineManualVariableConnection {
  "A list of edges."
  edges: [PipelineManualVariableEdge]
  "A list of nodes."
  nodes: [PipelineManualVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PipelineManualVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineManualVariable
}
type PipelineMessage {
  "Content of the pipeline message."
  content: String!
  "ID of the pipeline message."
  id: ID!
}
"The connection type for PipelineMessage."
type PipelineMessageConnection {
  "A list of edges."
  edges: [PipelineMessageEdge]
  "A list of nodes."
  nodes: [PipelineMessage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PipelineMessageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineMessage
}
type PipelinePermissions {
  "If `true`, the user can perform `admin_pipeline` on this resource"
  adminPipeline: Boolean!
  "If `true`, the user can perform `cancel_pipeline` on this resource"
  cancelPipeline: Boolean!
  "If `true`, the user can perform `destroy_pipeline` on this resource"
  destroyPipeline: Boolean!
  "If `true`, the user can perform `update_pipeline` on this resource"
  updatePipeline: Boolean!
}
"Autogenerated return type of PipelineRetry."
type PipelineRetryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Pipeline after mutation."
  pipeline: Pipeline
}
"Represents a pipeline schedule"
type PipelineSchedule {
  "Indicates if the pipeline schedule is active."
  active: Boolean!
  "Timestamp of when the pipeline schedule was created."
  createdAt: Time!
  "Cron notation for the schedule."
  cron: String!
  "Timezone for the pipeline schedule."
  cronTimezone: String!
  "Description of the pipeline schedule."
  description: String
  "Edit path of the pipeline schedule."
  editPath: String
  "Indicates if a pipelines schedule belongs to a tag."
  forTag: Boolean!
  "ID of the pipeline schedule."
  id: ID!
  "Inputs configured for the pipeline schedule. Introduced in GitLab 17.10: **Status**: Experiment."
  inputs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiInputsFieldConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Last pipeline object."
  lastPipeline: Pipeline
  "Time when the next pipeline will run."
  nextRunAt: Time
  "Owner of the pipeline schedule."
  owner: UserCore
  "Project of the pipeline schedule."
  project: Project
  "Time when the next pipeline will run."
  realNextRun: Time
  "Ref of the pipeline schedule."
  ref: String
  "Git ref for the pipeline schedule."
  refForDisplay: String
  "Path to the ref that triggered the pipeline."
  refPath: String
  "Timestamp of when the pipeline schedule was last updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PipelineSchedulePermissions!
  "Pipeline schedule variables."
  variables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineScheduleVariableConnection
}
"The connection type for PipelineSchedule."
type PipelineScheduleConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PipelineScheduleEdge]
  "A list of nodes."
  nodes: [PipelineSchedule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of PipelineScheduleCreate."
type PipelineScheduleCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created pipeline schedule."
  pipelineSchedule: PipelineSchedule
}
"Autogenerated return type of PipelineScheduleDelete."
type PipelineScheduleDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type PipelineScheduleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineSchedule
}
type PipelineSchedulePermissions {
  "If `true`, the user can perform `admin_pipeline_schedule` on this resource"
  adminPipelineSchedule: Boolean!
  "If `true`, the user can perform `play_pipeline_schedule` on this resource"
  playPipelineSchedule: Boolean!
  "If `true`, the user can perform `take_ownership_pipeline_schedule` on this resource Deprecated in GitLab 15.9: Use admin_pipeline_schedule permission to determine if the user can take ownership of a pipeline schedule."
  takeOwnershipPipelineSchedule: Boolean! @deprecated(reason: "Use admin_pipeline_schedule permission to determine if the user can take ownership of a pipeline schedule. Deprecated in GitLab 15.9.")
  "If `true`, the user can perform `update_pipeline_schedule` on this resource"
  updatePipelineSchedule: Boolean!
}
"Autogenerated return type of PipelineSchedulePlay."
type PipelineSchedulePlayPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Pipeline schedule after mutation."
  pipelineSchedule: PipelineSchedule
}
"Autogenerated return type of PipelineScheduleTakeOwnership."
type PipelineScheduleTakeOwnershipPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated pipeline schedule ownership."
  pipelineSchedule: PipelineSchedule
}
"Autogenerated return type of PipelineScheduleUpdate."
type PipelineScheduleUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated pipeline schedule."
  pipelineSchedule: PipelineSchedule
}
type PipelineScheduleVariable implements CiVariable {
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}
"The connection type for PipelineScheduleVariable."
type PipelineScheduleVariableConnection {
  "A list of edges."
  edges: [PipelineScheduleVariableEdge]
  "A list of nodes."
  nodes: [PipelineScheduleVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PipelineScheduleVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineScheduleVariable
}
type PipelineTrigger {
  "Indicates if the pipeline trigger token has access to the project."
  canAccessProject: Boolean!
  "Description of the pipeline trigger token."
  description: String
  "Timestamp of when the pipeline trigger token expires."
  expiresAt: Time
  "Indicates if the token is exposed."
  hasTokenExposed: Boolean!
  "ID of the pipeline trigger token."
  id: ID!
  "Timestamp of the last usage of the pipeline trigger token."
  lastUsed: Time
  "Owner of the pipeline trigger token."
  owner: UserCore!
  "Value of the pipeline trigger token."
  token: String!
}
"The connection type for PipelineTrigger."
type PipelineTriggerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PipelineTriggerEdge]
  "A list of nodes."
  nodes: [PipelineTrigger]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of PipelineTriggerCreate."
type PipelineTriggerCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mutated pipeline trigger token."
  pipelineTrigger: PipelineTrigger
}
"Autogenerated return type of PipelineTriggerDelete."
type PipelineTriggerDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type PipelineTriggerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineTrigger
}
"Autogenerated return type of PipelineTriggerUpdate."
type PipelineTriggerUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mutated pipeline trigger token."
  pipelineTrigger: PipelineTrigger
}
type Project implements ProjectInterface & Todoable {
  "Agent configurations defined by the project"
  agentConfigurations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AgentConfigurationConnection
  "A single Alert Management alert of the project."
  alertManagementAlert(
    """
    IID of the alert. For example, "1".
    """
    iid: String,
    "Alerts with the specified statues. For example, `[TRIGGERED]`."
    statuses: [AlertManagementStatus!],
    "Sort alerts by the criteria."
    sort: AlertManagementAlertSort,
    "Filter query for given domain."
    domain: AlertManagementDomainFilter! = operations,
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Username of a user assigned to the issue."
    assigneeUsername: String
  ): AlertManagementAlert
  "Counts of alerts by status for the project."
  alertManagementAlertStatusCounts(
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Username of a user assigned to the issue."
    assigneeUsername: String
  ): AlertManagementAlertStatusCountsType
  "Alert Management alerts of the project."
  alertManagementAlerts(
    """
    IID of the alert. For example, "1".
    """
    iid: String,
    "Alerts with the specified statues. For example, `[TRIGGERED]`."
    statuses: [AlertManagementStatus!],
    "Sort alerts by the criteria."
    sort: AlertManagementAlertSort,
    "Filter query for given domain."
    domain: AlertManagementDomainFilter! = operations,
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Username of a user assigned to the issue."
    assigneeUsername: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AlertManagementAlertConnection
  "HTTP Integrations which can receive alerts for the project."
  alertManagementHttpIntegrations(
    "ID of the integration."
    id: AlertManagementHttpIntegrationID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AlertManagementHttpIntegrationConnection
  "Integrations which can receive alerts for the project."
  alertManagementIntegrations(
    "ID of the integration."
    id: GlobalID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AlertManagementIntegrationConnection
  "If `only_allow_merge_if_pipeline_succeeds` is true, indicates if merge requests of the project can also be merged with skipped jobs."
  allowMergeOnSkippedPipeline: Boolean
  "Project allows assigning multiple users to a merge request."
  allowsMultipleMergeRequestAssignees: Boolean!
  "Project allows assigning multiple reviewers to a merge request."
  allowsMultipleMergeRequestReviewers: Boolean!
  "Indicates the archived status of the project."
  archived: Boolean
  "Indicates if issues referenced by merge requests and commits within the default branch are closed automatically."
  autocloseReferencedIssues: Boolean
  "Search users for autocompletion"
  autocompleteUsers(
    "Query to search users by name, username, or public email."
    search: String
  ): [AutocompletedUser!]
  "List of available deploy keys"
  availableDeployKeys(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Term by which to search deploy key titles."
    titleQuery: String
  ): AccessLevelDeployKeyConnection
  "Avatar URL of the project."
  avatarUrl: String
  "A single board of the project."
  board(
    "ID of the board."
    id: BoardID!
  ): Board
  "Boards of the project."
  boards(
    "Find a board by its ID."
    id: BoardID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "Branch rules configured for the project."
  branchRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BranchRuleConnection
  "Authorized cluster agents for the project through ci_access keyword."
  ciAccessAuthorizedAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentAuthorizationCiAccessConnection
  "CI/CD settings for the project."
  ciCdSettings: ProjectCiCdSetting
  "Path of the CI configuration file."
  ciConfigPathOrDefault: String!
  "CI/CD config variable. Introduced in GitLab 15.3: **Status**: Experiment."
  ciConfigVariables(
    "Ref."
    ref: String!
  ): [CiConfigVariable!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.3.")
  "The CI Job Tokens authorization logs. Introduced in GitLab 17.6: **Status**: Experiment."
  ciJobTokenAuthLogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobTokenAuthLogConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "The CI Job Tokens scope of access."
  ciJobTokenScope: CiJobTokenScopeType
  "List of CI job token scopes where the project is the source. Introduced in GitLab 17.6: **Status**: Experiment."
  ciJobTokenScopeAllowlist: CiJobTokenScopeAllowlist @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Inputs to create a pipeline. Introduced in GitLab 17.10: **Status**: Experiment."
  ciPipelineCreationInputs(
    "Ref where to create the pipeline."
    ref: String!
  ): [CiInputsSpec!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Get information about an asynchronous pipeline creation request. Introduced in GitLab 17.9: **Status**: Experiment."
  ciPipelineCreationRequest(
    "ID of the pipeline creation request."
    requestId: String!
  ): CiPipelineCreationRequest @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Find a single CI/CD template by name."
  ciTemplate(
    "Name of the CI/CD template to search for. Template must be formatted as `Name.gitlab-ci.yml`."
    name: String!
  ): CiTemplate
  "List of the project's CI/CD variables."
  ciVariables(
    "Sort order of results."
    sort: CiVariableSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiProjectVariableConnection
  "Find a single cluster agent by name."
  clusterAgent(
    "Name of the cluster agent."
    name: String!
  ): ClusterAgent
  "Cluster agents associated with the project."
  clusterAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentConnection
  "Get tag names containing a given commit. Introduced in GitLab 16.0: **Status**: Experiment."
  commitReferences(
    "Project commit SHA identifier. For example, `287774414568010855642518513f085491644061`."
    commitSha: String!
  ): CommitReferences @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.0.")
  "Container expiration policy of the project. Deprecated in GitLab 17.5: Use `container_tags_expiration_policy`."
  containerExpirationPolicy: ContainerExpirationPolicy @deprecated(reason: "Use `container_tags_expiration_policy`. Deprecated in GitLab 17.5.")
  "Container protection rules for the project. Introduced in GitLab 16.10: **Status**: Experiment."
  containerProtectionRepositoryRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ContainerProtectionRepositoryRuleConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.10.")
  "Container repository tag protection rules for the project. Introduced in GitLab 17.8: **Status**: Experiment."
  containerProtectionTagRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ContainerProtectionTagRuleConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Indicates if Container registry is enabled for the current user"
  containerRegistryEnabled: Boolean
  "Container repositories of the project."
  containerRepositories(
    "Filter the container repositories by their name."
    name: String,
    "Sort container repositories by the criteria."
    sort: ContainerRepositorySort = created_desc,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ContainerRepositoryConnection
  "Number of container repositories in the project."
  containerRepositoriesCount: Int!
  "Container tags expiration policy of the project."
  containerTagsExpirationPolicy: ContainerTagsExpirationPolicy
  "Timestamp of the project creation."
  createdAt: Time
  "Data transfer data point for a specific period. This is mocked data under a development feature flag."
  dataTransfer(
    "Retain egress data for one year. Data for the current month will increase dynamically as egress occurs."
    from: Date,
    "End date for the data."
    to: Date
  ): ProjectDataTransfer
  "Details of the deployment of the project."
  deployment(
    "Project-level internal ID of the Deployment."
    iid: ID!
  ): Deployment
  "Short description of the project."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Detailed import status of the project."
  detailedImportStatus: DetailedImportStatus
  "A single environment of the project."
  environment(
    "Name of the environment."
    name: String,
    "Search query for environment name."
    search: String,
    "States of environments that should be included in result."
    states: [String!],
    "Search query for environment type."
    type: String
  ): Environment
  "Environments of the project. This field can only be resolved for one project in any single request."
  environments(
    "Name of the environment."
    name: String,
    "Search query for environment name."
    search: String,
    "States of environments that should be included in result."
    states: [String!],
    "Search query for environment type."
    type: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EnvironmentConnection
  "Path to the project catalog resource. Introduced in GitLab 17.6: **Status**: Experiment."
  exploreCatalogPath: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Flow metrics for value stream analytics. Introduced in GitLab 15.10: **Status**: Experiment."
  flowMetrics: ProjectValueStreamAnalyticsFlowMetrics @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Details of the fork project compared to its upstream project. Introduced in GitLab 15.7: **Status**: Experiment."
  forkDetails(
    "Ref of the fork. Default value is HEAD."
    ref: String
  ): ForkDetails @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.7.")
  "Namespaces in which the current user can fork the project into."
  forkTargets(
    "Search query for path or name."
    search: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceConnection
  "Project the project was forked from."
  forkedFrom: Project
  "Access level required for forking access."
  forkingAccessLevel: ProjectFeatureAccess
  "Number of times the project has been forked."
  forksCount: Int!
  "Full path of the project."
  fullPath: ID!
  "Grafana integration details for the project."
  grafanaIntegration: GrafanaIntegration
  "Group of the project."
  group: Group
  "URL to connect to the project via HTTPS."
  httpUrlToRepo: String
  "ID of the project."
  id: ID!
  "Status of import background job of the project."
  importStatus: String
  "Incident Management Timeline event associated with the incident."
  incidentManagementTimelineEvent(
    "ID of the incident."
    incidentId: IssueID!,
    "ID of the timeline event."
    id: IncidentManagementTimelineEventID!
  ): TimelineEventType
  "Timeline event tags for the project."
  incidentManagementTimelineEventTags: [TimelineEventTagType!]
  "Incident Management Timeline events associated with the incident."
  incidentManagementTimelineEvents(
    "ID of the incident."
    incidentId: IssueID!,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelineEventTypeConnection
  "List of CI/CD variables the project inherited from its parent group and ancestors."
  inheritedCiVariables(
    "Sort variables by the criteria."
    sort: CiGroupVariablesSort = CREATED_DESC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): InheritedCiVariableConnection
  "Indicates if delayed project deletion is enabled. Introduced in GitLab 16.11: **Status**: Experiment."
  isAdjournedDeletionEnabled: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Indicates if a project is a catalog resource. Introduced in GitLab 15.11: **Status**: Experiment."
  isCatalogResource: Boolean @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
  "Project is forked."
  isForked: Boolean!
  "A single issue of the project."
  issue(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    """
    ID of a user assigned to the issues. Wildcard values "NONE" and "ANY" are supported.
    """
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Issues closed after the date."
    closedAfter: Time,
    "Issues closed before the date."
    closedBefore: Time,
    """
    Filter for confidential issues. If "false", excludes confidential issues. If "true", returns only confidential issues.
    """
    confidential: Boolean,
    "Issues created after the date."
    createdAfter: Time,
    "Issues created before the date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "Return issues due on or after the given time."
    dueAfter: Time,
    "Return issues due on or before the given time."
    dueBefore: Time,
    """
    IID of the issue. For example, "1".
    """
    iid: String,
    """
    List of IIDs of issues. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Labels applied to the issue."
    labelName: [String],
    "Milestone applied to the issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    """
    Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.
    """
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Issues the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after the date."
    updatedAfter: Time,
    "Issues updated before the date."
    updatedBefore: Time,
    "Sort issues by the criteria."
    sort: IssueSort = created_desc,
    "Current state of the issue."
    state: IssuableState,
    "Release tag associated with the issue's milestone."
    releaseTag: [String!],
    "Filter issues by release tag ID wildcard."
    releaseTagWildcardId: ReleaseTagWildcardId
  ): Issue
  "Counts of issues by status for the project."
  issueStatusCounts(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    """
    ID of a user assigned to the issues. Wildcard values "NONE" and "ANY" are supported.
    """
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Issues closed after the date."
    closedAfter: Time,
    "Issues closed before the date."
    closedBefore: Time,
    """
    Filter for confidential issues. If "false", excludes confidential issues. If "true", returns only confidential issues.
    """
    confidential: Boolean,
    "Issues created after the date."
    createdAfter: Time,
    "Issues created before the date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "Return issues due on or after the given time."
    dueAfter: Time,
    "Return issues due on or before the given time."
    dueBefore: Time,
    """
    IID of the issue. For example, "1".
    """
    iid: String,
    """
    List of IIDs of issues. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Labels applied to the issue."
    labelName: [String],
    "Milestone applied to the issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    """
    Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.
    """
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Issues the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after the date."
    updatedAfter: Time,
    "Issues updated before the date."
    updatedBefore: Time,
    "Release tag associated with the issue's milestone."
    releaseTag: [String!],
    "Filter issues by release tag ID wildcard."
    releaseTagWildcardId: ReleaseTagWildcardId
  ): IssueStatusCountsType
  "Issues of the project."
  issues(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    """
    ID of a user assigned to the issues. Wildcard values "NONE" and "ANY" are supported.
    """
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Issues closed after the date."
    closedAfter: Time,
    "Issues closed before the date."
    closedBefore: Time,
    """
    Filter for confidential issues. If "false", excludes confidential issues. If "true", returns only confidential issues.
    """
    confidential: Boolean,
    "Issues created after the date."
    createdAfter: Time,
    "Issues created before the date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "Return issues due on or after the given time."
    dueAfter: Time,
    "Return issues due on or before the given time."
    dueBefore: Time,
    """
    IID of the issue. For example, "1".
    """
    iid: String,
    """
    List of IIDs of issues. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Labels applied to the issue."
    labelName: [String],
    "Milestone applied to the issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    """
    Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.
    """
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Issues the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after the date."
    updatedAfter: Time,
    "Issues updated before the date."
    updatedBefore: Time,
    "Sort issues by the criteria."
    sort: IssueSort = created_desc,
    "Current state of the issue."
    state: IssuableState,
    "Release tag associated with the issue's milestone."
    releaseTag: [String!],
    "Filter issues by release tag ID wildcard."
    releaseTagWildcardId: ReleaseTagWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssueConnection
  "Access level required for issues access."
  issuesAccessLevel: ProjectFeatureAccess
  "Indicates if Issues are enabled for the current user"
  issuesEnabled: Boolean
  "Status of Jira import background job of the project."
  jiraImportStatus: String
  "Jira imports into the project."
  jiraImports(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): JiraImportConnection
  "One job belonging to the project, selected by ID."
  job(
    "ID of the job."
    id: JobID!
  ): CiJob
  "Jobs of a project. This field can only be resolved for one project in any single request."
  jobs(
    "Filter jobs by status."
    statuses: [CiJobStatus!],
    "Filter by artifacts presence."
    withArtifacts: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Indicates if CI/CD pipeline jobs are enabled for the current user."
  jobsEnabled: Boolean
  "Label available on the project."
  label(
    "Title of the label."
    title: String!
  ): Label
  "Labels available on this project."
  labels(
    "Exact match on title. Cannot be used with `searchTerm`. `searchIn` will be ignored if `title` argument is provided."
    title: String,
    "Search term to find labels with."
    searchTerm: String,
    "Specify which fields to search in. Ignored if using `title`."
    searchIn: [LabelSearchFieldList!]! = [TITLE, DESCRIPTION],
    "Include labels from ancestor groups."
    includeAncestorGroups: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Programming languages used in the project."
  languages: [RepositoryLanguage!]
  "Timestamp of the project last activity."
  lastActivityAt: Time
  "Indicates if the project has Large File Storage (LFS) enabled."
  lfsEnabled: Boolean
  "Date when project was scheduled to be deleted. Introduced in GitLab 16.10: **Status**: Experiment."
  markedForDeletionOn: Time @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.10.")
  "Maximum access level of the current user in the project."
  maxAccessLevel: AccessLevel!
  "Template used to create merge commit message in merge requests."
  mergeCommitTemplate: String
  "A single merge request of the project."
  mergeRequest(
    "IID of the merge request, for example `1`."
    iid: String!
  ): MergeRequest
  "Merge requests of the project."
  mergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Access level required for merge requests access."
  mergeRequestsAccessLevel: ProjectFeatureAccess
  "Indicates if Merge requests are enabled for the current user"
  mergeRequestsEnabled: Boolean
  "Indicates if no merge commits should be created and all merges should instead be fast-forwarded, which means that merging is only allowed if the branch could be fast-forwarded."
  mergeRequestsFfOnlyEnabled: Boolean
  "Milestones of the project."
  milestones(
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    """
    Array of global milestone IDs, e.g., `"gid://gitlab/Milestone/1"`.
    """
    ids: [ID!],
    "Filter milestones by state."
    state: MilestoneStateEnum,
    "Title of the milestone."
    title: String,
    "Search string for the title."
    searchTitle: String,
    "Date the milestone contains."
    containingDate: Time,
    "Sort milestones by the criteria."
    sort: MilestoneSort = DUE_DATE_ASC,
    "Also return milestones in the project's parent group and its ancestors."
    includeAncestors: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MilestoneConnection
  "Find machine learning experiments"
  mlExperiments(
    "Search for names that include the string."
    name: String,
    "Ordering column. Default is created_at."
    orderBy: MlModelsOrderBy,
    "Ordering direction. Default is desc."
    sort: SortDirectionEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlExperimentConnection
  "Finds machine learning models Introduced in GitLab 16.8: **Status**: Experiment."
  mlModels(
    "Search for names that include the string."
    name: String,
    "Ordering column. Default is created_at."
    orderBy: MlModelsOrderBy,
    "Ordering column. Default is desc."
    sort: SortDirectionEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlModelConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.8.")
  "Name of the project without the namespace."
  name: String!
  "Name of the project including the namespace."
  nameWithNamespace: String!
  "Namespace of the project."
  namespace: Namespace
  "Environments for this project with nested folders, can only be resolved for one project in any single request"
  nestedEnvironments(
    "Name of the environment."
    name: String,
    "Search query for environment name."
    search: String,
    "States of environments that should be included in result."
    states: [String!],
    "Search query for environment type."
    type: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NestedEnvironmentConnection
  "Indicates if merge requests of the project can only be merged when all the discussions are resolved."
  onlyAllowMergeIfAllDiscussionsAreResolved: Boolean
  "Indicates if merge requests of the project can only be merged with successful jobs."
  onlyAllowMergeIfPipelineSucceeds: Boolean
  "Number of open issues for the project."
  openIssuesCount: Int
  "Number of open merge requests for the project."
  openMergeRequestsCount: Int
  "Path for editing project at the organization level. Introduced in GitLab 16.11: **Status**: Experiment."
  organizationEditPath: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Packages of the project."
  packages(
    "Sort packages by the criteria."
    sort: PackageSort = CREATED_DESC,
    "Search a package by name."
    packageName: String = null,
    "Filter a package by type."
    packageType: PackageTypeEnum = null,
    """
    Filter a package by version. If used in combination with `include_versionless`,
              then no versionless packages are returned.
    """
    packageVersion: String = null,
    "Filter a package by status."
    status: PackageStatus = null,
    "Include versionless packages."
    includeVersionless: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageConnection
  "Packages cleanup policy for the project."
  packagesCleanupPolicy: PackagesCleanupPolicy
  "Packages protection rules for the project. Introduced in GitLab 16.6: **Status**: Experiment."
  packagesProtectionRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackagesProtectionRuleConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "List of the project's Pages Deployments."
  pagesDeployments(
    "Filter by active or inactive state."
    active: Boolean,
    "Sort results."
    sort: Sort,
    """
    Filter deployments that are
    versioned or unversioned.
    """
    versioned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PagesDeploymentConnection
  "Project's Pages site redirects unsecured connections to HTTPS."
  pagesForceHttps: Boolean!
  "Project's Pages site uses a unique subdomain."
  pagesUseUniqueDomain: Boolean!
  "Path of the project."
  path: String!
  "Date when project will be deleted if delayed project deletion is enabled. Introduced in GitLab 16.11: **Status**: Experiment."
  permanentDeletionDate: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Pipeline of the project. If no arguments are provided, returns the latest pipeline for the head commit on the default branch"
  pipeline(
    """
    Global ID of the Pipeline. For example, "gid://gitlab/Ci::Pipeline/314".
    """
    id: CiPipelineID,
    """
    IID of the Pipeline. For example, "1".
    """
    iid: ID,
    """
    SHA of the Pipeline. For example, "dyd0f15ay83993f5ab66k927w28673882x99100b".
    """
    sha: String
  ): Pipeline
  "Pipeline analytics."
  pipelineAnalytics: PipelineAnalytics
  "Pipeline counts of the project."
  pipelineCounts(
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by the SHA of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String
  ): PipelineCounts
  "Pipeline schedules of the project. This field can only be resolved for one project per request."
  pipelineSchedules(
    "Filter pipeline schedules by active status."
    status: PipelineScheduleStatus,
    "Filter pipeline schedules by IDs."
    ids: [ID!] = null,
    "List pipeline schedules by sort order. Default is `id_desc`."
    sort: PipelineScheduleSort = ID_DESC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineScheduleConnection
  "List of pipeline trigger tokens. Introduced in GitLab 16.3: **Status**: Experiment."
  pipelineTriggers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineTriggerConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Pipelines of the project."
  pipelines(
    "Filter pipelines by their status."
    status: PipelineStatusEnum,
    "Filter pipelines by scope."
    scope: PipelineScopeEnum,
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by the sha of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String,
    "Pipelines updated after the date."
    updatedAfter: Time,
    "Pipelines updated before the date."
    updatedBefore: Time,
    "Filter pipelines by the user that triggered the pipeline."
    username: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Indicates if a link to create or view a merge request should display after a push to Git repositories of the project from the command line."
  printingMergeRequestLinkEnabled: Boolean
  "Members of the project."
  projectMembers(
    "Search query."
    search: String,
    "sort query."
    sort: MemberSort,
    "Filter members by the given member relations."
    relations: [ProjectMemberRelation!] = [DIRECT, INHERITED],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MemberInterfaceConnection
  "Plan limits for the current project. Introduced in GitLab 16.9: **Status**: Experiment."
  projectPlanLimits: ProjectPlanLimits @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.9.")
  "List of unprotected branches, ignoring any wildcard branch rules. Introduced in GitLab 16.9: **Status**: Experiment."
  protectableBranches: [String!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.9.")
  "Indicates if there is public access to pipelines and job details of the project, including output logs and artifacts."
  publicJobs: Boolean
  "List of recently visited boards of the project. Maximum size is 4."
  recentIssueBoards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "A single release of the project."
  release(
    "Name of the tag associated to the release."
    tagName: String!
  ): Release
  "Releases of the project."
  releases(
    "Sort releases by given criteria."
    sort: ReleaseSort = RELEASED_AT_DESC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseConnection
  "Indicates if `Delete source branch` option should be enabled by default for all new merge requests of the project."
  removeSourceBranchAfterMerge: Boolean
  "Git repository of the project."
  repository: Repository
  "Indicates if users can request member access to the project."
  requestAccessEnabled: Boolean
  "Find runners visible to the current user."
  runners(
    "Filter runners by `paused` (true) or `active` (false) status."
    paused: Boolean,
    "Filter runners by status."
    status: CiRunnerStatus,
    "Filter runners by type."
    type: CiRunnerType,
    "Filter by tags associated with the runner (comma-separated or array)."
    tagList: [String!],
    "Filter by full token or partial text in description field."
    search: String,
    "Sort order of results."
    sort: CiRunnerSort,
    "Filter by upgrade status."
    upgradeStatus: CiRunnerUpgradeStatus,
    "Filter runners by creator ID."
    creatorId: UserID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiRunnerConnection
  "SAST CI configuration for the project."
  sastCiConfiguration: SastCiConfiguration
  "Detailed version of a Sentry error on the project."
  sentryDetailedError(
    "ID of the Sentry issue."
    id: GitlabErrorTrackingDetailedErrorID!
  ): SentryDetailedError
  "Paginated collection of Sentry errors on the project."
  sentryErrors: SentryErrorCollection
  "E-mail address of the Service Desk."
  serviceDeskAddress: String
  "Indicates if the project has Service Desk enabled."
  serviceDeskEnabled: Boolean
  "Project services. Deprecated in GitLab 15.9: A `Project.integrations` field is proposed instead in [issue 389904](https://gitlab.com/gitlab-org/gitlab/-/issues/389904)."
  services(
    "Indicates if the integration is active."
    active: Boolean,
    "Type of integration."
    type: ServiceType,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ServiceConnection @deprecated(reason: "A `Project.integrations` field is proposed instead in [issue 389904](https://gitlab.com/gitlab-org/gitlab/-/issues/389904). Deprecated in GitLab 15.9.")
  "Indicates if shared runners are enabled for the project."
  sharedRunnersEnabled: Boolean
  "Snippets of the project."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Indicates if Snippets are enabled for the current user"
  snippetsEnabled: Boolean
  "Template used to create squash commit message in merge requests."
  squashCommitTemplate: String
  "Indicates if `squashReadOnly` is enabled."
  squashReadOnly: Boolean!
  "URL to connect to the project via SSH."
  sshUrlToRepo: String
  "Number of times the project has been starred."
  starCount: Int!
  "Statistics of the project."
  statistics: ProjectStatistics
  "Redirects for Statistics of the project."
  statisticsDetailsPaths: ProjectStatisticsRedirect
  "Commit message used to apply merge request suggestions."
  suggestionCommitMessage: String
  "List of project topics (not Git tags). Deprecated in GitLab 13.12: Use `topics`."
  tagList: String @deprecated(reason: "Use `topics`. Deprecated in GitLab 13.12.")
  "Find a single Terraform state by name."
  terraformState(
    "Name of the Terraform state."
    name: String!
  ): TerraformState
  "Terraform states associated with the project."
  terraformStates(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TerraformStateConnection
  "Timelog categories for the project. Introduced in GitLab 15.3: **Status**: Experiment."
  timelogCategories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimeTrackingTimelogCategoryConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.3.")
  "Time logged on issues and merge requests in the project."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "List of project topics."
  topics: [String!]
  "Timestamp of when the project was last updated."
  updatedAt: Time
  "Authorized cluster agents for the project through user_access keyword."
  userAccessAuthorizedAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentAuthorizationUserAccessConnection
  "Permissions for the current user on the resource"
  userPermissions: ProjectPermissions!
  "Value streams available to the project."
  valueStreams(
    "Value stream id."
    id: ID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ValueStreamConnection
  "Visibility of the project."
  visibility: String
  "Visible forks of the project. Introduced in GitLab 15.10: **Status**: Experiment."
  visibleForks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Minimum access level."
    minimumAccessLevel: AccessLevelEnum
  ): ProjectConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Web URL of the project."
  webUrl: String
  "Indicates if Wikis are enabled for the current user"
  wikiEnabled: Boolean
  "Counts of work items by state for the project. Introduced in GitLab 16.7: **Status**: Experiment."
  workItemStateCounts(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Filter work items by author username."
    authorUsername: String,
    "Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items."
    confidential: Boolean,
    "Usernames of users assigned to the work item."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with `assigneeUsernames`."
    assigneeWildcardId: AssigneeWildcardId,
    "Labels applied to the work item."
    labelName: [String!],
    "Milestone applied to the work item."
    milestoneTitle: [String!],
    "Filter by milestone ID wildcard. Incompatible with `milestoneTitle`."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported."
    myReactionEmoji: String,
    """
    List of IIDs of work items. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Current state of the work item."
    state: IssuableState,
    "Filter work items by the given work item types."
    types: [IssueType!],
    "Work items created before the timestamp."
    createdBefore: Time,
    "Work items created after the timestamp."
    createdAfter: Time,
    "Work items updated before the timestamp."
    updatedBefore: Time,
    "Work items updated after the timestamp."
    updatedAfter: Time,
    "Work items due before the timestamp."
    dueBefore: Time,
    "Work items due after the timestamp."
    dueAfter: Time,
    "Work items closed before the date."
    closedBefore: Time,
    "Work items closed after the date."
    closedAfter: Time,
    "Work items the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Negated work item arguments."
    not: NegatedWorkItemFilterInput,
    "List of arguments with inclusive `OR`."
    or: UnionedWorkItemFilterInput,
    """
    IID of the work item. For example, "1".
    """
    iid: String,
    "Sort work items by criteria."
    sort: WorkItemSort = CREATED_DESC
  ): WorkItemStateCountsType @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  "Work item types available to the project."
  workItemTypes(
    "Filter work item types by the given name."
    name: IssueType,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemTypeConnection
  "Work items of the project. Introduced in GitLab 15.1: **Status**: Experiment."
  workItems(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Filter work items by author username."
    authorUsername: String,
    "Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items."
    confidential: Boolean,
    "Usernames of users assigned to the work item."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with `assigneeUsernames`."
    assigneeWildcardId: AssigneeWildcardId,
    "Labels applied to the work item."
    labelName: [String!],
    "Milestone applied to the work item."
    milestoneTitle: [String!],
    "Filter by milestone ID wildcard. Incompatible with `milestoneTitle`."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported."
    myReactionEmoji: String,
    """
    List of IIDs of work items. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Current state of the work item."
    state: IssuableState,
    "Filter work items by the given work item types."
    types: [IssueType!],
    "Work items created before the timestamp."
    createdBefore: Time,
    "Work items created after the timestamp."
    createdAfter: Time,
    "Work items updated before the timestamp."
    updatedBefore: Time,
    "Work items updated after the timestamp."
    updatedAfter: Time,
    "Work items due before the timestamp."
    dueBefore: Time,
    "Work items due after the timestamp."
    dueAfter: Time,
    "Work items closed before the date."
    closedBefore: Time,
    "Work items closed after the date."
    closedAfter: Time,
    "Work items the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Negated work item arguments."
    not: NegatedWorkItemFilterInput,
    "List of arguments with inclusive `OR`."
    or: UnionedWorkItemFilterInput,
    """
    IID of the work item. For example, "1".
    """
    iid: String,
    "Sort work items by criteria."
    sort: WorkItemSort = CREATED_DESC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.1.")
}
type ProjectCiCdSetting {
  "Indicates CI/CD job tokens generated in other projects have restricted access to this project."
  inboundJobTokenScopeEnabled: Boolean
  "Indicates CI/CD job tokens generated in this project have restricted access to other projects."
  jobTokenScopeEnabled: Boolean
  "Whether to keep the latest builds artifacts."
  keepLatestArtifact: Boolean
  "Whether merged results pipelines are enabled."
  mergePipelinesEnabled: Boolean
  "Minimum role required to set variables when creating a pipeline or running a job."
  pipelineVariablesMinimumOverrideRole: String!
  "Project the CI/CD settings belong to."
  project: Project
  "Indicates the ability to push to the original project repository using a job token"
  pushRepositoryForJobTokenAllowed: Boolean
}
"Autogenerated return type of ProjectCiCdSettingsUpdate."
type ProjectCiCdSettingsUpdatePayload {
  "CI/CD settings after mutation."
  ciCdSettings: ProjectCiCdSetting!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"The connection type for Project."
type ProjectConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ProjectEdge]
  "A list of nodes."
  nodes: [Project]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
type ProjectDataTransfer {
  "Data nodes."
  egressNodes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EgressNodeConnection
  "Total egress for that project in that period of time."
  totalEgress: BigInt
}
"An edge in a connection."
type ProjectEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Project
}
"Represents the access level required by the user to access a project feature"
type ProjectFeatureAccess {
  "Integer representation of access level."
  integerValue: Int
  "String representation of access level."
  stringValue: ProjectFeatureAccessLevel
}
"Represents a Project Membership"
type ProjectMember implements MemberInterface {
  "GitLab::Access level."
  accessLevel: AccessLevel
  "Date and time the membership was created."
  createdAt: Time
  "User that authorized membership."
  createdBy: UserCore
  "Date and time the membership expires."
  expiresAt: Time
  "ID of the member."
  id: ID!
  "Find a merge request."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Project that User is a member of."
  project: Project
  "Date and time the membership was last updated."
  updatedAt: Time
  "User that is associated with the member object."
  user: UserCore
  "Permissions for the current user on the resource"
  userPermissions: ProjectPermissions!
}
"Autogenerated return type of ProjectMemberBulkUpdate."
type ProjectMemberBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project members after mutation."
  projectMembers: [ProjectMember!]
}
"The connection type for ProjectMember."
type ProjectMemberConnection {
  "A list of edges."
  edges: [ProjectMemberEdge]
  "A list of nodes."
  nodes: [ProjectMember]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ProjectMemberEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ProjectMember
}
type ProjectPermissions {
  "If `true`, the user can perform `admin_operations` on this resource"
  adminOperations: Boolean!
  "If `true`, the user can perform `admin_project` on this resource"
  adminProject: Boolean!
  "If `true`, the user can perform `admin_remote_mirror` on this resource"
  adminRemoteMirror: Boolean!
  "If `true`, the user can perform `admin_wiki` on this resource"
  adminWiki: Boolean!
  "If `true`, the user can perform `archive_project` on this resource"
  archiveProject: Boolean!
  "If `true`, the user can perform `change_namespace` on this resource"
  changeNamespace: Boolean!
  "If `true`, the user can perform `change_visibility_level` on this resource"
  changeVisibilityLevel: Boolean!
  "If `true`, the user can perform `create_deployment` on this resource"
  createDeployment: Boolean!
  "If `true`, the user can perform `create_design` on this resource"
  createDesign: Boolean!
  "If `true`, the user can perform `create_issue` on this resource"
  createIssue: Boolean!
  "If `true`, the user can perform `create_label` on this resource"
  createLabel: Boolean!
  "If `true`, the user can perform `create_merge_request_from` on this resource"
  createMergeRequestFrom: Boolean!
  "If `true`, the user can perform `create_merge_request_in` on this resource"
  createMergeRequestIn: Boolean!
  "If `true`, the user can perform `create_pages` on this resource"
  createPages: Boolean!
  "If `true`, the user can perform `create_pipeline` on this resource"
  createPipeline: Boolean!
  "If `true`, the user can perform `create_pipeline_schedule` on this resource"
  createPipelineSchedule: Boolean!
  "If `true`, the user can perform `create_snippet` on this resource"
  createSnippet: Boolean!
  "If `true`, the user can perform `create_wiki` on this resource"
  createWiki: Boolean!
  "If `true`, the user can perform `destroy_design` on this resource"
  destroyDesign: Boolean!
  "If `true`, the user can perform `destroy_pages` on this resource"
  destroyPages: Boolean!
  "If `true`, the user can perform `destroy_wiki` on this resource"
  destroyWiki: Boolean!
  "If `true`, the user can perform `download_code` on this resource"
  downloadCode: Boolean!
  "If `true`, the user can perform `download_wiki_code` on this resource"
  downloadWikiCode: Boolean!
  "If `true`, the user can perform `fork_project` on this resource"
  forkProject: Boolean!
  "If `true`, the user can perform `move_design` on this resource"
  moveDesign: Boolean!
  "If `true`, the user can perform `push_code` on this resource"
  pushCode: Boolean!
  "If `true`, the user can perform `push_to_delete_protected_branch` on this resource"
  pushToDeleteProtectedBranch: Boolean!
  "If `true`, the user can perform `read_commit_status` on this resource"
  readCommitStatus: Boolean!
  "If `true`, the user can perform `read_cycle_analytics` on this resource"
  readCycleAnalytics: Boolean!
  "If `true`, the user can perform `read_design` on this resource"
  readDesign: Boolean!
  "If `true`, the user can perform `read_environment` on this resource"
  readEnvironment: Boolean!
  "If `true`, the user can perform `read_merge_request` on this resource"
  readMergeRequest: Boolean!
  "If `true`, the user can perform `read_pages_content` on this resource"
  readPagesContent: Boolean!
  "If `true`, the user can perform `read_project` on this resource"
  readProject: Boolean!
  "If `true`, the user can perform `read_project_member` on this resource"
  readProjectMember: Boolean!
  "If `true`, the user can perform `read_wiki` on this resource"
  readWiki: Boolean!
  "If `true`, the user can perform `remove_fork_project` on this resource"
  removeForkProject: Boolean!
  "If `true`, the user can perform `remove_pages` on this resource"
  removePages: Boolean!
  "If `true`, the user can perform `remove_project` on this resource"
  removeProject: Boolean!
  "If `true`, the user can perform `rename_project` on this resource"
  renameProject: Boolean!
  "If `true`, the user can perform `request_access` on this resource"
  requestAccess: Boolean!
  "If `true`, the user can perform `update_design` on this resource"
  updateDesign: Boolean!
  "If `true`, the user can perform `update_pages` on this resource"
  updatePages: Boolean!
  "If `true`, the user can perform `update_wiki` on this resource"
  updateWiki: Boolean!
  "If `true`, the user can perform `upload_file` on this resource"
  uploadFile: Boolean!
  "If `true`, the user can perform `view_edit_page` on this resource"
  viewEditPage: Boolean!
}
"Plan limits for the current project."
type ProjectPlanLimits {
  "Maximum number of pipeline schedules allowed per project."
  ciPipelineSchedules: Int
}
type ProjectStatistics {
  "Build artifacts size of the project in bytes."
  buildArtifactsSize: Float!
  "Commit count of the project."
  commitCount: Float!
  "Container registry size of the project in bytes."
  containerRegistrySize: Float
  "Large File Storage (LFS) object size of the project in bytes."
  lfsObjectsSize: Float!
  "Packages size of the project in bytes."
  packagesSize: Float!
  "CI Pipeline artifacts size in bytes."
  pipelineArtifactsSize: Float
  "Repository size of the project in bytes."
  repositorySize: Float!
  "Snippets size of the project in bytes."
  snippetsSize: Float
  "Storage size of the project in bytes."
  storageSize: Float!
  "Uploads size of the project in bytes."
  uploadsSize: Float
  "Wiki size of the project in bytes."
  wikiSize: Float
}
type ProjectStatisticsRedirect {
  "Redirection Route for job_artifacts."
  buildArtifacts: String!
  "Redirection Route for container_registry."
  containerRegistry: String!
  "Redirection Route for packages."
  packages: String!
  "Redirection Route for repository."
  repository: String!
  "Redirection Route for snippets."
  snippets: String!
  "Redirection Route for wiki."
  wiki: String!
}
"Autogenerated return type of ProjectSyncFork."
type ProjectSyncForkPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Updated fork details."
  details: ForkDetails
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Exposes aggregated value stream flow metrics"
type ProjectValueStreamAnalyticsFlowMetrics {
  "Number of production deployments in the given period."
  deploymentCount(
    "Timestamp marking the start date and time."
    from: Time!,
    "Timestamp marking the end date and time."
    to: Time!
  ): ValueStreamAnalyticsMetric
  "Number of issues opened in the given period."
  issueCount(
    "Timestamp marking the start date and time."
    from: Time!,
    "Timestamp marking the end date and time."
    to: Time!,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Labels applied to the issue."
    labelNames: [String!]
  ): ValueStreamAnalyticsMetric
}
"The alert condition for Prometheus"
type PrometheusAlert {
  "Human-readable text of the alert condition."
  humanizedText: String!
  "ID of the alert condition."
  id: ID!
}
"Autogenerated return type of PrometheusIntegrationCreate."
type PrometheusIntegrationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Newly created integration."
  integration: AlertManagementPrometheusIntegration
}
"Autogenerated return type of PrometheusIntegrationResetToken."
type PrometheusIntegrationResetTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Newly created integration."
  integration: AlertManagementPrometheusIntegration
}
"Autogenerated return type of PrometheusIntegrationUpdate."
type PrometheusIntegrationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Newly created integration."
  integration: AlertManagementPrometheusIntegration
}
"Defines which user roles, users, or groups can push to a protected branch."
type PushAccessLevel {
  "GitLab::Access level."
  accessLevel: Int!
  "Human readable representation for the access level."
  accessLevelDescription: String!
  "Deploy key assigned to the access level."
  deployKey: AccessLevelDeployKey
}
"The connection type for PushAccessLevel."
type PushAccessLevelConnection {
  "A list of edges."
  edges: [PushAccessLevelEdge]
  "A list of nodes."
  nodes: [PushAccessLevel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type PushAccessLevelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PushAccessLevel
}
"Pypi metadata"
type PypiMetadata {
  "Author email address(es) in RFC-822 format."
  authorEmail: String
  "Longer description that can run to several paragraphs."
  description: String
  "Markup syntax used in the description field."
  descriptionContentType: String
  "ID of the metadatum."
  id: PackagesPypiMetadatumID!
  "List of keywords, separated by commas."
  keywords: String
  "Metadata version."
  metadataVersion: String
  "Required Python version of the Pypi package."
  requiredPython: String
  "One-line summary of the description."
  summary: String
}
type Query {
  "Find an abuse report. Introduced in GitLab 16.3: **Status**: Experiment."
  abuseReport(
    "ID of the abuse report."
    id: AbuseReportID!
  ): AbuseReport @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Abuse report labels. Introduced in GitLab 16.3: **Status**: Experiment."
  abuseReportLabels(
    "Search term to find labels with."
    searchTerm: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AbuseReportLabelConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Definitions for all audit events available on the instance."
  auditEventDefinitions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AuditEventDefinitionConnection!
  "Find an issue board list."
  boardList(
    "Global ID of the list."
    id: ListID!,
    "Filters applied when getting issue metadata in the board list."
    issueFilters: BoardIssueInput
  ): BoardList
  "CI related settings that apply to the entire instance."
  ciApplicationSettings: CiApplicationSettings
  "A single CI/CD Catalog resource visible to an authorized user Introduced in GitLab 16.1: **Status**: Experiment."
  ciCatalogResource(
    "CI/CD Catalog resource global ID."
    id: CiCatalogResourceID,
    "CI/CD Catalog resource full path."
    fullPath: ID
  ): CiCatalogResource @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.1.")
  "All CI/CD Catalog resources under a common namespace, visible to an authorized user Introduced in GitLab 15.11: **Status**: Experiment."
  ciCatalogResources(
    "Scope of the returned catalog resources."
    scope: CiCatalogResourceScope = ALL,
    "Search term to filter the catalog resources by name or description."
    search: String,
    "Sort catalog resources by given criteria."
    sort: CiCatalogResourceSort,
    "Filter catalog resources by verification level."
    verificationLevel: CiCatalogResourceVerificationLevel,
    "Filter catalog resources by project topic names."
    topics: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiCatalogResourceConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.11.")
  """
  Linted and processed contents of a CI config.
  Should not be requested more than once per request.
  """
  ciConfig(
    "Project of the CI config."
    projectPath: ID!,
    "Sha for the pipeline."
    sha: String,
    "Contents of `.gitlab-ci.yml`."
    content: String!,
    "Run pipeline creation simulation, or only do static check."
    dryRun: Boolean
  ): CiConfig
  "Stage belonging to a CI pipeline."
  ciPipelineStage(
    "Global ID of the CI stage."
    id: CiStageID!
  ): CiStage
  "List of the instance's CI/CD variables."
  ciVariables(
    "Sort order of results."
    sort: CiVariableSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiInstanceVariableConnection
  "Find a container repository."
  containerRepository(
    "Global ID of the container repository."
    id: ContainerRepositoryID!
  ): ContainerRepositoryDetails
  "Get information about current user."
  currentUser: CurrentUser
  "Fields related to design management."
  designManagement: DesignManagement!
  "Testing endpoint to validate the API with"
  echo(
    "Text to echo back."
    text: String!
  ): String!
  "Check if a feature flag is enabled Deprecated in GitLab 17.4: Replaced with metadata.featureFlags."
  featureFlagEnabled(
    "Name of the feature flag."
    name: String!
  ): Boolean! @deprecated(reason: "Replaced with metadata.featureFlags. Deprecated in GitLab 17.4.")
  "A user's frecently visited groups"
  frecentGroups: [Group!]
  "A user's frecently visited projects"
  frecentProjects: [Project!]
  "Whether Gitpod is enabled in application settings."
  gitpodEnabled: Boolean
  "Find a group."
  group(
    "Full path of the group. For example, `gitlab-org/gitlab-foss`."
    fullPath: ID!
  ): Group
  "Find groups."
  groups(
    "Filter groups by IDs."
    ids: [ID!],
    "Only include top-level groups."
    topLevelOnly: Boolean = false,
    "Only include groups where the current user has an owner role."
    ownedOnly: Boolean = false,
    "Search query for group name or group full path."
    search: String,
    "Sort order of results. Format: `<field_name>_<sort_direction>`, for example: `id_desc` or `name_asc`"
    sort: String = "name_asc",
    "Full path of the parent group."
    parentPath: ID,
    """
    When `true`, returns all accessible groups. When `false`, returns only groups where the user is a member.
    Unauthenticated requests always return all public groups. The `owned_only` argument takes precedence.
    """
    allAvailable: Boolean = true,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  integrationExclusions(
    "Type of integration."
    integrationName: IntegrationType!,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IntegrationExclusionConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  "Find an issue."
  issue(
    "Global ID of the issue."
    id: IssueID!
  ): Issue
  "Find issues visible to the current user. At least one filter must be provided. Introduced in GitLab 15.6: **Status**: Experiment."
  issues(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    """
    ID of a user assigned to the issues. Wildcard values "NONE" and "ANY" are supported.
    """
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Issues closed after the date."
    closedAfter: Time,
    "Issues closed before the date."
    closedBefore: Time,
    """
    Filter for confidential issues. If "false", excludes confidential issues. If "true", returns only confidential issues.
    """
    confidential: Boolean,
    "Issues created after the date."
    createdAfter: Time,
    "Issues created before the date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "Return issues due on or after the given time."
    dueAfter: Time,
    "Return issues due on or before the given time."
    dueBefore: Time,
    """
    IID of the issue. For example, "1".
    """
    iid: String,
    """
    List of IIDs of issues. For example, `["1", "2"]`.
    """
    iids: [String!],
    "Labels applied to the issue."
    labelName: [String],
    "Milestone applied to the issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    """
    Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.
    """
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Issues the current user is subscribed to."
    subscribed: SubscriptionStatus,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after the date."
    updatedAfter: Time,
    "Issues updated before the date."
    updatedBefore: Time,
    "Sort issues by the criteria."
    sort: IssueSort = created_desc,
    "Whether to include issues from archived projects. Defaults to `false`."
    includeArchived: Boolean = false,
    "Current state of the issue."
    state: IssuableState,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssueConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.6.")
  "All jobs on this GitLab instance. Returns an empty result for users without administrator access."
  jobs(
    "Filter jobs by status."
    statuses: [CiJobStatus!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Find a merge request."
  mergeRequest(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): MergeRequest
  "Metadata about GitLab."
  metadata: Metadata
  "Find a milestone."
  milestone(
    "Find a milestone by its ID."
    id: MilestoneID!
  ): Milestone
  "Find a machine learning experiment."
  mlExperiment(
    "ID of the experiment."
    id: MlExperimentID!
  ): MlExperiment
  "Find machine learning models. Introduced in GitLab 16.7: **Status**: Experiment."
  mlModel(
    "ID of the model."
    id: MlModelID!
  ): MlModel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
  "Find a namespace."
  namespace(
    "Full path of the namespace. For example, `gitlab-org/gitlab-foss`."
    fullPath: ID!
  ): Namespace
  "Find a note. Introduced in GitLab 15.9: **Status**: Experiment."
  note(
    "Global ID of the note."
    id: NoteID!
  ): Note @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  "Find an organization. Introduced in GitLab 16.4: **Status**: Experiment."
  organization(
    "ID of the organization."
    id: OrganizationsOrganizationID!
  ): Organization @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.4.")
  "List organizations. Introduced in GitLab 16.8: **Status**: Experiment."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.8.")
  "Find a package. This field can only be resolved for one query in any single request. Returns `null` if a package has no `default` status."
  package(
    "Global ID of the package."
    id: PackagesPackageID!
  ): PackageDetailsType
  "Find a project."
  project(
    "Full path of the project. For example, `gitlab-org/gitlab-foss`."
    fullPath: ID!
  ): Project
  "Find projects visible to the current user."
  projects(
    "Return only projects that the current user is a member of."
    membership: Boolean,
    "Search query, which can be for the project name, a path, or a description."
    search: String,
    "Include namespace in project search."
    searchNamespaces: Boolean,
    "Filter projects by topics."
    topics: [String!],
    "Return only personal projects."
    personal: Boolean,
    "Sort order of results. Format: `<field_name>_<sort_direction>`, for example: `id_desc` or `name_asc`"
    sort: String = "id_desc",
    "Filter projects by IDs."
    ids: [ID!],
    "Filter projects by full paths. You cannot provide more than 50 full paths."
    fullPaths: [String!],
    "Return only projects with issues enabled."
    withIssuesEnabled: Boolean,
    "Return only projects with merge requests enabled."
    withMergeRequestsEnabled: Boolean,
    "Filter projects by archived status."
    archived: ProjectArchived,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Return only projects that are trending."
    trending: Boolean,
    "Exclude projects that are marked for deletion."
    notAimedForDeletion: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Information about the complexity of the GraphQL query."
  queryComplexity: QueryComplexity
  "Find a runner."
  runner(
    "Runner ID."
    id: CiRunnerID!
  ): CiRunner
  "Supported runner platforms. Deprecated in GitLab 15.9: No longer used, use gitlab-runner documentation to learn about supported platforms."
  runnerPlatforms(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): RunnerPlatformConnection @deprecated(reason: "No longer used, use gitlab-runner documentation to learn about supported platforms. Deprecated in GitLab 15.9.")
  "Runner setup instructions. Deprecated in GitLab 15.9: No longer used, use gitlab-runner documentation to learn about runner registration commands."
  runnerSetup(
    "Platform to generate the instructions for."
    platform: String!,
    "Architecture to generate the instructions for."
    architecture: String!
  ): RunnerSetup @deprecated(reason: "No longer used, use gitlab-runner documentation to learn about runner registration commands. Deprecated in GitLab 15.9.")
  "Get all runners in the GitLab instance (project and shared). Access is restricted to users with administrator access."
  runners(
    "Filter runners by `paused` (true) or `active` (false) status."
    paused: Boolean,
    "Filter runners by status."
    status: CiRunnerStatus,
    "Filter runners by type."
    type: CiRunnerType,
    "Filter by tags associated with the runner (comma-separated or array)."
    tagList: [String!],
    "Filter by full token or partial text in description field."
    search: String,
    "Sort order of results."
    sort: CiRunnerSort,
    "Filter by upgrade status."
    upgradeStatus: CiRunnerUpgradeStatus,
    "Filter runners by creator ID."
    creatorId: UserID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiRunnerConnection
  "Find Snippets visible to the current user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "ID of an author."
    authorId: UserID,
    "ID of a project."
    projectId: ProjectID,
    "Type of snippet."
    type: TypeEnum,
    "Explore personal snippets."
    explore: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Find a synthetic note Introduced in GitLab 15.9: **Status**: Experiment."
  syntheticNote(
    "Global ID of the note."
    sha: String!,
    "Global ID of the resource to search synthetic note on."
    noteableId: NoteableID!
  ): Note @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  "Find timelogs visible to the current user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "Retrieve a single to-do item"
  todo(
    "ID of the to-do item."
    id: TodoID!
  ): Todo
  "Find project topics."
  topics(
    "Search query for topic name."
    search: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TopicConnection
  "Get statistics on the instance."
  usageTrendsMeasurements(
    "Type of measurement or statistics to retrieve."
    identifier: MeasurementIdentifier!,
    "Measurement recorded after the date."
    recordedAfter: Time,
    "Measurement recorded before the date."
    recordedBefore: Time,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UsageTrendsMeasurementConnection
  "Find a user."
  user(
    "ID of the User."
    id: UserID,
    "Username of the User."
    username: String
  ): UserCore
  "Find users."
  users(
    "List of user Global IDs."
    ids: [ID!],
    "List of usernames."
    usernames: [String!],
    "Sort users by the criteria."
    sort: Sort = created_desc,
    "Query to search users by name, username, or primary email."
    search: String,
    "Return only admin users."
    admins: Boolean = false,
    "Filter by active users. When true, returns active users. When false, returns non-active users."
    active: Boolean,
    "Filter by regular users. When true, returns only users that are not bot or internal users. When false, returns only users that are bot or internal users."
    humans: Boolean,
    "Return users member of a given group."
    groupId: GroupID,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Find a wiki page. Introduced in GitLab 17.6: **Status**: Experiment."
  wikiPage(
    "Wiki page slug."
    slug: String,
    "Wiki page project ID."
    projectId: ProjectID,
    "Wiki page namespace ID."
    namespaceId: NamespaceID
  ): WikiPage @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Find a work item. Introduced in GitLab 15.1: **Status**: Experiment."
  workItem(
    "Global ID of the work item."
    id: WorkItemID!
  ): WorkItem @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.1.")
  "Find a work item description template. Introduced in GitLab 17.9: **Status**: Experiment."
  workItemDescriptionTemplateContent(
    "Input for fetching a specific Descriptiontemplate."
    templateContentInput: WorkItemDescriptionTemplateContentInput!
  ): WorkItemDescriptionTemplate @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Find work items by their reference. Introduced in GitLab 16.7: **Status**: Experiment."
  workItemsByReference(
    "Full path of the context namespace (project or group)."
    contextNamespacePath: ID,
    "Work item references. Can be either a short reference or URL."
    refs: [String!]!,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
}
type QueryComplexity {
  "GraphQL query complexity limit."
  limit: Int
  "GraphQL query complexity score."
  score: Int
}
type QuickActionsStatus {
  "Quick action command names."
  commandNames: [String!]
  "Returns true if only quick action commands were in the note."
  commandsOnly: Boolean
  "Error messages from quick actions that failed to apply."
  errorMessages: [String!]
  "Response messages from quick actions."
  messages: [String!]
}
"Recent failure history of a test case."
type RecentFailures {
  "Name of the base branch of the project."
  baseBranch: String
  "Number of times the test case has failed in the past 14 days."
  count: Int
}
"Represents a release"
type Release {
  "Assets of the release."
  assets: ReleaseAssets
  "User that created the release."
  author: UserCore
  "Commit associated with the release."
  commit: Commit
  "Timestamp of when the release was created."
  createdAt: Time
  """
  Description (also known as "release notes") of the release.
  """
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Evidence for the release."
  evidences(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseEvidenceConnection
  "Indicates the release is a historical release."
  historicalRelease: Boolean
  "Global ID of the release."
  id: ReleaseID!
  "Links of the release."
  links: ReleaseLinks
  "Milestones associated to the release."
  milestones(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MilestoneConnection
  "Name of the release."
  name: String
  "Timestamp of when the release was released."
  releasedAt: Time
  "Name of the tag associated with the release."
  tagName: String
  "Relative web path to the tag associated with the release."
  tagPath: String
  "Indicates the release is an upcoming release."
  upcomingRelease: Boolean
}
"Represents an asset link associated with a release"
type ReleaseAssetLink {
  "Relative path for the direct asset link."
  directAssetPath: String
  "Direct asset URL of the link."
  directAssetUrl: String
  "ID of the link."
  id: ID!
  "Type of the link: `other`, `runbook`, `image`, `package`; defaults to `other`."
  linkType: ReleaseAssetLinkType
  "Name of the link."
  name: String
  "URL of the link."
  url: String
}
"The connection type for ReleaseAssetLink."
type ReleaseAssetLinkConnection {
  "A list of edges."
  edges: [ReleaseAssetLinkEdge]
  "A list of nodes."
  nodes: [ReleaseAssetLink]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of ReleaseAssetLinkCreate."
type ReleaseAssetLinkCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Asset link after mutation."
  link: ReleaseAssetLink
}
"Autogenerated return type of ReleaseAssetLinkDelete."
type ReleaseAssetLinkDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted release asset link."
  link: ReleaseAssetLink
}
"An edge in a connection."
type ReleaseAssetLinkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ReleaseAssetLink
}
"Autogenerated return type of ReleaseAssetLinkUpdate."
type ReleaseAssetLinkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Asset link after mutation."
  link: ReleaseAssetLink
}
"A container for all assets associated with a release"
type ReleaseAssets {
  "Number of assets of the release."
  count: Int
  "Asset links of the release."
  links(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseAssetLinkConnection
  "Sources of the release."
  sources(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseSourceConnection
}
"The connection type for Release."
type ReleaseConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ReleaseEdge]
  "A list of nodes."
  nodes: [Release]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of ReleaseCreate."
type ReleaseCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Release after mutation."
  release: Release
}
"Autogenerated return type of ReleaseDelete."
type ReleaseDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted release."
  release: Release
}
"An edge in a connection."
type ReleaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Release
}
"Evidence for a release"
type ReleaseEvidence {
  "Timestamp when the evidence was collected."
  collectedAt: Time
  "URL from where the evidence can be downloaded."
  filepath: String
  "ID of the evidence."
  id: ID!
  "SHA1 ID of the evidence hash."
  sha: String
}
"The connection type for ReleaseEvidence."
type ReleaseEvidenceConnection {
  "A list of edges."
  edges: [ReleaseEvidenceEdge]
  "A list of nodes."
  nodes: [ReleaseEvidence]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ReleaseEvidenceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ReleaseEvidence
}
type ReleaseLinks {
  "HTTP URL of the issues page, filtered by the release and `state=closed`."
  closedIssuesUrl: String
  "HTTP URL of the merge request page, filtered by the release and `state=closed`."
  closedMergeRequestsUrl: String
  "HTTP URL of the release's edit page."
  editUrl: String
  "HTTP URL of the merge request page, filtered by the release and `state=merged`."
  mergedMergeRequestsUrl: String
  "HTTP URL of the issues page, filtered by the release and `state=open`."
  openedIssuesUrl: String
  "HTTP URL of the merge request page, filtered by the release and `state=open`."
  openedMergeRequestsUrl: String
  "HTTP URL of the release."
  selfUrl: String
}
"Represents the source code attached to a release in a particular format"
type ReleaseSource {
  "Format of the source."
  format: String
  "Download URL of the source."
  url: String
}
"The connection type for ReleaseSource."
type ReleaseSourceConnection {
  "A list of edges."
  edges: [ReleaseSourceEdge]
  "A list of nodes."
  nodes: [ReleaseSource]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ReleaseSourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ReleaseSource
}
"Autogenerated return type of ReleaseUpdate."
type ReleaseUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Release after mutation."
  release: Release
}
"Autogenerated return type of RepositionImageDiffNote."
type RepositionImageDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
type Repository {
  "Blobs contained within the repository"
  blobs(
    "Array of desired blob paths."
    paths: [String!]!,
    "Commit ref to get the blobs from. Default value is HEAD."
    ref: String = null,
    "Type of ref."
    refType: RefType = null,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): RepositoryBlobConnection
  "Names of branches available in this repository that match the search pattern."
  branchNames(
    "Pattern to search for branch names by."
    searchPattern: String!,
    "Number of branch names to skip."
    offset: Int!,
    "Number of branch names to return."
    limit: Int!
  ): [String!]
  "Commit from the repository."
  commit(
    "Commit reference (SHA, branch name, or tag name)."
    ref: String!
  ): Commit
  "Shows a disk path of the repository."
  diskPath: String
  "Indicates repository has no visible content."
  empty: Boolean!
  "Indicates a corresponding Git repository exists on disk."
  exists: Boolean!
  "The last commit made in the repository for the given path and ref."
  lastCommit(
    "Path to get the last commit for. Default value is the root of the repository."
    path: String,
    "Commit ref to get the last commit for. Default value is HEAD."
    ref: String,
    "Type of ref."
    refType: RefType
  ): Commit
  "Paginated tree of the repository."
  paginatedTree(
    "Path to get the tree for. Default value is the root of the repository."
    path: String = "",
    "Used to get a recursive tree. Default is false."
    recursive: Boolean = false,
    "Commit ref to get the tree for. Default value is HEAD."
    ref: String,
    "Type of ref."
    refType: RefType,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TreeConnection
  "Default branch of the repository."
  rootRef: String
  "Tree of the repository."
  tree(
    "Path to get the tree for. Default value is the root of the repository."
    path: String = "",
    "Used to get a recursive tree. Default is false."
    recursive: Boolean = false,
    "Commit ref to get the tree for. Default value is HEAD."
    ref: String,
    "Type of ref."
    refType: RefType
  ): Tree
}
type RepositoryBlob {
  "Whether the current project is archived."
  archived: Boolean
  "Content of blob is encoded base64. Returns `null` if the `unicode_escaped_data` feature flag is disabled. Introduced in GitLab 17.1: **Status**: Experiment."
  base64EncodedBlob: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.1.")
  "Blob blame. Introduced in GitLab 16.3: **Status**: Experiment."
  blame(
    "Range starting from the line. Cannot be less than 1 or greater than `to_line`."
    fromLine: Int = 1,
    "Range ending on the line. Cannot be smaller than `from_line` or greater than `from_line` + 100."
    toLine: Int = 1
  ): Blame @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Web path to blob blame page."
  blamePath: String
  "Whether the current user can push to the branch."
  canCurrentUserPushToBranch: Boolean
  "Whether the current user can modify the blob."
  canModifyBlob: Boolean
  "Whether the current user can modify the blob with Web IDE."
  canModifyBlobWithWebIde: Boolean!
  "Web path for code navigation."
  codeNavigationPath: String
  "Web path to edit the blob in the old-style editor."
  editBlobPath: String
  "Web path to blob on an environment."
  environmentExternalUrlForRouteMap: String
  "Environment on which the blob is available."
  environmentFormattedExternalUrl: String
  "External storage being used, if enabled (for instance, 'LFS')."
  externalStorage: String
  "Web path to download the raw blob via external storage, if enabled."
  externalStorageUrl: String
  "Expected format of the blob based on the extension."
  fileType: String
  "Web path to find file."
  findFilePath: String
  "Web path to edit the blob using a forked project."
  forkAndEditPath: String
  "Web path to view the blob using a forked project."
  forkAndViewPath: String
  "URL to the blob within Gitpod."
  gitpodBlobUrl: String
  "Web path to blob history page."
  historyPath: String
  "ID of the blob."
  id: ID!
  "Web path to edit the blob in the Web IDE."
  ideEditPath: String
  "Web path to edit the blob in the Web IDE using a forked project."
  ideForkAndEditPath: String
  "Blob language."
  language: String
  "LFS OID of the blob."
  lfsOid: String
  "Blob mode."
  mode: String
  "Blob name."
  name: String
  "OID of the blob."
  oid: String!
  "Path of the blob."
  path: String!
  "Web path to blob permalink."
  permalinkPath: String
  "Web path to edit .gitlab-ci.yml file."
  pipelineEditorPath: String
  "Blob plain highlighted data."
  plainData: String
  "Web path for the root of the blob."
  projectBlobPathRoot: String
  "Raw content of the blob."
  rawBlob: String
  "Web path to download the raw blob."
  rawPath: String
  "Size (in bytes) of the blob, or the blob target if stored externally."
  rawSize: BigInt
  "Raw content of the blob, if the blob is text data."
  rawTextBlob: String
  "Web path to replace the blob content."
  replacePath: String
  "Blob content rich viewer."
  richViewer: BlobViewer
  "Blob content simple viewer."
  simpleViewer: BlobViewer!
  "Size (in bytes) of the blob."
  size: BigInt
  "Whether the blob's content is stored externally (for instance, in LFS)."
  storedExternally: Boolean
  "Web path of the blob."
  webPath: String
}
"The connection type for RepositoryBlob."
type RepositoryBlobConnection {
  "A list of edges."
  edges: [RepositoryBlobEdge]
  "A list of nodes."
  nodes: [RepositoryBlob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type RepositoryBlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RepositoryBlob
}
type RepositoryLanguage {
  "Color to visualize the repository language."
  color: Color
  "Name of the repository language."
  name: String!
  "Percentage of the repository's languages."
  share: Float
}
"Autogenerated return type of RestorePagesDeployment."
type RestorePagesDeploymentPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Restored Pages Deployment."
  pagesDeployment: PagesDeployment!
}
type RootStorageStatistics {
  "CI artifacts size in bytes."
  buildArtifactsSize: Float!
  "Container registry size in bytes."
  containerRegistrySize: Float!
  "Indicates whether the deduplicated container registry size for the namespace is an estimated value or not."
  containerRegistrySizeIsEstimated: Boolean!
  "Dependency Proxy sizes in bytes."
  dependencyProxySize: Float!
  "LFS objects size in bytes."
  lfsObjectsSize: Float!
  "Packages size in bytes."
  packagesSize: Float!
  "CI pipeline artifacts size in bytes."
  pipelineArtifactsSize: Float!
  "Indicates whether the deduplicated container registry size for the namespace is an estimated value or not. Deprecated in GitLab 16.2: Use `container_registry_size_is_estimated`."
  registrySizeEstimated: Boolean! @deprecated(reason: "Use `container_registry_size_is_estimated`. Deprecated in GitLab 16.2.")
  "Git repository size in bytes."
  repositorySize: Float!
  "Snippets size in bytes."
  snippetsSize: Float!
  "Total storage in bytes."
  storageSize: Float!
  "Uploads size in bytes."
  uploadsSize: Float!
  "Wiki size in bytes."
  wikiSize: Float!
}
type RunnerArchitecture {
  "Download location for the runner for the platform architecture."
  downloadLocation: String!
  "Name of the runner platform architecture."
  name: String!
}
"The connection type for RunnerArchitecture."
type RunnerArchitectureConnection {
  "A list of edges."
  edges: [RunnerArchitectureEdge]
  "A list of nodes."
  nodes: [RunnerArchitecture]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type RunnerArchitectureEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RunnerArchitecture
}
"Autogenerated return type of RunnerBulkPause."
type RunnerBulkPausePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Number of records effectively updated. Only present if operation was performed synchronously."
  updatedCount: Int
  "Runners after mutation."
  updatedRunners: [CiRunner!]
}
"Autogenerated return type of RunnerCacheClear."
type RunnerCacheClearPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of RunnerCreate."
type RunnerCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Runner after mutation."
  runner: CiRunner
}
"Autogenerated return type of RunnerDelete."
type RunnerDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type RunnerPermissions {
  "If `true`, the user can perform `assign_runner` on this resource"
  assignRunner: Boolean!
  "If `true`, the user can perform `delete_runner` on this resource"
  deleteRunner: Boolean!
  "If `true`, the user can perform `read_runner` on this resource"
  readRunner: Boolean!
  "If `true`, the user can perform `update_runner` on this resource"
  updateRunner: Boolean!
}
type RunnerPlatform {
  "Runner architectures supported for the platform."
  architectures(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): RunnerArchitectureConnection
  "Human readable name of the runner platform."
  humanReadableName: String!
  "Name slug of the runner platform."
  name: String!
}
"The connection type for RunnerPlatform."
type RunnerPlatformConnection {
  "A list of edges."
  edges: [RunnerPlatformEdge]
  "A list of nodes."
  nodes: [RunnerPlatform]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type RunnerPlatformEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RunnerPlatform
}
type RunnerSetup {
  "Instructions for installing the runner on the specified architecture."
  installInstructions: String!
  "Instructions for registering the runner. The actual registration tokens are not included in the commands. Instead, a placeholder `$REGISTRATION_TOKEN` is shown."
  registerInstructions: String
}
"Autogenerated return type of RunnerUpdate."
type RunnerUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Runner after mutation."
  runner: CiRunner
}
"Autogenerated return type of RunnersRegistrationTokenReset."
type RunnersRegistrationTokenResetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Runner token after mutation."
  token: String
}
"Represents a CI configuration of SAST"
type SastCiConfiguration {
  "List of analyzers entities attached to SAST configuration."
  analyzers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationAnalyzersEntityConnection
  "List of global entities related to SAST configuration."
  global(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationEntityConnection
  "List of pipeline entities related to SAST configuration."
  pipeline(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationEntityConnection
}
"Represents an analyzer entity in SAST CI configuration"
type SastCiConfigurationAnalyzersEntity {
  "Analyzer description that is displayed on the form."
  description: String
  "Indicates whether an analyzer is enabled."
  enabled: Boolean
  "Analyzer label used in the config UI."
  label: String
  "Name of the analyzer."
  name: String
  "List of supported variables."
  variables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationEntityConnection
}
"The connection type for SastCiConfigurationAnalyzersEntity."
type SastCiConfigurationAnalyzersEntityConnection {
  "A list of edges."
  edges: [SastCiConfigurationAnalyzersEntityEdge]
  "A list of nodes."
  nodes: [SastCiConfigurationAnalyzersEntity]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SastCiConfigurationAnalyzersEntityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SastCiConfigurationAnalyzersEntity
}
"Represents an entity in SAST CI configuration"
type SastCiConfigurationEntity {
  "Default value that is used if value is empty."
  defaultValue: String
  "Entity description that is displayed on the form."
  description: String
  "CI keyword of entity."
  field: String
  "Label for entity used in the form."
  label: String
  "Different possible values of the field."
  options(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationOptionsEntityConnection
  "Size of the UI component."
  size: SastUiComponentSize
  "Type of the field value."
  type: String
  "Current value of the entity."
  value: String
}
"The connection type for SastCiConfigurationEntity."
type SastCiConfigurationEntityConnection {
  "A list of edges."
  edges: [SastCiConfigurationEntityEdge]
  "A list of nodes."
  nodes: [SastCiConfigurationEntity]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SastCiConfigurationEntityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SastCiConfigurationEntity
}
"Represents an entity for options in SAST CI configuration"
type SastCiConfigurationOptionsEntity {
  "Label of option entity."
  label: String
  "Value of option entity."
  value: String
}
"The connection type for SastCiConfigurationOptionsEntity."
type SastCiConfigurationOptionsEntityConnection {
  "A list of edges."
  edges: [SastCiConfigurationOptionsEntityEdge]
  "A list of nodes."
  nodes: [SastCiConfigurationOptionsEntity]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SastCiConfigurationOptionsEntityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SastCiConfigurationOptionsEntity
}
type SavedReply {
  "Content of the saved reply."
  content: String!
  "Global ID of the user saved reply."
  id: UsersSavedReplyID!
  "Name of the saved reply."
  name: String!
}
"The connection type for SavedReply."
type SavedReplyConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [SavedReplyEdge]
  "A list of nodes."
  nodes: [SavedReply]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of SavedReplyCreate."
type SavedReplyCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Saved reply after mutation."
  savedReply: SavedReply
}
"Autogenerated return type of SavedReplyDestroy."
type SavedReplyDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Saved reply after mutation."
  savedReply: SavedReply
}
"An edge in a connection."
type SavedReplyEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SavedReply
}
"Autogenerated return type of SavedReplyUpdate."
type SavedReplyUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Saved reply after mutation."
  savedReply: SavedReply
}
"A Sentry error"
type SentryDetailedError {
  "Count of occurrences."
  count: Int!
  "Culprit of the error."
  culprit: String!
  "External Base URL of the Sentry Instance."
  externalBaseUrl: String!
  "External URL of the error."
  externalUrl: String!
  "Commit the error was first seen."
  firstReleaseLastCommit: String
  "Release short version the error was first seen."
  firstReleaseShortVersion: String
  "Release version the error was first seen."
  firstReleaseVersion: String
  "Timestamp when the error was first seen."
  firstSeen: Time!
  "Last 24hr stats of the error."
  frequency: [SentryErrorFrequency!]!
  "GitLab commit SHA attributed to the Error based on the release version."
  gitlabCommit: String
  "Path to the GitLab page for the GitLab commit attributed to the error."
  gitlabCommitPath: String
  "URL of GitLab Issue."
  gitlabIssuePath: String
  "ID (global ID) of the error."
  id: ID!
  "Error tracking backend."
  integrated: Boolean
  "Commit the error was last seen."
  lastReleaseLastCommit: String
  "Release short version the error was last seen."
  lastReleaseShortVersion: String
  "Release version the error was last seen."
  lastReleaseVersion: String
  "Timestamp when the error was last seen."
  lastSeen: Time!
  "Sentry metadata message of the error."
  message: String
  "ID (Sentry ID) of the error."
  sentryId: String!
  "ID of the project (Sentry project)."
  sentryProjectId: ID!
  "Name of the project affected by the error."
  sentryProjectName: String!
  "Slug of the project affected by the error."
  sentryProjectSlug: String!
  "Short ID (Sentry ID) of the error."
  shortId: String!
  "Status of the error."
  status: SentryErrorStatus!
  "Tags associated with the Sentry Error."
  tags: SentryErrorTags!
  "Title of the error."
  title: String!
  "Type of the error."
  type: String!
  "Count of users affected by the error."
  userCount: Int!
}
"A Sentry error. A simplified version of SentryDetailedError"
type SentryError {
  "Count of occurrences."
  count: Int!
  "Culprit of the error."
  culprit: String!
  "External URL of the error."
  externalUrl: String!
  "Timestamp when the error was first seen."
  firstSeen: Time!
  "Last 24hr stats of the error."
  frequency: [SentryErrorFrequency!]!
  "ID (global ID) of the error."
  id: ID!
  "Timestamp when the error was last seen."
  lastSeen: Time!
  "Sentry metadata message of the error."
  message: String
  "ID (Sentry ID) of the error."
  sentryId: String!
  "ID of the project (Sentry project)."
  sentryProjectId: ID!
  "Name of the project affected by the error."
  sentryProjectName: String!
  "Slug of the project affected by the error."
  sentryProjectSlug: String!
  "Short ID (Sentry ID) of the error."
  shortId: String!
  "Status of the error."
  status: SentryErrorStatus!
  "Title of the error."
  title: String!
  "Type of the error."
  type: String!
  "Count of users affected by the error."
  userCount: Int!
}
"An object containing a collection of Sentry errors, and a detailed error"
type SentryErrorCollection {
  "Detailed version of a Sentry error on the project."
  detailedError(
    "ID of the Sentry issue."
    id: GitlabErrorTrackingDetailedErrorID!
  ): SentryDetailedError
  "Stack Trace of Sentry Error."
  errorStackTrace(
    "ID of the Sentry issue."
    id: GitlabErrorTrackingDetailedErrorID!
  ): SentryErrorStackTrace
  "Collection of Sentry Errors."
  errors(
    "Search query for the Sentry error details."
    searchTerm: String,
    "Attribute to sort on. Options are frequency, first_seen, last_seen. last_seen is default."
    sort: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SentryErrorConnection
  "External URL for Sentry."
  externalUrl: String
}
"The connection type for SentryError."
type SentryErrorConnection {
  "A list of edges."
  edges: [SentryErrorEdge]
  "A list of nodes."
  nodes: [SentryError]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SentryErrorEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SentryError
}
type SentryErrorFrequency {
  "Count of errors received since the previously recorded time."
  count: Int!
  "Time the error frequency stats were recorded."
  time: Time!
}
"An object containing a stack trace entry for a Sentry error"
type SentryErrorStackTrace {
  "Time the stack trace was received by Sentry."
  dateReceived: String!
  "ID of the Sentry error."
  issueId: String!
  "Stack trace entries for the Sentry error."
  stackTraceEntries: [SentryErrorStackTraceEntry!]!
}
"An object context for a Sentry error stack trace"
type SentryErrorStackTraceContext {
  "Code number of the context."
  code: String!
  "Line number of the context."
  line: Int!
}
"An object containing a stack trace entry for a Sentry error"
type SentryErrorStackTraceEntry {
  "Function in which the Sentry error occurred."
  col: String
  "File in which the Sentry error occurred."
  fileName: String
  "Function in which the Sentry error occurred."
  function: String
  "Function in which the Sentry error occurred."
  line: String
  "Context of the Sentry error."
  traceContext: [SentryErrorStackTraceContext!]
}
"State of a Sentry error"
type SentryErrorTags {
  "Severity level of the Sentry Error."
  level: String
  "Logger of the Sentry Error."
  logger: String
}
"The connection type for Service."
type ServiceConnection {
  "A list of edges."
  edges: [ServiceEdge]
  "A list of nodes."
  nodes: [Service]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ServiceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Service
}
"Represents a snippet entry"
type Snippet implements NoteableInterface {
  "Owner of the snippet."
  author: UserCore
  "Snippet blobs."
  blobs(
    "Paths of the blobs."
    paths: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetBlobConnection
  "All commenters on the noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Timestamp the snippet was created."
  createdAt: Time!
  "Description of the snippet."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "File Name of the snippet."
  fileName: String
  "Indicates the snippet is hidden because the author has been banned."
  hidden: Boolean!
  "HTTP URL to the snippet repository."
  httpUrlToRepo: String
  "ID of the snippet."
  id: SnippetID!
  "Indicates whether the snippet was imported."
  imported: Boolean!
  "Import source of the snippet."
  importedFrom: ImportSource!
  "All notes on this noteable."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Project the snippet is associated with."
  project: Project
  "Raw URL of the snippet."
  rawUrl: String!
  "SSH URL to the snippet repository."
  sshUrlToRepo: String
  "Title of the snippet."
  title: String!
  "Timestamp the snippet was updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: SnippetPermissions!
  "Visibility Level of the snippet."
  visibilityLevel: VisibilityLevelsEnum!
  "Web URL of the snippet."
  webUrl: String!
}
"Represents the snippet blob"
type SnippetBlob {
  "Shows whether the blob is binary."
  binary: Boolean!
  "Blob external storage."
  externalStorage: String
  "Blob mode."
  mode: String
  "Blob name."
  name: String
  "Blob path."
  path: String
  "Blob plain highlighted data."
  plainData: String
  "Blob raw content endpoint path."
  rawPath: String!
  "Raw content of the blob, if the blob is text data."
  rawPlainData: String
  "Shows whether the blob is rendered as text."
  renderedAsText: Boolean!
  "Blob highlighted data."
  richData: String
  "Blob content rich viewer."
  richViewer: SnippetBlobViewer
  "Blob content simple viewer."
  simpleViewer: SnippetBlobViewer!
  "Blob size."
  size: Int!
}
"The connection type for SnippetBlob."
type SnippetBlobConnection {
  "A list of edges."
  edges: [SnippetBlobEdge]
  "Indicates if the snippet has unretrievable blobs."
  hasUnretrievableBlobs: Boolean!
  "A list of nodes."
  nodes: [SnippetBlob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SnippetBlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SnippetBlob
}
"Represents how the blob content should be displayed"
type SnippetBlobViewer {
  "Shows whether the blob should be displayed collapsed."
  collapsed: Boolean!
  "Content file type."
  fileType: String!
  "Shows whether the blob content is loaded asynchronously."
  loadAsync: Boolean!
  "Loading partial name."
  loadingPartialName: String!
  "Error rendering the blob content."
  renderError: String
  "Shows whether the blob is too large to be displayed."
  tooLarge: Boolean!
  "Type of blob viewer."
  type: BlobViewersType!
}
"The connection type for Snippet."
type SnippetConnection {
  "A list of edges."
  edges: [SnippetEdge]
  "A list of nodes."
  nodes: [Snippet]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SnippetEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Snippet
}
type SnippetPermissions {
  "If `true`, the user can perform `admin_snippet` on this resource"
  adminSnippet: Boolean!
  "If `true`, the user can perform `award_emoji` on this resource"
  awardEmoji: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `read_snippet` on this resource"
  readSnippet: Boolean!
  "If `true`, the user can perform `report_snippet` on this resource"
  reportSnippet: Boolean!
  "If `true`, the user can perform `update_snippet` on this resource"
  updateSnippet: Boolean!
}
"Squash option overrides for a protected branch"
type SquashOption {
  "Help text for the squash option."
  helpText: String!
  "Human-readable description of the squash option."
  option: String!
}
"SSH signature for a signed commit"
type SshSignature implements CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "SSH key used for the signature."
  key: Key
  "Fingerprint of the key."
  keyFingerprintSha256: String
  "Project of the associated commit."
  project: Project
  "User associated with the key."
  user: UserCore
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
}
"Autogenerated return type of StarProject."
type StarProjectPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of stars for the project."
  count: String!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type StatusAction {
  "Title for the button, for example: Retry the job."
  buttonTitle: String
  "Custom confirmation message for a manual job. Introduced in GitLab 17.0: **Status**: Experiment."
  confirmationMessage: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.0.")
  "Icon used in the action button."
  icon: String
  "ID for a status action."
  id: String!
  "Method for the action, for example: :post."
  method: String
  "Path for the action."
  path: String
  "Title for the action, for example: Retry."
  title: String
}
type Submodule implements Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "SHA of the entry."
  sha: String!
  "Tree URL for the sub-module."
  treeUrl: String
  "Type of tree entry."
  type: EntryType!
  "Web URL for the sub-module."
  webUrl: String
}
"The connection type for Submodule."
type SubmoduleConnection {
  "A list of edges."
  edges: [SubmoduleEdge]
  "A list of nodes."
  nodes: [Submodule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type SubmoduleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Submodule
}
type Subscription {
  "Triggered when a pipeline status is updated. Introduced in GitLab 17.10: **Status**: Experiment."
  ciPipelineStatusUpdated(
    "Global ID of the pipeline."
    pipelineId: CiPipelineID!
  ): Pipeline @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Triggered when the assignees of an issuable are updated."
  issuableAssigneesUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the due date or start date of an issuable is updated."
  issuableDatesUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the description of an issuable is updated."
  issuableDescriptionUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the labels of an issuable are updated."
  issuableLabelsUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the milestone of an issuable is updated."
  issuableMilestoneUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the title of an issuable is updated."
  issuableTitleUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when a todo on an issuable is updated. Introduced in GitLab 17.5: **Status**: Experiment."
  issuableTodoUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.5.")
  "Triggered when the crm contacts of an issuable are updated."
  issueCrmContactsUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when approval state of a merge request is updated."
  mergeRequestApprovalStateUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when a merge request diff is generated."
  mergeRequestDiffGenerated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the merge status of a merge request is updated."
  mergeRequestMergeStatusUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the reviewers of a merge request are updated."
  mergeRequestReviewersUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when a merge request the user is an assignee or a reviewer of is updated. Introduced in GitLab 17.9: **Status**: Experiment."
  userMergeRequestUpdated(
    "ID of the user."
    userId: UserID!
  ): MergeRequest @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Triggered when a note is created. Introduced in GitLab 15.9: **Status**: Experiment."
  workItemNoteCreated(
    "ID of the noteable."
    noteableId: NoteableID
  ): Note @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  "Triggered when a note is deleted. Introduced in GitLab 15.9: **Status**: Experiment."
  workItemNoteDeleted(
    "ID of the noteable."
    noteableId: NoteableID
  ): DeletedNote @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  "Triggered when a note is updated. Introduced in GitLab 15.9: **Status**: Experiment."
  workItemNoteUpdated(
    "ID of the noteable."
    noteableId: NoteableID
  ): Note @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  "Triggered when a work item is updated."
  workItemUpdated(
    "ID of the work item."
    workItemId: WorkItemID!
  ): WorkItem
}
type SystemNoteMetadata {
  "System note metadata action."
  action: String
  "Version of the changed description."
  descriptionVersion: DescriptionVersion
  "Global ID of the specific system note metadata."
  id: SystemNoteMetadataID!
}
type Tag {
  "Commit for the tag."
  commit: Commit
  "Tagging message."
  message: String
  "Name of the tag."
  name: String!
}
"Autogenerated return type of TagCreate."
type TagCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Tag after mutation."
  tag: Tag
}
"Autogenerated return type of TagDelete."
type TagDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Tag after mutation."
  tag: Tag
}
"Completion status of tasks"
type TaskCompletionStatus {
  "Number of completed tasks."
  completedCount: Int!
  "Number of total tasks."
  count: Int!
}
"Terraform module metadata"
type TerraformModuleMetadata {
  "Timestamp of when the metadata was created."
  createdAt: Time!
  "Fields of the metadata."
  fields: TerraformModuleMetadataFields!
  "ID of the metadata."
  id: PackagesTerraformModuleMetadatumID!
  "Timestamp of when the metadata was last updated."
  updatedAt: Time!
}
"Terraform module metadata dependencies"
type TerraformModuleMetadataDependencies {
  "Modules of the module."
  modules: [TerraformModuleMetadataDependency!]
  "Providers of the module."
  providers: [TerraformModuleMetadataDependency!]
}
"Terraform module metadata dependency"
type TerraformModuleMetadataDependency {
  "Name of the dependency."
  name: String!
  "Source of the dependency."
  source: String
  "Version of the dependency."
  version: String
}
"Terraform module metadata example"
type TerraformModuleMetadataExample implements TerraformModuleMetadataSharedFields {
  "Inputs of the module."
  inputs: [TerraformModuleMetadataInput!]
  "Name of the example."
  name: String!
  "Outputs of the module."
  outputs: [TerraformModuleMetadataOutput!]
  "Readme data."
  readme: String
  "GitLab Flavored Markdown rendering of `readme`"
  readmeHtml: String
}
"Terraform module metadata fields type"
type TerraformModuleMetadataFields {
  "Examples of the module."
  examples: [TerraformModuleMetadataExample!]
  "Root module."
  root: TerraformModuleMetadataRoot!
  "Submodules of the module."
  submodules: [TerraformModuleMetadataSubmodule!]
}
"Terraform module metadata input type"
type TerraformModuleMetadataInput {
  "Default value of the input."
  default: String
  "Description of the input."
  description: String
  "Name of the input."
  name: String!
  "Type of the input."
  type: String!
}
"Terraform module metadata output"
type TerraformModuleMetadataOutput {
  "Description of the output field."
  description: String
  "Name of the output field."
  name: String!
}
"Metadata for Terraform root module"
type TerraformModuleMetadataRoot implements TerraformModuleMetadataSharedFields {
  "Dependencies of the module."
  dependencies: TerraformModuleMetadataDependencies
  "Inputs of the module."
  inputs: [TerraformModuleMetadataInput!]
  "Outputs of the module."
  outputs: [TerraformModuleMetadataOutput!]
  "Readme data."
  readme: String
  "GitLab Flavored Markdown rendering of `readme`"
  readmeHtml: String
  "Resources of the module."
  resources: [String!]
}
"Terraform module metadata submodule"
type TerraformModuleMetadataSubmodule implements TerraformModuleMetadataSharedFields {
  "Dependencies of the submodule."
  dependencies: TerraformModuleMetadataDependencies
  "Inputs of the module."
  inputs: [TerraformModuleMetadataInput!]
  "Name of the submodule."
  name: String!
  "Outputs of the module."
  outputs: [TerraformModuleMetadataOutput!]
  "Readme data."
  readme: String
  "GitLab Flavored Markdown rendering of `readme`"
  readmeHtml: String
  "Resources of the submodule."
  resources: [String!]
}
type TerraformState {
  "Timestamp the Terraform state was created."
  createdAt: Time!
  "Timestamp the Terraform state was deleted."
  deletedAt: Time
  "ID of the Terraform state."
  id: ID!
  "Latest version of the Terraform state."
  latestVersion: TerraformStateVersion
  "Timestamp the Terraform state was locked."
  lockedAt: Time
  "User currently holding a lock on the Terraform state."
  lockedByUser: UserCore
  "Name of the Terraform state."
  name: String!
  "Timestamp the Terraform state was updated."
  updatedAt: Time!
}
"The connection type for TerraformState."
type TerraformStateConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TerraformStateEdge]
  "A list of nodes."
  nodes: [TerraformState]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of TerraformStateDelete."
type TerraformStateDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type TerraformStateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TerraformState
}
"Autogenerated return type of TerraformStateLock."
type TerraformStateLockPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of TerraformStateUnlock."
type TerraformStateUnlockPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
type TerraformStateVersion {
  "Timestamp the version was created."
  createdAt: Time!
  "User that created the version."
  createdByUser: UserCore
  "URL for downloading the version's JSON file."
  downloadPath: String
  "ID of the Terraform state version."
  id: ID!
  "Job that created the version."
  job: CiJob
  "Serial number of the version."
  serial: Int
  "Timestamp the version was updated."
  updatedAt: Time!
}
"Test case in pipeline test report."
type TestCase {
  "URL of the test case attachment file."
  attachmentUrl: String
  "Classname of the test case."
  classname: String
  "Test case execution time in seconds."
  executionTime: Float
  "Path to the file of the test case."
  file: String
  "Name of the test case."
  name: String
  "Recent failure history of the test case on the base branch."
  recentFailures: RecentFailures
  "Stack trace of the test case."
  stackTrace: String
  "Status of the test case (error, failed, success, skipped)."
  status: TestCaseStatus
  "System output of the test case."
  systemOutput: String
}
"The connection type for TestCase."
type TestCaseConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TestCaseEdge]
  "A list of nodes."
  nodes: [TestCase]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TestCaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TestCase
}
"Test report for a pipeline"
type TestReportSummary {
  "Test suites belonging to a pipeline test report."
  testSuites(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TestSuiteSummaryConnection!
  "Total report statistics for a pipeline test report."
  total: TestReportTotal!
}
"Total test report statistics."
type TestReportTotal {
  "Total number of the test cases."
  count: Int
  "Total number of test cases that had an error."
  error: Int
  "Total number of test cases that failed."
  failed: Int
  "Total number of test cases that were skipped."
  skipped: Int
  "Total number of test cases that succeeded."
  success: Int
  "Test suite error message."
  suiteError: String
  "Total duration of the tests."
  time: Float
}
"Test suite in a pipeline test report."
type TestSuite {
  "Total number of test cases that had an error."
  errorCount: Int
  "Total number of test cases that failed in the test suite."
  failedCount: Int
  "Name of the test suite."
  name: String
  "Total number of test cases that were skipped in the test suite."
  skippedCount: Int
  "Total number of test cases that succeeded in the test suite."
  successCount: Int
  "Test suite error message."
  suiteError: String
  "Test cases in the test suite."
  testCases(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TestCaseConnection
  "Total number of the test cases in the test suite."
  totalCount: Int
  "Total duration of the tests in the test suite."
  totalTime: Float
}
"Test suite summary in a pipeline test report."
type TestSuiteSummary {
  "IDs of the builds used to run the test suite."
  buildIds: [ID!]
  "Total number of test cases that had an error."
  errorCount: Int
  "Total number of test cases that failed in the test suite."
  failedCount: Int
  "Name of the test suite."
  name: String
  "Total number of test cases that were skipped in the test suite."
  skippedCount: Int
  "Total number of test cases that succeeded in the test suite."
  successCount: Int
  "Test suite error message."
  suiteError: String
  "Total number of the test cases in the test suite."
  totalCount: Int
  "Total duration of the tests in the test suite."
  totalTime: Float
}
"The connection type for TestSuiteSummary."
type TestSuiteSummaryConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TestSuiteSummaryEdge]
  "A list of nodes."
  nodes: [TestSuiteSummary]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TestSuiteSummaryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TestSuiteSummary
}
type TimeTrackingTimelogCategory {
  "Whether the category is billable or not."
  billable: Boolean
  "Billing rate for the category."
  billingRate: Float
  "Color assigned to the category."
  color: Color
  "When the category was created."
  createdAt: Time!
  "Description of the category."
  description: String
  "Internal ID of the timelog category."
  id: ID!
  "Name of the category."
  name: String!
  "When the category was last updated."
  updatedAt: Time!
}
"The connection type for TimeTrackingTimelogCategory."
type TimeTrackingTimelogCategoryConnection {
  "A list of edges."
  edges: [TimeTrackingTimelogCategoryEdge]
  "A list of nodes."
  nodes: [TimeTrackingTimelogCategory]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TimeTrackingTimelogCategoryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TimeTrackingTimelogCategory
}
"Autogenerated return type of TimelineEventCreate."
type TimelineEventCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}
"Autogenerated return type of TimelineEventDestroy."
type TimelineEventDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}
"Autogenerated return type of TimelineEventPromoteFromNote."
type TimelineEventPromoteFromNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}
"Autogenerated return type of TimelineEventTagCreate."
type TimelineEventTagCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event tag."
  timelineEventTag: TimelineEventTagType
}
"Describes a tag on an incident management timeline event."
type TimelineEventTagType {
  "ID of the timeline event tag."
  id: IncidentManagementTimelineEventTagID!
  "Name of the timeline event tag."
  name: String!
}
"The connection type for TimelineEventTagType."
type TimelineEventTagTypeConnection {
  "A list of edges."
  edges: [TimelineEventTagTypeEdge]
  "A list of nodes."
  nodes: [TimelineEventTagType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TimelineEventTagTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TimelineEventTagType
}
"Describes an incident management timeline event"
type TimelineEventType {
  "Indicates the timeline event icon."
  action: String!
  "User that created the timeline event."
  author: UserCore
  "Timestamp when the event created."
  createdAt: Time!
  "Indicates the timeline event is editable."
  editable: Boolean!
  "ID of the timeline event."
  id: IncidentManagementTimelineEventID!
  "Incident of the timeline event."
  incident: Issue!
  "Text note of the timeline event."
  note: String
  "HTML note of the timeline event."
  noteHtml: String
  "Timestamp when the event occurred."
  occurredAt: Time!
  "Note from which the timeline event was created."
  promotedFromNote: Note
  "Tags for the incident timeline event."
  timelineEventTags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelineEventTagTypeConnection
  "Timestamp when the event updated."
  updatedAt: Time!
  "User that updated the timeline event."
  updatedByUser: UserCore
}
"The connection type for TimelineEventType."
type TimelineEventTypeConnection {
  "A list of edges."
  edges: [TimelineEventTypeEdge]
  "A list of nodes."
  nodes: [TimelineEventType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TimelineEventTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TimelineEventType
}
"Autogenerated return type of TimelineEventUpdate."
type TimelineEventUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}
type Timelog {
  "Internal ID of the timelog."
  id: ID!
  "Issue that logged time was added to."
  issue: Issue
  "Merge request that logged time was added to."
  mergeRequest: MergeRequest
  "Note where the quick action was executed to add the logged time."
  note: Note
  "Target project of the timelog merge request or issue."
  project: Project!
  "Timestamp of when the time tracked was spent at."
  spentAt: Time
  "Summary of how the time was spent."
  summary: String
  "Time spent displayed in seconds."
  timeSpent: Int!
  "User that logged the time."
  user: UserCore!
  "Permissions for the current user on the resource"
  userPermissions: TimelogPermissions!
}
"The connection type for Timelog."
type TimelogConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TimelogEdge]
  "A list of nodes."
  nodes: [Timelog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total time spent in seconds."
  totalSpentTime: BigInt!
}
"Autogenerated return type of TimelogCreate."
type TimelogCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timelog."
  timelog: Timelog
}
"Autogenerated return type of TimelogDelete."
type TimelogDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timelog."
  timelog: Timelog
}
"An edge in a connection."
type TimelogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Timelog
}
type TimelogPermissions {
  "If `true`, the user can perform `admin_timelog` on this resource"
  adminTimelog: Boolean!
}
"Representing a to-do entry"
type Todo {
  "Action of the to-do item."
  action: TodoActionEnum!
  "Author of the to-do item."
  author: UserCore!
  "Body of the to-do item."
  body: String!
  "Timestamp the to-do item was created."
  createdAt: Time!
  "Group the to-do item is associated with."
  group: Group
  "ID of the to-do item."
  id: ID!
  "Access type of access request to-do items."
  memberAccessType: String
  "Note which created the to-do item."
  note: Note
  "Project the to-do item is associated with."
  project: Project
  "Time until when the todo is snoozed."
  snoozedUntil: Time
  "State of the to-do item."
  state: TodoStateEnum!
  "Target of the to-do item. Deprecated in GitLab 17.4: Use `target_entity` field."
  target: Todoable! @deprecated(reason: "Use `target_entity` field. Deprecated in GitLab 17.4.")
  "Target of the to-do item."
  targetEntity: Todoable
  "Target type of the to-do item."
  targetType: TodoTargetEnum!
  "URL of the to-do item target."
  targetUrl: String
}
"The connection type for Todo."
type TodoConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TodoEdge]
  "A list of nodes."
  nodes: [Todo]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of TodoCreate."
type TodoCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "To-do item created."
  todo: Todo
}
"Autogenerated return type of TodoDeleteMany."
type TodoDeleteManyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"An edge in a connection."
type TodoEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Todo
}
"Autogenerated return type of TodoMarkDone."
type TodoMarkDonePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requested to-do item."
  todo: Todo!
}
"Autogenerated return type of TodoResolveMany."
type TodoResolveManyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Resolved to-do items."
  todos: [Todo!]!
}
"Autogenerated return type of TodoRestoreMany."
type TodoRestoreManyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Restored to-do items."
  todos: [Todo!]!
}
"Autogenerated return type of TodoRestore."
type TodoRestorePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requested to-do item."
  todo: Todo!
}
"Autogenerated return type of TodoSnoozeMany."
type TodoSnoozeManyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snoozed to-do items."
  todos: [Todo!]!
}
"Autogenerated return type of TodoSnooze."
type TodoSnoozePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requested to-do item."
  todo: Todo!
}
"Autogenerated return type of TodoUnSnooze."
type TodoUnSnoozePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requested to-do item."
  todo: Todo!
}
"Autogenerated return type of TodoUnsnoozeMany."
type TodoUnsnoozeManyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Unsnoozed to-do items."
  todos: [Todo!]!
}
"Autogenerated return type of TodosMarkAllDone."
type TodosMarkAllDonePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated to-do items."
  todos: [Todo!]!
}
type Topic {
  "URL to avatar image file of the topic."
  avatarUrl: String
  "Description of the topic."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "ID of the topic."
  id: ID!
  "Name of the topic."
  name: String!
  "Title of the topic."
  title: String!
}
"The connection type for Topic."
type TopicConnection {
  "A list of edges."
  edges: [TopicEdge]
  "A list of nodes."
  nodes: [Topic]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TopicEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Topic
}
type Tree {
  "Blobs of the tree."
  blobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BlobConnection!
  "Last commit for the tree."
  lastCommit(
    "Path to get the last commit for. Default value is the root of the repository."
    path: String,
    "Commit ref to get the last commit for. Default value is HEAD."
    ref: String,
    "Type of ref."
    refType: RefType
  ): Commit
  "Sub-modules of the tree."
  submodules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SubmoduleConnection!
  "Trees of the tree."
  trees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TreeEntryConnection!
}
"The connection type for Tree."
type TreeConnection {
  "A list of edges."
  edges: [TreeEdge]
  "A list of nodes."
  nodes: [Tree]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TreeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Tree
}
"Represents a directory"
type TreeEntry implements Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "SHA of the entry."
  sha: String!
  "Type of tree entry."
  type: EntryType!
  "Web path for the tree entry (directory)."
  webPath: String
  "Web URL for the tree entry (directory)."
  webUrl: String
}
"The connection type for TreeEntry."
type TreeEntryConnection {
  "A list of edges."
  edges: [TreeEntryEdge]
  "A list of nodes."
  nodes: [TreeEntry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type TreeEntryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TreeEntry
}
"Autogenerated return type of UpdateAbuseReportNote."
type UpdateAbuseReportNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Abuse report note after mutation."
  note: AbuseReportNote!
}
"Autogenerated return type of UpdateAlertStatus."
type UpdateAlertStatusPayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}
"Autogenerated return type of UpdateBoardList."
type UpdateBoardListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mutated list."
  list: BoardList
}
"Autogenerated return type of UpdateBoard."
type UpdateBoardPayload {
  "Board after mutation."
  board: Board
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of UpdateContainerExpirationPolicy."
type UpdateContainerExpirationPolicyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container expiration policy after mutation. Deprecated in GitLab 17.5: Use `container_tags_expiration_policy`."
  containerExpirationPolicy: ContainerExpirationPolicy @deprecated(reason: "Use `container_tags_expiration_policy`. Deprecated in GitLab 17.5.")
  "Container tags expiration policy after mutation."
  containerTagsExpirationPolicy: ContainerTagsExpirationPolicy
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of UpdateContainerProtectionRepositoryRule."
type UpdateContainerProtectionRepositoryRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container repository protection rule after mutation."
  containerProtectionRepositoryRule: ContainerProtectionRepositoryRule
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of UpdateContainerProtectionTagRule."
type UpdateContainerProtectionTagRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Protection rule for container image tags after creation. Introduced in GitLab 17.8: **Status**: Experiment."
  containerProtectionTagRule: ContainerProtectionTagRule @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of UpdateDependencyProxyImageTtlGroupPolicy."
type UpdateDependencyProxyImageTtlGroupPolicyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group image TTL policy after mutation."
  dependencyProxyImageTtlPolicy: DependencyProxyImageTtlGroupPolicy
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of UpdateDependencyProxySettings."
type UpdateDependencyProxySettingsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group dependency proxy settings after mutation."
  dependencyProxySetting: DependencyProxySetting
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of UpdateImageDiffNote."
type UpdateImageDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"Autogenerated return type of UpdateIssue."
type UpdateIssuePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}
"Autogenerated return type of UpdateNamespacePackageSettings."
type UpdateNamespacePackageSettingsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Namespace package setting after mutation."
  packageSettings: PackageSettings
}
"Autogenerated return type of UpdateNote."
type UpdateNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
  "Status of quick actions after mutation."
  quickActionsStatus: QuickActionsStatus
}
"Autogenerated return type of UpdatePackagesCleanupPolicy."
type UpdatePackagesCleanupPolicyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages cleanup policy after mutation."
  packagesCleanupPolicy: PackagesCleanupPolicy
}
"Autogenerated return type of UpdatePackagesProtectionRule."
type UpdatePackagesProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages protection rule after mutation."
  packageProtectionRule: PackagesProtectionRule
}
"Autogenerated return type of UpdateSnippet."
type UpdateSnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}
"Autogenerated return type of UploadDelete."
type UploadDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted upload."
  upload: FileUpload
}
"Represents a recorded measurement (object count) for the Admins"
type UsageTrendsMeasurement {
  "Object count."
  count: Int!
  "Type of objects being measured."
  identifier: MeasurementIdentifier!
  "Time the measurement was recorded."
  recordedAt: Time
}
"The connection type for UsageTrendsMeasurement."
type UsageTrendsMeasurementConnection {
  "A list of edges."
  edges: [UsageTrendsMeasurementEdge]
  "A list of nodes."
  nodes: [UsageTrendsMeasurement]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type UsageTrendsMeasurementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UsageTrendsMeasurement
}
type UserAchievement {
  "Achievement awarded."
  achievement: Achievement!
  "Awarded by."
  awardedByUser: UserCore!
  "Timestamp the achievement was created."
  createdAt: Time!
  "ID of the user achievement."
  id: AchievementsUserAchievementID!
  "Priority of the user achievement."
  priority: Int
  "Timestamp the achievement was revoked."
  revokedAt: Time
  "Revoked by."
  revokedByUser: UserCore
  "Indicates whether or not the achievement is shown on the profile."
  showOnProfile: Boolean!
  "Timestamp the achievement was last updated."
  updatedAt: Time!
  "Achievement recipient."
  user: UserCore!
}
"The connection type for UserAchievement."
type UserAchievementConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [UserAchievementEdge]
  "A list of nodes."
  nodes: [UserAchievement]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type UserAchievementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserAchievement
}
"Autogenerated return type of UserAchievementPrioritiesUpdate."
type UserAchievementPrioritiesUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated user achievements."
  userAchievements: [UserAchievement!]!
}
"Autogenerated return type of UserAchievementsDelete."
type UserAchievementsDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted user achievement."
  userAchievement: UserAchievement
}
"Autogenerated return type of UserAchievementsUpdate."
type UserAchievementsUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Achievement award."
  userAchievement: UserAchievement
}
type UserCallout {
  "Date when the callout was dismissed."
  dismissedAt: Time
  "Name of the feature that the callout is for."
  featureName: UserCalloutFeatureNameEnum
}
"The connection type for UserCallout."
type UserCalloutConnection {
  "A list of edges."
  edges: [UserCalloutEdge]
  "A list of nodes."
  nodes: [UserCallout]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of UserCalloutCreate."
type UserCalloutCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User callout dismissed."
  userCallout: UserCallout!
}
"An edge in a connection."
type UserCalloutEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserCallout
}
"Core representation of a GitLab user."
type UserCore implements Todoable & User {
  "Indicates if the user is active."
  active: Boolean
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
"The connection type for UserCore."
type UserCoreConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [UserCoreEdge]
  "A list of nodes."
  nodes: [UserCore]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type UserCoreEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserCore
}
"""
Information about a merge request given a specific user.

This object has two parts to its state: a `User` and a `MergeRequest`. All
fields relate to interactions between the two entities.
"""
type UserMergeRequestInteraction {
  "Whether the user has approved the merge request."
  approved: Boolean!
  "Whether the user can merge the merge request."
  canMerge: Boolean!
  "Whether the user can update the merge request."
  canUpdate: Boolean!
  "State of the review by the user."
  reviewState: MergeRequestReviewState
  "Whether the user has provided a review for the merge request."
  reviewed: Boolean!
}
type UserPermissions {
  "If `true`, the user can perform `create_snippet` on this resource"
  createSnippet: Boolean!
}
type UserPreferences {
  "Status of the Web IDE Extension Marketplace opt-in for the user."
  extensionsMarketplaceOptInStatus: ExtensionsMarketplaceOptInStatus!
  "Sort order for issue lists."
  issuesSort: IssueSort
  "Merge request dashboard list rendering type."
  mergeRequestDashboardListType: MergeRequestsDashboardListType
  "Default list view for organization groups and projects. Introduced in GitLab 17.2: **Status**: Experiment."
  organizationGroupsProjectsDisplay: OrganizationGroupProjectDisplay! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  "Sort order for organization groups and projects. Introduced in GitLab 17.2: **Status**: Experiment."
  organizationGroupsProjectsSort: OrganizationGroupProjectSort @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  "Sort order for projects."
  projectsSort: ProjectSort
  "Timezone of the user. Introduced in GitLab 17.7: **Status**: Experiment."
  timezone: String @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.7.")
  "Use work item view instead of legacy issue view."
  useWorkItemsView: Boolean
  "Determines whether the pipeline list shows ID or IID."
  visibilityPipelineIdType: VisibilityPipelineIdType
}
"Autogenerated return type of UserPreferencesUpdate."
type UserPreferencesUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User preferences after mutation."
  userPreferences: UserPreferences
}
"Autogenerated return type of UserSetNamespaceCommitEmail."
type UserSetNamespaceCommitEmailPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User namespace commit email after mutation."
  namespaceCommitEmail: NamespaceCommitEmail
}
type UserStatus {
  "User availability status."
  availability: AvailabilityEnum!
  "String representation of emoji."
  emoji: String
  "User status message."
  message: String
  "HTML of the user status message"
  messageHtml: String
}
type ValueStream {
  "ID of the value stream."
  id: AnalyticsCycleAnalyticsValueStreamID!
  "Name of the value stream."
  name: String!
  "Namespace the value stream belongs to."
  namespace: Namespace!
  "Project the value stream belongs to, returns empty if it belongs to a group. Introduced in GitLab 15.6: **Status**: Experiment."
  project: Project @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.6.")
  "Value Stream stages."
  stages(
    "Value stream stage id."
    id: ID
  ): [ValueStreamStage!]
}
""
type ValueStreamAnalyticsMetric {
  "Identifier for the metric."
  identifier: String!
  "Optional links for drilling down."
  links: [ValueStreamMetricLinkType!]!
  "Title for the metric."
  title: String!
  "Unit of measurement."
  unit: String
  "Value for the metric."
  value: Float
}
"The connection type for ValueStream."
type ValueStreamConnection {
  "A list of edges."
  edges: [ValueStreamEdge]
  "A list of nodes."
  nodes: [ValueStream]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ValueStreamEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ValueStream
}
type ValueStreamMetricLinkType {
  "Link to the metric documentation."
  docsLink: Boolean
  "Label for the link."
  label: String!
  "Name of the link group."
  name: String!
  "Drill-down URL."
  url: String!
}
type ValueStreamStage {
  "Whether the stage is customized."
  custom: Boolean!
  "HTML description of the end event."
  endEventHtmlDescription: String!
  "End event identifier."
  endEventIdentifier: ValueStreamStageEvent!
  "Whether the stage is hidden."
  hidden: Boolean!
  "ID of the value stream."
  id: AnalyticsCycleAnalyticsStageID!
  "Aggregated metrics for the given stage"
  metrics(
    "Aggregation timeframe. Filters the issue or the merge request creation time for FOSS projects, and the end event timestamp for licensed projects or groups."
    timeframe: Timeframe!,
    "Usernames of users assigned to the issue or the merge request."
    assigneeUsernames: [String!],
    "Username of the author of the issue or the merge request."
    authorUsername: String,
    "Milestone applied to the issue or the merge request."
    milestoneTitle: String,
    "Labels applied to the issue or the merge request."
    labelNames: [String!]
  ): ValueStreamStageMetrics!
  "Name of the stage."
  name: String!
  "HTML description of the start event."
  startEventHtmlDescription: String!
  "Start event identifier."
  startEventIdentifier: ValueStreamStageEvent!
}
type ValueStreamStageItems {
  "Duration of the item on the stage."
  duration: String
  "When exited the stage."
  endEventTimestamp: Time
  "Item record."
  record: Issuable
}
"The connection type for ValueStreamStageItems."
type ValueStreamStageItemsConnection {
  "A list of edges."
  edges: [ValueStreamStageItemsEdge]
  "A list of nodes."
  nodes: [ValueStreamStageItems]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type ValueStreamStageItemsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ValueStreamStageItems
}
type ValueStreamStageMetrics {
  "Average duration in seconds."
  average: ValueStreamAnalyticsMetric
  "Limited item count. The backend counts maximum 1000 items, for free projects, and maximum 10,000 items for licensed projects or licensed groups."
  count: ValueStreamAnalyticsMetric
  "Items in the stage. Introduced in GitLab 17.4: **Status**: Experiment."
  items(
    "Sort stage items by criteria."
    sort: ValueStreamStageItemSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ValueStreamStageItemsConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  "Median duration in seconds."
  median: ValueStreamAnalyticsMetric
}
"A wiki page"
type WikiPage implements NoteableInterface & Todoable {
  "All commenters on the noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Global ID of the wiki page metadata record."
  id: WikiPageMetaID!
  "Name or title of the object."
  name: String
  "All notes on this noteable."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Wiki page title."
  title: String!
  "Permissions for the current user on the resource"
  userPermissions: WikiPagePermissions!
  "URL of the object."
  webUrl: String
}
type WikiPagePermissions {
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `read_wiki_page` on this resource"
  readWikiPage: Boolean!
}
type WorkItem implements Todoable {
  "Whether the work item belongs to an archived project. Always false for group level work items. Introduced in GitLab 16.5: **Status**: Experiment."
  archived: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.5.")
  "User that created the work item. Introduced in GitLab 15.9: **Status**: Experiment."
  author: UserCore @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.9.")
  "Timestamp of when the work item was closed."
  closedAt: Time
  "Indicates the work item is confidential."
  confidential: Boolean!
  "User specific email address for the work item."
  createNoteEmail: String
  "Timestamp of when the work item was created."
  createdAt: Time!
  "Description of the work item."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "URL of the work item that the work item is marked as a duplicate of."
  duplicatedToWorkItemUrl: String
  "Indicates the work item is hidden because the author has been banned."
  hidden: Boolean
  "Global ID of the work item."
  id: WorkItemID!
  "Internal ID of the work item."
  iid: String!
  "Lock version of the work item. Incremented each time the work item is updated."
  lockVersion: Int!
  "URL of the work item that the work item was moved to."
  movedToWorkItemUrl: String
  "Name or title of the object."
  name: String
  "Namespace the work item belongs to. Introduced in GitLab 15.10: **Status**: Experiment."
  namespace: Namespace @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Project the work item belongs to. Introduced in GitLab 15.3: **Status**: Experiment."
  project: Project @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.3.")
  "Internal reference of the work item. Returned in shortened format by default."
  reference(
    "Boolean option specifying whether the reference should be returned in full."
    full: Boolean = false
  ): String!
  "Whether to show the promotional message for the work item. Introduced in GitLab 17.11: **Status**: Experiment."
  showPlanUpgradePromotion: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.11.")
  "State of the work item."
  state: WorkItemState!
  "Title of the work item."
  title: String!
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Timestamp of when the work item was last updated."
  updatedAt: Time!
  "Number of user discussions in the work item."
  userDiscussionsCount: Int!
  "Permissions for the current user on the resource"
  userPermissions: WorkItemPermissions!
  "URL of the object."
  webUrl: String
  "Collection of widgets that belong to the work item."
  widgets(
    "Except widgets of the given types."
    exceptTypes: [WorkItemWidgetType!] = null,
    "Only widgets of the given types."
    onlyTypes: [WorkItemWidgetType!] = null
  ): [WorkItemWidget!]
  "Type assigned to the work item."
  workItemType: WorkItemType!
}
"Autogenerated return type of WorkItemAddClosingMergeRequest."
type WorkItemAddClosingMergeRequestPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Closing merge request added to the work item."
  closingMergeRequest: WorkItemClosingMergeRequest
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Work item with new closing merge requests."
  workItem: WorkItem
}
"Autogenerated return type of WorkItemAddLinkedItems."
type WorkItemAddLinkedItemsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Linked items update result message."
  message: String
  "Updated work item."
  workItem: WorkItem
}
"Autogenerated return type of WorkItemBulkUpdate."
type WorkItemBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Number of work items that were successfully updated."
  updatedWorkItemCount: Int
}
type WorkItemClosingMergeRequest {
  "Whether this merge request link was created by referencing the work item on the merge request description, using the closing pattern."
  fromMrDescription: Boolean!
  "Global ID of the closing merge request association."
  id: MergeRequestsClosingIssuesID!
  "Related merge request."
  mergeRequest: MergeRequest
}
"The connection type for WorkItemClosingMergeRequest."
type WorkItemClosingMergeRequestConnection {
  "Number of merge requests that close the work item on merge."
  count: Int
  "A list of edges."
  edges: [WorkItemClosingMergeRequestEdge]
  "A list of nodes."
  nodes: [WorkItemClosingMergeRequest]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type WorkItemClosingMergeRequestEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItemClosingMergeRequest
}
"The connection type for WorkItem."
type WorkItemConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [WorkItemEdge]
  "A list of nodes."
  nodes: [WorkItem]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Autogenerated return type of WorkItemConvert."
type WorkItemConvertPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated work item."
  workItem: WorkItem
}
"Autogenerated return type of WorkItemCreateFromTask."
type WorkItemCreateFromTaskPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "New work item created from task."
  newWorkItem: WorkItem
  "Updated work item."
  workItem: WorkItem
}
"Autogenerated return type of WorkItemCreate."
type WorkItemCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created work item."
  workItem: WorkItem
}
"Autogenerated return type of WorkItemDelete."
type WorkItemDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Namespace the deleted work item belonged to."
  namespace: Namespace
  "Project the deleted work item belonged to. Deprecated in GitLab 16.9: Use `namespace`."
  project: Project @deprecated(reason: "Use `namespace`. Deprecated in GitLab 16.9.")
}
type WorkItemDescriptionTemplate {
  "Category of description template."
  category: String
  "Content of Description Template."
  content: String
  "Name of Description Template."
  name: String
  "ID of the description template project."
  projectId: Int
}
"The connection type for WorkItemDescriptionTemplate."
type WorkItemDescriptionTemplateConnection {
  "A list of edges."
  edges: [WorkItemDescriptionTemplateEdge]
  "A list of nodes."
  nodes: [WorkItemDescriptionTemplate]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type WorkItemDescriptionTemplateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItemDescriptionTemplate
}
"An edge in a connection."
type WorkItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItem
}
"Autogenerated return type of WorkItemExport."
type WorkItemExportPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Export request result message."
  message: String
}
type WorkItemLinkedResource {
  "URL of resource."
  url: String!
}
"The connection type for WorkItemLinkedResource."
type WorkItemLinkedResourceConnection {
  "A list of edges."
  edges: [WorkItemLinkedResourceEdge]
  "A list of nodes."
  nodes: [WorkItemLinkedResource]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type WorkItemLinkedResourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItemLinkedResource
}
"Check permissions for the current user on a work item"
type WorkItemPermissions {
  "If `true`, the user can perform `admin_parent_link` on this resource"
  adminParentLink: Boolean!
  "If `true`, the user can perform `admin_work_item` on this resource"
  adminWorkItem: Boolean!
  "If `true`, the user can perform `admin_work_item_link` on this resource"
  adminWorkItemLink: Boolean!
  "If `true`, the user can perform `clone_work_item` on this resource"
  cloneWorkItem: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `delete_work_item` on this resource"
  deleteWorkItem: Boolean!
  "If `true`, the user can perform `mark_note_as_internal` on this resource"
  markNoteAsInternal: Boolean!
  "If `true`, the user can perform `move_work_item` on this resource"
  moveWorkItem: Boolean!
  "If `true`, the user can perform `read_work_item` on this resource"
  readWorkItem: Boolean!
  "If `true`, the user can perform `report_spam` on this resource"
  reportSpam: Boolean!
  "If `true`, the user can perform `set_work_item_metadata` on this resource"
  setWorkItemMetadata: Boolean!
  "If `true`, the user can perform `summarize_comments` on this resource"
  summarizeComments: Boolean!
  "If `true`, the user can perform `update_work_item` on this resource"
  updateWorkItem: Boolean!
}
type WorkItemRelatedBranch {
  "Path to comparison of branch to default branch."
  comparePath: String
  "Name of the branch."
  name: String!
  "Status of pipeline for the branch."
  pipelineStatus: DetailedStatus
}
"The connection type for WorkItemRelatedBranch."
type WorkItemRelatedBranchConnection {
  "A list of edges."
  edges: [WorkItemRelatedBranchEdge]
  "A list of nodes."
  nodes: [WorkItemRelatedBranch]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"An edge in a connection."
type WorkItemRelatedBranchEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItemRelatedBranch
}
"Autogenerated return type of WorkItemRemoveLinkedItems."
type WorkItemRemoveLinkedItemsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Linked items update result message."
  message: String
  "Updated work item."
  workItem: WorkItem
}
"Represents total number of work items for the represented states"
type WorkItemStateCountsType {
  "Number of work items for the project or group."
  all: Int
  "Number of work items with state CLOSED for the project or group."
  closed: Int
  "Number of work items with state OPENED for the project or group."
  opened: Int
}
"Autogenerated return type of WorkItemSubscribe."
type WorkItemSubscribePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Work item after mutation."
  workItem: WorkItem
}
type WorkItemTimelog {
  "Internal ID of the timelog."
  id: ID!
  "Note where the quick action was executed to add the logged time."
  note: Note
  "Timestamp of when the time tracked was spent at."
  spentAt: Time
  "Summary of how the time was spent."
  summary: String
  "Time spent displayed in seconds."
  timeSpent: Int!
  "User that logged the time."
  user: UserCore!
  "Permissions for the current user on the resource"
  userPermissions: TimelogPermissions!
}
"The connection type for WorkItemTimelog."
type WorkItemTimelogConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [WorkItemTimelogEdge]
  "A list of nodes."
  nodes: [WorkItemTimelog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total time spent in seconds."
  totalSpentTime: BigInt!
}
"An edge in a connection."
type WorkItemTimelogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItemTimelog
}
type WorkItemType {
  "Icon name of the work item type."
  iconName: String
  "Global ID of the work item type."
  id: WorkItemsTypeID!
  "Name of the work item type."
  name: String!
  "Supported conversion types for the work item type. Introduced in GitLab 17.8: **Status**: Experiment."
  supportedConversionTypes: [WorkItemType!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Available widgets for the work item type. Introduced in GitLab 16.7: **Status**: Experiment."
  widgetDefinitions: [WorkItemWidgetDefinition!] @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
}
"The connection type for WorkItemType."
type WorkItemTypeConnection {
  "A list of edges."
  edges: [WorkItemTypeEdge]
  "A list of nodes."
  nodes: [WorkItemType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}
"Represents work item counts for the work item type"
type WorkItemTypeCountsByState {
  "Total number of work items for the represented states."
  countsByState: WorkItemStateCountsType!
  "Work item type."
  workItemType: WorkItemType!
}
"Represents Depth limit reached for the allowed work item type."
type WorkItemTypeDepthLimitReachedByType {
  "Indicates if maximum allowed depth has been reached for the descendant type."
  depthLimitReached: Boolean!
  "Work item type."
  workItemType: WorkItemType!
}
"An edge in a connection."
type WorkItemTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItemType
}
type WorkItemTypesUserPreference {
  "Namespace for the user preference."
  namespace: Namespace!
  "Sort order for work item lists."
  sort: WorkItemSort
  "Type assigned to the work item."
  workItemType: WorkItemType
}
"Autogenerated return type of WorkItemUpdate."
type WorkItemUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated work item."
  workItem: WorkItem
}
"Autogenerated return type of WorkItemUserPreferenceUpdate."
type WorkItemUserPreferenceUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User preferences."
  userPreferences: WorkItemTypesUserPreference
}
"Represents an assignees widget"
type WorkItemWidgetAssignees implements WorkItemWidget {
  "Indicates whether multiple assignees are allowed. Deprecated in GitLab 16.7: Field moved to workItemType widget definition interface."
  allowsMultipleAssignees: Boolean @deprecated(reason: "Field moved to workItemType widget definition interface. Please use `workitemWidgetDefinitionAssignees.allowsMultipleAssignees`. Deprecated in GitLab 16.7.")
  "Assignees of the work item."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Indicates whether the current user can invite members to the work item's project. Deprecated in GitLab 16.7: Field moved to workItemType widget definition interface."
  canInviteMembers: Boolean! @deprecated(reason: "Field moved to workItemType widget definition interface. Please use `workitemWidgetDefinitionAssignees.canInviteMembers`. Deprecated in GitLab 16.7.")
  "Widget type."
  type: WorkItemWidgetType
}
"Represents the emoji reactions widget"
type WorkItemWidgetAwardEmoji implements WorkItemWidget {
  "Emoji reactions on the work item."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Number of downvotes the work item has received."
  downvotes: Int!
  "Path to create a new custom emoji."
  newCustomEmojiPath: String
  "Widget type."
  type: WorkItemWidgetType
  "Number of upvotes the work item has received."
  upvotes: Int!
}
"Represents CRM contacts widget"
type WorkItemWidgetCrmContacts implements WorkItemWidget {
  "Collection of CRM contacts associated with the work item."
  contacts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomerRelationsContactConnection
  "Indicates whether contacts are available to be associated with the work item."
  contactsAvailable: Boolean!
  "Widget type."
  type: WorkItemWidgetType
}
"Represents a todos widget"
type WorkItemWidgetCurrentUserTodos implements CurrentUserTodos & WorkItemWidget {
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Widget type."
  type: WorkItemWidgetType
}
"Represents an assignees widget definition"
type WorkItemWidgetDefinitionAssignees implements WorkItemWidgetDefinition {
  "Indicates whether the current user can invite members to the work item's parent."
  canInviteMembers: Boolean!
  "Widget type."
  type: WorkItemWidgetType!
}
"Represents a generic widget definition"
type WorkItemWidgetDefinitionGeneric implements WorkItemWidgetDefinition {
  "Widget type."
  type: WorkItemWidgetType!
}
"Represents a hierarchy widget definition"
type WorkItemWidgetDefinitionHierarchy implements WorkItemWidgetDefinition {
  "Allowed child types for the work item type."
  allowedChildTypes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemTypeConnection
  "Allowed parent types for the work item type."
  allowedParentTypes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemTypeConnection
  "Widget type."
  type: WorkItemWidgetType!
}
"Represents a description widget"
type WorkItemWidgetDescription implements WorkItemWidget {
  "Description of the work item."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Whether the description has been edited since the work item was created."
  edited: Boolean!
  "Timestamp of when the work item's description was last edited."
  lastEditedAt: Time
  "User that made the last edit to the work item's description."
  lastEditedBy: UserCore
  "Task completion status of the work item."
  taskCompletionStatus: TaskCompletionStatus!
  "Widget type."
  type: WorkItemWidgetType
}
"Represents designs widget"
type WorkItemWidgetDesigns implements WorkItemWidget {
  "Collection of design images associated with the issue."
  designCollection: DesignCollection
  "Widget type."
  type: WorkItemWidgetType
}
"Represents a development widget"
type WorkItemWidgetDevelopment implements WorkItemWidget {
  "Merge requests that will close the work item when merged."
  closingMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemClosingMergeRequestConnection
  "Branches that have referred to the work item, but do not have an associated merge request."
  relatedBranches(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemRelatedBranchConnection
  "Merge requests where the work item has been mentioned. This field can only be resolved for one work item in any single request. Introduced in GitLab 17.6: **Status**: Experiment."
  relatedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Widget type."
  type: WorkItemWidgetType
  "Whether the work item will automatically be closed when a closing merge request is merged."
  willAutoCloseByMergeRequest: Boolean!
}
"Represents email participants widget"
type WorkItemWidgetEmailParticipants implements WorkItemWidget {
  "Collection of email participants associated with the work item."
  emailParticipants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailParticipantTypeConnection
  "Widget type."
  type: WorkItemWidgetType
}
"Represents the error tracking widget"
type WorkItemWidgetErrorTracking implements WorkItemWidget {
  "Error tracking issue id.This field can only be resolved for one work item in any single request."
  identifier: BigInt
  "Stack trace details of the error.This field can only be resolved for one work item in any single request."
  stackTrace(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ErrorTrackingStackTraceConnection
  "Response status of error service.This field can only be resolved for one work item in any single request."
  status: ErrorTrackingStatus
  "Widget type."
  type: WorkItemWidgetType
}
"Represents details about a line of code of the stack trace"
type WorkItemWidgetErrorTrackingStackTraceContext {
  "Line of code."
  line: String
  "Line number of code."
  lineNumber: Int
}
"Represents a hierarchy widget"
type WorkItemWidgetHierarchy implements WorkItemWidget {
  "Ancestors (parents) of the work item."
  ancestors(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection
  "Child work items."
  children(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection
  "Depth limit reached by allowed work item type. Introduced in GitLab 17.4: **Status**: Experiment."
  depthLimitReachedByType: [WorkItemTypeDepthLimitReachedByType!]! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.4.")
  "Indicates if the work item has children."
  hasChildren: Boolean!
  "Indicates if the work item has a parent."
  hasParent: Boolean!
  "Parent work item."
  parent: WorkItem
  "Counts of descendant work items by work item type and state. Introduced in GitLab 17.3: **Status**: Experiment."
  rolledUpCountsByType: [WorkItemTypeCountsByState!]! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.3.")
  "Widget type."
  type: WorkItemWidgetType
}
"Represents the labels widget"
type WorkItemWidgetLabels implements WorkItemWidget {
  "Indicates whether a scoped label is allowed. Deprecated in GitLab 16.7: Field moved to workItemType widget definition interface."
  allowsScopedLabels: Boolean @deprecated(reason: "Field moved to workItemType widget definition interface. Please use `WorkItemWidgetDefinitionLabels.allowsScopedLabels`. Deprecated in GitLab 16.7.")
  "Labels assigned to the work item."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Widget type."
  type: WorkItemWidgetType
}
"Represents the linked items widget"
type WorkItemWidgetLinkedItems implements WorkItemWidget {
  "Linked items for the work item. Introduced in GitLab 16.3: **Status**: Experiment."
  linkedItems(
    "Filter by link type. Supported values: RELATED. Returns all types if omitted."
    filter: WorkItemRelatedLinkType,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LinkedWorkItemTypeConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.3.")
  "Widget type."
  type: WorkItemWidgetType
}
"Represents the linked resources widget"
type WorkItemWidgetLinkedResources implements WorkItemWidget {
  "Resources for the work item."
  linkedResources(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemLinkedResourceConnection
  "Widget type."
  type: WorkItemWidgetType
}
"Represents a milestone widget"
type WorkItemWidgetMilestone implements WorkItemWidget {
  "Milestone of the work item."
  milestone: Milestone
  "Widget type."
  type: WorkItemWidgetType
}
"Represents a notes widget"
type WorkItemWidgetNotes implements WorkItemWidget {
  "Discussion lock attribute of the work item."
  discussionLocked: Boolean
  "Discussions on this work item."
  discussions(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the first _n_ elements from the list."
    first: Int
  ): DiscussionConnection
  "Notes on this work item."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Widget type."
  type: WorkItemWidgetType
}
"Represents the notifications widget"
type WorkItemWidgetNotifications implements WorkItemWidget {
  "Whether the current user is subscribed to notifications on the work item."
  subscribed: Boolean!
  "Widget type."
  type: WorkItemWidgetType
}
"Represents a participants widget"
type WorkItemWidgetParticipants implements WorkItemWidget {
  "Participants in the work item."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Widget type."
  type: WorkItemWidgetType
}
"Represents a start and due date widget"
type WorkItemWidgetStartAndDueDate implements WorkItemWidget {
  "Due date of the work item."
  dueDate: Date
  "Indicates if the work item can use rolled up dates."
  rollUp: Boolean!
  "Start date of the work item."
  startDate: Date
  "Widget type."
  type: WorkItemWidgetType
}
"Represents the time tracking widget on the work item"
type WorkItemWidgetTimeTracking implements WorkItemWidget {
  "Human-readable attributes of the work item."
  humanReadableAttributes: WorkItemWidgetTimeTrackingHumanReadableAttributes
  "Time estimate of the work item."
  timeEstimate: Int
  "Timelogs on the work item."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemTimelogConnection
  "Total time (in seconds) reported as spent on the work item."
  totalTimeSpent: Int
  "Widget type."
  type: WorkItemWidgetType
}
"Represents a time tracking human readable attributes"
type WorkItemWidgetTimeTrackingHumanReadableAttributes {
  "Human-readable time estimate of the work item."
  timeEstimate: String
  "Human-readable total time reported as spent on the work item."
  totalTimeSpent: String
}
"Represents an X.509 certificate."
type X509Certificate {
  "Indicates if the certificate is good or revoked."
  certificateStatus: String!
  "Timestamp of when the certificate was saved."
  createdAt: Time!
  "Email associated with the cerificate."
  email: String!
  "ID of the certificate."
  id: ID!
  "Serial number of the certificate."
  serialNumber: String!
  "Subject of the certificate."
  subject: String!
  "Subject key identifier of the certificate."
  subjectKeyIdentifier: String!
  "Timestamp of when the certificate was last updated."
  updatedAt: Time!
  "Issuer of the certificate."
  x509Issuer: X509Issuer!
}
"Issuer of an X.509 certificate."
type X509Issuer {
  "Timestamp of when the issuer was created."
  createdAt: Time
  "Certificate revokation list of the issuer."
  crlUrl: String
  "ID of the issuer."
  id: ID
  "Subject of the issuer."
  subject: String
  "Subject key identifier of the issuer."
  subjectKeyIdentifier: String
  "Timestamp of when the issuer was last updated."
  updatedAt: Time
}
"X.509 signature for a signed commit"
type X509Signature implements CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "Project of the associated commit."
  project: Project
  "User associated with the key."
  user: UserCore
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
  "Certificate used for the signature."
  x509Certificate: X509Certificate
}
"Autogenerated return type of createContainerProtectionTagRule."
type createContainerProtectionTagRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Protection rule for container image tags after creation. Introduced in GitLab 17.8: **Status**: Experiment."
  containerProtectionTagRule: ContainerProtectionTagRule @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of projectBlobsRemove."
type projectBlobsRemovePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of projectTextReplace."
type projectTextReplacePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}
"Autogenerated return type of workItemsHierarchyReorder."
type workItemsHierarchyReorderPayload {
  "Adjacent work item after mutation."
  adjacentWorkItem: WorkItem
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Work item's parent after mutation."
  parentWorkItem: WorkItem
  "Work item after mutation."
  workItem: WorkItem
}
interface AccessLevelInterface {
  "Returns true when tag rule is for tag immutability. Otherwise, false. Introduced in GitLab 17.11: **Status**: Experiment."
  immutable: Boolean! @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.11.")
  "Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can delete tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForDelete: ContainerProtectionTagRuleAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can push tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForPush: ContainerProtectionTagRuleAccessLevel @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
}
interface AlertManagementIntegration {
  "Whether the endpoint is currently accepting alerts."
  active: Boolean
  "URL at which Prometheus metrics can be queried to populate the metrics dashboard."
  apiUrl: String
  "ID of the integration."
  id: ID!
  "Name of the integration."
  name: String
  "Token used to authenticate alert notification requests."
  token: String
  "Type of integration."
  type: AlertManagementIntegrationType!
  "Endpoint which accepts alert notifications."
  url: String
}
interface BaseDiscussionInterface implements ResolvableInterface {
  "Timestamp of the discussion's creation."
  createdAt: Time!
  "ID of the discussion."
  id: DiscussionID!
  "ID used to reply to the discussion."
  replyId: DiscussionID!
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
}
interface BaseNoteInterface implements ResolvableInterface {
  "User who wrote the note."
  author: UserCore
  "List of emoji reactions associated with the note."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Content of the note."
  body: String!
  "First line of the note content."
  bodyFirstLineHtml: String!
  "GitLab Flavored Markdown rendering of the content of the note."
  bodyHtml: String
  "Timestamp of the note creation."
  createdAt: Time!
  "Timestamp when note was last edited."
  lastEditedAt: Time
  "User who last edited the note."
  lastEditedBy: UserCore
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
  "Timestamp of the note's last activity."
  updatedAt: Time!
  "URL to view the note in the Web UI."
  url: String
}
interface CiVariable {
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}
"Represents signing information for a commit"
interface CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "Project of the associated commit."
  project: Project
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
}
interface CurrentUserTodos {
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
}
interface DesignFields {
  "Diff refs for the design."
  diffRefs: DiffRefs!
  "How the design was changed in the current version."
  event: DesignVersionEvent!
  "Filename of the design."
  filename: String!
  "Full path to the design file."
  fullPath: ID!
  "ID of the design."
  id: ID!
  "URL of the full-sized image."
  image: String!
  "The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated"
  imageV432x230: String
  "Issue the design belongs to."
  issue: Issue!
  "Total count of user-created notes for the design."
  notesCount: Int!
  "Project the design belongs to."
  project: Project!
}
interface Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "SHA of the entry."
  sha: String!
  "Type of tree entry."
  type: EntryType!
}
"""
Returns either a "Group" type for users with :read_group permission, or a "GroupMinimalAccess" type for users with only :read_group_metadata permission.
"""
interface GroupInterface {
  "Avatar URL of the group."
  avatarUrl: String
  "Full name of the group."
  fullName: String
  "ID of the group."
  id: ID
  "Name of the group."
  name: String
  "Web URL of the group."
  webUrl: String
}
interface LabelInterface {
  "Background color of the label."
  color: String!
  "When the label was created."
  createdAt: Time!
  "Description of the label (Markdown rendered as HTML for caching)."
  description: String
  "Text color of the label."
  textColor: String!
  "Content of the label."
  title: String!
  "When the label was last updated."
  updatedAt: Time!
}
interface MemberInterface {
  "GitLab::Access level."
  accessLevel: AccessLevel
  "Date and time the membership was created."
  createdAt: Time
  "User that authorized membership."
  createdBy: UserCore
  "Date and time the membership expires."
  expiresAt: Time
  "ID of the member."
  id: ID!
  "Find a merge request."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Date and time the membership was last updated."
  updatedAt: Time
  "User that is associated with the member object."
  user: UserCore
}
interface NoteableInterface {
  "All commenters on the noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "All discussions on the noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "All notes on this noteable."
  notes(
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
}
"Represents metadata associated with a Package file"
interface PackageFileMetadata {
  "Date of creation."
  createdAt: Time!
  "Date of most recent update."
  updatedAt: Time!
}
interface PipelineInterface {
  "ID of the pipeline."
  id: ID
  "Internal ID of the pipeline."
  iid: String
  "Relative path to the pipeline's page."
  path: String
  "Project the pipeline belongs to."
  project: ProjectInterface
  "Pipeline user."
  user: UserCore
}
interface ProjectInterface {
  "Avatar URL of the project."
  avatarUrl: String
  "Short description of the project."
  description: String
  "Full path of the project."
  fullPath: ID
  "ID of the project."
  id: ID
  "Name of the project without the namespace."
  name: String
  "Name of the project including the namespace."
  nameWithNamespace: String
  "Web URL of the project."
  webUrl: String
}
interface ResolvableInterface {
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
}
interface Service {
  "Indicates if the service is active."
  active: Boolean
  "Type of the service."
  serviceType: ServiceType
  "Class name of the service."
  type: String
}
interface TerraformModuleMetadataSharedFields {
  "Inputs of the module."
  inputs: [TerraformModuleMetadataInput!]
  "Outputs of the module."
  outputs: [TerraformModuleMetadataOutput!]
  "Readme data."
  readme: String
  "GitLab Flavored Markdown rendering of `readme`"
  readmeHtml: String
}
interface Todoable {
  "Name or title of the object."
  name: String
  "URL of the object."
  webUrl: String
}
"Representation of a GitLab user."
interface User implements Todoable {
  "Indicates if the user is active."
  active: Boolean
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the reviewer."
    reviewerUsername: String,
    "Filter by reviewer presence. Incompatible with reviewerUsername."
    reviewerWildcardId: ReviewerWildcardId,
    "Include merge requests the user is assigned to."
    includeAssigned: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Projects the user has contributed to."
  contributedProjects(
    "Search query."
    search: String,
    "Sort contributed projects."
    sort: ProjectSort = LATEST_ACTIVITY_DESC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    "Include personal projects."
    includePersonal: Boolean = false,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in GitLab 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in GitLab 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String,
    "Sort groups by given criteria."
    sort: GroupSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "Indicates if the user is a regular user."
  human: Boolean
  "Global ID of the user."
  id: UserID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in GitLab 16.6: **Status**: Experiment."
  organizations(
    "Search query, which can be for the organization name or a path."
    search: String,
    "When true, returns only organizations solely owned by the user."
    soloOwned: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Search query for title or description."
    search: String,
    """
    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Usernames of the approvers."
    approvedBy: [String!],
    "Filter by release tag."
    releaseTag: String,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Username of the merger."
    mergedBy: String,
    "Filter by your reaction emoji."
    myReactionEmoji: String,
    "List of arguments with inclusive OR."
    or: UnionedMergeRequestFilterInput,
    """
    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    """
    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have the state."
    state: MergeRequestState,
    "Limit result to draft merge requests."
    draft: Boolean,
    """
    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Merge requests created after the timestamp."
    createdAfter: Time,
    "Merge requests created before the timestamp."
    createdBefore: Time,
    "Merge requests deployed after the timestamp."
    deployedAfter: Time,
    "Merge requests deployed before the timestamp."
    deployedBefore: Time,
    "ID of the deployment."
    deploymentId: String,
    "Environment merge requests have been deployed to."
    environmentName: String,
    "Merge requests updated after the timestamp."
    updatedAfter: Time,
    "Merge requests updated before the timestamp."
    updatedBefore: Time,
    "Labels applied to the merge request."
    labelName: [String],
    "Merge requests merged after the date."
    mergedAfter: Time,
    "Merge requests merged before the date."
    mergedBefore: Time,
    "Title of the milestone. Incompatible with milestoneWildcardId."
    milestoneTitle: String,
    "Filter issues by milestone ID wildcard. Incompatible with milestoneTitle."
    milestoneWildcardId: MilestoneWildcardId,
    "Sort merge requests by the criteria."
    sort: MergeRequestSort = created_desc,
    "Merge requests the current user is subscribed to."
    subscribed: SubscriptionStatus,
    """
    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """
    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    """
    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    """
    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    "Merge requests from archived projects."
    includeArchived: Boolean = false,
    "Username of the author."
    authorUsername: String,
    "Username of the assignee."
    assigneeUsername: String,
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Filter by assignee presence. Incompatible with assigneeUsernames and assigneeUsername."
    assigneeWildcardId: AssigneeWildcardId,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum,
    "Type of snippet."
    type: TypeEnum,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Search query."
    search: String,
    "List starred projects by sort order."
    sort: ProjectSort = NAME_ASC,
    "Return only projects where current user has at least the specified access level."
    minAccessLevel: AccessLevelEnum,
    """
    Filter projects by programming language name (case insensitive). For example: "css" or "ruby".
    """
    programmingLanguageName: String,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs for a group."
    groupId: GroupID,
    "List timelogs for a user."
    username: String,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "ID of an author."
    authorId: [ID!],
    "ID of a project."
    projectId: [ID!],
    "ID of a group."
    groupId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Whether the to-do item is snoozed."
    isSnoozed: Boolean,
    "Type of the todo."
    type: [TodoTargetEnum!],
    "Sort todos by given criteria."
    sort: TodoSort,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Type of the user."
  type: UserType!
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in GitLab 15.10: **Status**: Experiment."
  userAchievements(
    "Indicates whether or not achievements hidden from the profile should be included in the result."
    includeHidden: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Preferences for the user."
  userPreferences: UserPreferences
  "Username of the user. Unique within the instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}
interface WorkItemWidget {
  "Widget type."
  type: WorkItemWidgetType
}
interface WorkItemWidgetDefinition {
  "Widget type."
  type: WorkItemWidgetType!
}
"Represents an object that is the target of a CI_JOB_TOKEN allowlist entry"
union CiJobTokenScopeTarget = CiJobTokenAccessibleGroup | CiJobTokenAccessibleProject
"Represents metadata associated with a dependency link"
union DependencyLinkMetadata = NugetDependencyLinkMetadata
"Represents an object that can be the subject of an event."
union EventTargetType = Design | Issue | MergeRequest | Milestone | Note | Project | Snippet | UserCore | WikiPage
"Represents an issuable."
union Issuable = Issue | MergeRequest | WorkItem
union JobNeedUnion = CiBuildNeed | CiJob
"Represents an object that supports notes."
union NoteableType = Design | Issue | MergeRequest
"Represents metadata associated with a Package"
union PackageMetadata = ComposerMetadata | ConanMetadata | MavenMetadata | NugetMetadata | PypiMetadata | TerraformModuleMetadata
"Access level to a resource"
enum AccessLevelEnum {
  "No access."
  NO_ACCESS
  "Minimal access."
  MINIMAL_ACCESS
  "Guest access."
  GUEST
  "Planner access."
  PLANNER
  "Reporter access."
  REPORTER
  "Developer access."
  DEVELOPER
  "Maintainer access."
  MAINTAINER
  "Owner access."
  OWNER
}
"Agent token statuses"
enum AgentTokenStatus {
  "Active agent token."
  ACTIVE
  "Revoked agent token."
  REVOKED
}
"Values for sorting alerts"
enum AlertManagementAlertSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created time by ascending order."
  CREATED_TIME_ASC
  "Created time by descending order."
  CREATED_TIME_DESC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "End time by ascending order."
  ENDED_AT_ASC
  "End time by descending order."
  ENDED_AT_DESC
  "Events count by ascending order."
  EVENT_COUNT_ASC
  "Events count by descending order."
  EVENT_COUNT_DESC
  "Severity from less critical to more critical."
  SEVERITY_ASC
  "Severity from more critical to less critical."
  SEVERITY_DESC
  "Start time by ascending order."
  STARTED_AT_ASC
  "Start time by descending order."
  STARTED_AT_DESC
  "Status by order: `Ignored > Resolved > Acknowledged > Triggered`."
  STATUS_ASC
  "Status by order: `Triggered > Acknowledged > Resolved > Ignored`."
  STATUS_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Created time by ascending order."
  UPDATED_TIME_ASC
  "Created time by descending order."
  UPDATED_TIME_DESC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"Filters the alerts based on given domain"
enum AlertManagementDomainFilter {
  "Alerts for operations domain."
  operations
  "Alerts for threat monitoring domain. Deprecated in GitLab 15.0: Network policies are deprecated and will be removed in GitLab 16.0."
  threat_monitoring @deprecated(reason: "Network policies are deprecated and will be removed in GitLab 16.0. Deprecated in GitLab 15.0.")
}
"Values of types of integrations"
enum AlertManagementIntegrationType {
  "Prometheus integration."
  PROMETHEUS
  "Integration with any monitoring tool."
  HTTP
}
"Alert severity values"
enum AlertManagementSeverity {
  "Critical severity"
  CRITICAL
  "High severity"
  HIGH
  "Medium severity"
  MEDIUM
  "Low severity"
  LOW
  "Info severity"
  INFO
  "Unknown severity"
  UNKNOWN
}
"Alert status values"
enum AlertManagementStatus {
  "Investigation has not started."
  TRIGGERED
  "Someone is actively investigating the problem."
  ACKNOWLEDGED
  "The problem has been addressed."
  RESOLVED
  "No action will be taken."
  IGNORED
}
enum AnalyticsAggregationPeriod {
  "Daily aggregation."
  DAY
  "Weekly aggregation."
  WEEK
  "Monthly aggregation."
  MONTH
}
"Assignee ID wildcard values"
enum AssigneeWildcardId {
  "No assignee is assigned."
  NONE
  "An assignee is assigned."
  ANY
}
"Auto stop setting."
enum AutoStopSetting {
  "Always"
  ALWAYS
  "With Action"
  WITH_ACTION
}
"User availability status"
enum AvailabilityEnum {
  "Not Set"
  NOT_SET
  "Busy"
  BUSY
}
"Available fields to be exported as CSV"
enum AvailableExportFields {
  "Unique identifier."
  ID
  "Title."
  TITLE
  "Description."
  DESCRIPTION
  "Type of the work item."
  TYPE
  "Author name."
  AUTHOR
  "Author username."
  AUTHOR_USERNAME
  "Date of creation."
  CREATED_AT
}
"Types of blob viewers"
enum BlobViewersType {
  "Rich blob viewers type."
  rich
  "Simple blob viewers type."
  simple
  "Auxiliary blob viewers type."
  auxiliary
}
"Values for scoping catalog resources"
enum CiCatalogResourceScope {
  "All catalog resources visible to the current user."
  ALL
  "Catalog resources belonging to authorized namespaces of the user."
  NAMESPACES
}
"Values for sorting catalog resources"
enum CiCatalogResourceSort {
  "Name by ascending order."
  NAME_ASC
  "Name by descending order."
  NAME_DESC
  "Latest release date by ascending order."
  LATEST_RELEASED_AT_ASC
  "Latest release date by descending order."
  LATEST_RELEASED_AT_DESC
  "Created date by ascending order."
  CREATED_ASC
  "Created date by descending order."
  CREATED_DESC
  "Star count by ascending order."
  STAR_COUNT_ASC
  "Star count by descending order."
  STAR_COUNT_DESC
  "Last 30-day usage count by ascending order."
  USAGE_COUNT_ASC
  "Last 30-day usage count by descending order."
  USAGE_COUNT_DESC
}
enum CiCatalogResourceVerificationLevel {
  "The resource is Gitlab Maintained"
  GITLAB_MAINTAINED
  "The resource is Gitlab Partner Maintained"
  GITLAB_PARTNER_MAINTAINED
  "The resource is Verified Creator Maintained"
  VERIFIED_CREATOR_MAINTAINED
  "The resource is Unverified"
  UNVERIFIED
}
"Include type."
enum CiConfigIncludeType {
  "Remote include."
  remote
  "Local include."
  local
  "Project file include."
  file
  "Template include."
  template
  "Component include."
  component
}
"Values for YAML processor result"
enum CiConfigStatus {
  "Configuration file is valid."
  VALID
  "Configuration file is not valid."
  INVALID
}
"Deploy freeze period status"
enum CiFreezePeriodStatus {
  "Freeze period is active."
  ACTIVE
  "Freeze period is inactive."
  INACTIVE
}
"Values for sorting inherited variables"
enum CiGroupVariablesSort {
  "Created at descending order."
  CREATED_DESC
  "Created at ascending order."
  CREATED_ASC
  "Key by descending order."
  KEY_DESC
  "Key by ascending order."
  KEY_ASC
}
"Available input types"
enum CiInputsType {
  "Array input"
  ARRAY
  "Boolean input"
  BOOLEAN
  "Number input"
  NUMBER
  "String input"
  STRING
}
enum CiJobKind {
  "Standard CI job."
  BUILD
  "Bridge CI job connecting a parent and child pipeline."
  BRIDGE
}
enum CiJobSource {
  "A job initiated by scan execution policy."
  SCAN_EXECUTION_POLICY
  "A job initiated by pipeline execution policy."
  PIPELINE_EXECUTION_POLICY
  "A job initiated by unknown."
  UNKNOWN
  "A job initiated by push."
  PUSH
  "A job initiated by web."
  WEB
  "A job initiated by trigger."
  TRIGGER
  "A job initiated by schedule."
  SCHEDULE
  "A job initiated by api."
  API
  "A job initiated by external."
  EXTERNAL
  "A job initiated by pipeline."
  PIPELINE
  "A job initiated by chat."
  CHAT
  "A job initiated by webide."
  WEBIDE
  "A job initiated by merge request event."
  MERGE_REQUEST_EVENT
  "A job initiated by external pull request event."
  EXTERNAL_PULL_REQUEST_EVENT
  "A job initiated by parent pipeline."
  PARENT_PIPELINE
  "A job initiated by ondemand dast scan."
  ONDEMAND_DAST_SCAN
  "A job initiated by ondemand dast validation."
  ONDEMAND_DAST_VALIDATION
  "A job initiated by security orchestration policy."
  SECURITY_ORCHESTRATION_POLICY
  "A job initiated by container registry push."
  CONTAINER_REGISTRY_PUSH
  "A job initiated by duo workflow."
  DUO_WORKFLOW
  "A job initiated by pipeline execution policy schedule."
  PIPELINE_EXECUTION_POLICY_SCHEDULE
}
enum CiJobStatus {
  "A job that is created."
  CREATED
  "A job that is waiting for resource."
  WAITING_FOR_RESOURCE
  "A job that is preparing."
  PREPARING
  "A job that is waiting for callback."
  WAITING_FOR_CALLBACK
  "A job that is pending."
  PENDING
  "A job that is running."
  RUNNING
  "A job that is success."
  SUCCESS
  "A job that is failed."
  FAILED
  "A job that is canceling."
  CANCELING
  "A job that is canceled."
  CANCELED
  "A job that is skipped."
  SKIPPED
  "A job that is manual."
  MANUAL
  "A job that is scheduled."
  SCHEDULED
}
"Direction of access."
enum CiJobTokenScopeDirection {
  "Job token scope project can access target project in the outbound allowlist."
  OUTBOUND
  "Target projects in the inbound allowlist can access the scope project through their job tokens."
  INBOUND
}
"CI_JOB_TOKEN policy"
enum CiJobTokenScopePolicies {
  "Read Deployments"
  READ_DEPLOYMENTS
  "Admin Deployments"
  ADMIN_DEPLOYMENTS
  "Read Environments"
  READ_ENVIRONMENTS
  "Admin Environments"
  ADMIN_ENVIRONMENTS
  "Read Jobs"
  READ_JOBS
  "Admin Jobs"
  ADMIN_JOBS
  "Read Packages"
  READ_PACKAGES
  "Admin Packages"
  ADMIN_PACKAGES
  "Read Pipelines"
  READ_PIPELINES
  "Admin Pipelines"
  ADMIN_PIPELINES
  "Read Releases"
  READ_RELEASES
  "Admin Releases"
  ADMIN_RELEASES
  "Read Secure Files"
  READ_SECURE_FILES
  "Admin Secure Files"
  ADMIN_SECURE_FILES
  "Read Terraform State"
  READ_TERRAFORM_STATE
  "Admin Terraform State"
  ADMIN_TERRAFORM_STATE
}
"The status of a pipeline creation"
enum CiPipelineCreationStatus {
  "The pipeline creation is failed"
  FAILED
  "The pipeline creation is in progress"
  IN_PROGRESS
  "The pipeline creation is succeeded"
  SUCCEEDED
}
"Ci Pipeline sources enum"
enum CiPipelineSources {
  "Pipeline created by an unknown event"
  UNKNOWN
  "Pipeline created by a push event"
  PUSH
  "Pipeline created by a web event"
  WEB
  "Pipeline created by a trigger event"
  TRIGGER
  "Pipeline created by a schedule event"
  SCHEDULE
  "Pipeline created by an API event"
  API
  "Pipeline created by an external event"
  EXTERNAL
  "Pipeline created by a pipeline event"
  PIPELINE
  "Pipeline created by a chat event"
  CHAT
  "Pipeline created by a webide event"
  WEBIDE
  "Pipeline created by a merge request event"
  MERGE_REQUEST_EVENT
  "Pipeline created by an external pull request event"
  EXTERNAL_PULL_REQUEST_EVENT
  "Pipeline created by a parent pipeline event"
  PARENT_PIPELINE
  "Pipeline created by an ondemand dast scan event"
  ONDEMAND_DAST_SCAN
  "Pipeline created by an ondemand dast validation event"
  ONDEMAND_DAST_VALIDATION
  "Pipeline created by a security orchestration policy event"
  SECURITY_ORCHESTRATION_POLICY
  "Pipeline created by a container registry push event"
  CONTAINER_REGISTRY_PUSH
  "Pipeline created by a duo workflow event"
  DUO_WORKFLOW
  "Pipeline created by a pipeline execution policy schedule event"
  PIPELINE_EXECUTION_POLICY_SCHEDULE
}
enum CiRunnerAccessLevel {
  "A runner that is not protected."
  NOT_PROTECTED
  "A runner that is ref protected."
  REF_PROTECTED
}
enum CiRunnerCreationMethod {
  "Applies to a runner that was created by a runner registration token."
  REGISTRATION_TOKEN
  "Applies to a runner that was created by an authenticated user."
  AUTHENTICATED_USER
}
enum CiRunnerCreationState {
  "Applies to a runner that has been created, but is not yet registered and running."
  STARTED
  "Applies to a runner that has been registered and has polled for CI/CD jobs at least once."
  FINISHED
}
enum CiRunnerJobExecutionStatus {
  "Runner is idle. Introduced in GitLab 15.7: **Status**: Experiment."
  IDLE @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.7.")
  "Runner is busy. Introduced in GitLab 17.2: **Status**: Experiment."
  ACTIVE @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
}
"Values for filtering runners in namespaces."
enum CiRunnerMembershipFilter {
  "Include runners that have a direct relationship."
  DIRECT
  "Include runners that have either a direct or inherited relationship. These runners can be specific to a project or a group."
  DESCENDANTS
  "Include all runners. This list includes runners for all projects in the group and subgroups, as well as for the parent groups and instance. Introduced in GitLab 15.5: **Status**: Experiment."
  ALL_AVAILABLE @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.5.")
}
"Values for sorting runners"
enum CiRunnerSort {
  "Ordered by contacted_at in ascending order."
  CONTACTED_ASC
  "Ordered by contacted_at in descending order."
  CONTACTED_DESC
  "Ordered by created_at in ascending order."
  CREATED_ASC
  "Ordered by created_at in descending order."
  CREATED_DESC
  "Ordered by token_expires_at in ascending order."
  TOKEN_EXPIRES_AT_ASC
  "Ordered by token_expires_at in descending order."
  TOKEN_EXPIRES_AT_DESC
}
enum CiRunnerStatus {
  "Runner that contacted this instance within the last 2 hours."
  ONLINE
  "Runner that has not contacted this instance within the last 2 hours. Will be considered `STALE` if offline for more than 7 days."
  OFFLINE
  "Runner that has not contacted this instance within the last 7 days."
  STALE
  "Runner that has never contacted the instance."
  NEVER_CONTACTED
}
enum CiRunnerType {
  "A runner that is instance type."
  INSTANCE_TYPE
  "A runner that is group type."
  GROUP_TYPE
  "A runner that is project type."
  PROJECT_TYPE
}
enum CiRunnerUpgradeStatus {
  "Runner version is not valid."
  INVALID
  "Upgrade is not available for the runner."
  NOT_AVAILABLE
  "Upgrade is available for the runner."
  AVAILABLE
  "Upgrade is available and recommended for the runner."
  RECOMMENDED
}
"Values for sorting variables"
enum CiVariableSort {
  "Sorted by key in ascending order."
  KEY_ASC
  "Sorted by key in descending order."
  KEY_DESC
}
enum CiVariableType {
  "Env var type."
  ENV_VAR
  "File type."
  FILE
}
enum CodeQualityDegradationSeverity {
  "Code Quality degradation has a status of blocker."
  BLOCKER
  "Code Quality degradation has a status of critical."
  CRITICAL
  "Code Quality degradation has a status of major."
  MAJOR
  "Code Quality degradation has a status of minor."
  MINOR
  "Code Quality degradation has a status of info."
  INFO
  "Code Quality degradation has a status of unknown."
  UNKNOWN
}
"Represents the generation status of the compared codequality report."
enum CodequalityReportsComparerReportGenerationStatus {
  "Report was generated."
  PARSED
  "Report is being generated."
  PARSING
  "An error happened while generating the report."
  ERROR
}
"Represents the state of the code quality report."
enum CodequalityReportsComparerStatus {
  "No degradations found in the head pipeline report."
  SUCCESS
  "Report generated and there are new code quality degradations."
  FAILED
  "Head report or base report not found."
  NOT_FOUND
}
"Mode of a commit action"
enum CommitActionMode {
  "Create command."
  CREATE
  "Delete command."
  DELETE
  "Move command."
  MOVE
  "Update command."
  UPDATE
  "Chmod command."
  CHMOD
}
enum CommitEncoding {
  "Text encoding."
  TEXT
  "Base64 encoding."
  BASE64
}
"Conan file types"
enum ConanMetadatumFileTypeEnum {
  "A recipe file type."
  RECIPE_FILE
  "A package file type."
  PACKAGE_FILE
}
"Values for sorting contacts"
enum ContactSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
  "Description in ascending order."
  DESCRIPTION_ASC
  "Description in descending order."
  DESCRIPTION_DESC
  "Email in ascending order."
  EMAIL_ASC
  "Email in descending order."
  EMAIL_DESC
  "First name in ascending order."
  FIRST_NAME_ASC
  "First name in descending order."
  FIRST_NAME_DESC
  "Last name in ascending order."
  LAST_NAME_ASC
  "Last name in descending order."
  LAST_NAME_DESC
  "Organization in ascending order."
  ORGANIZATION_ASC
  "Organization in descending order."
  ORGANIZATION_DESC
  "Phone in ascending order."
  PHONE_ASC
  "Phone in descending order."
  PHONE_DESC
}
enum ContainerExpirationPolicyCadenceEnum {
  "Every day"
  EVERY_DAY
  "Every week"
  EVERY_WEEK
  "Every two weeks"
  EVERY_TWO_WEEKS
  "Every month"
  EVERY_MONTH
  "Every three months"
  EVERY_THREE_MONTHS
}
enum ContainerExpirationPolicyKeepEnum {
  "1 tag per image name"
  ONE_TAG
  "5 tags per image name"
  FIVE_TAGS
  "10 tags per image name"
  TEN_TAGS
  "25 tags per image name"
  TWENTY_FIVE_TAGS
  "50 tags per image name"
  FIFTY_TAGS
  "100 tags per image name"
  ONE_HUNDRED_TAGS
}
enum ContainerExpirationPolicyOlderThanEnum {
  "7 days until tags are automatically removed"
  SEVEN_DAYS
  "14 days until tags are automatically removed"
  FOURTEEN_DAYS
  "30 days until tags are automatically removed"
  THIRTY_DAYS
  "60 days until tags are automatically removed"
  SIXTY_DAYS
  "90 days until tags are automatically removed"
  NINETY_DAYS
}
"Access level for a container repository protection rule resource"
enum ContainerProtectionRepositoryRuleAccessLevel {
  "Maintainer access."
  MAINTAINER
  "Owner access."
  OWNER
  "Admin access."
  ADMIN
}
"Access level of a container registry tag protection rule resource"
enum ContainerProtectionTagRuleAccessLevel {
  "Maintainer access. Introduced in GitLab 17.8: **Status**: Experiment."
  MAINTAINER @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Owner access. Introduced in GitLab 17.8: **Status**: Experiment."
  OWNER @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
  "Admin access. Introduced in GitLab 17.8: **Status**: Experiment."
  ADMIN @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.8.")
}
"Status of the tags cleanup of a container repository"
enum ContainerRepositoryCleanupStatus {
  "Tags cleanup is not scheduled. This is the default state."
  UNSCHEDULED
  "Tags cleanup is scheduled and is going to be executed shortly."
  SCHEDULED
  "Tags cleanup has been partially executed. There are still remaining tags to delete."
  UNFINISHED
  "Tags cleanup is ongoing."
  ONGOING
}
"Values for sorting container repositories"
enum ContainerRepositorySort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Name by ascending order."
  NAME_ASC
  "Name by descending order."
  NAME_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"Status of a container repository"
enum ContainerRepositoryStatus {
  "Delete Scheduled status."
  DELETE_SCHEDULED
  "Delete Failed status."
  DELETE_FAILED
  "Delete Ongoing status."
  DELETE_ONGOING
}
"Values for sorting tags"
enum ContainerRepositoryTagSort {
  "Ordered by name in ascending order."
  NAME_ASC
  "Ordered by name in descending order."
  NAME_DESC
  "Ordered by published_at in ascending order. Only available for GitLab.com."
  PUBLISHED_AT_ASC
  "Ordered by published_at in descending order. Only available for GitLab.com."
  PUBLISHED_AT_DESC
}
enum CustomerRelationsContactState {
  "All available contacts."
  all
  "Active contacts."
  active
  "Inactive contacts."
  inactive
}
enum CustomerRelationsOrganizationState {
  "All available organizations."
  all
  "Active organizations."
  active
  "Inactive organizations."
  inactive
}
enum DependencyProxyManifestStatus {
  "Dependency proxy manifest has a status of default."
  DEFAULT
  "Dependency proxy manifest has a status of pending_destruction."
  PENDING_DESTRUCTION
  "Dependency proxy manifest has a status of processing."
  PROCESSING
  "Dependency proxy manifest has a status of error."
  ERROR
}
"All deployment statuses."
enum DeploymentStatus {
  "A deployment that is created."
  CREATED
  "A deployment that is running."
  RUNNING
  "A deployment that is success."
  SUCCESS
  "A deployment that is failed."
  FAILED
  "A deployment that is canceled."
  CANCELED
  "A deployment that is skipped."
  SKIPPED
  "A deployment that is blocked."
  BLOCKED
}
"All environment deployment tiers."
enum DeploymentTier {
  "Production."
  PRODUCTION
  "Staging."
  STAGING
  "Testing."
  TESTING
  "Development."
  DEVELOPMENT
  "Other."
  OTHER
}
"Copy state of a DesignCollection"
enum DesignCollectionCopyState {
  "The DesignCollection has no copy in progress"
  READY
  "The DesignCollection is being copied"
  IN_PROGRESS
  "The DesignCollection encountered an error during a copy"
  ERROR
}
"Mutation event of a design within a version"
enum DesignVersionEvent {
  "No change."
  NONE
  "A creation event"
  CREATION
  "A modification event"
  MODIFICATION
  "A deletion event"
  DELETION
}
"Detailed representation of whether a GitLab merge request can be merged."
enum DetailedMergeStatus {
  "Merge status has not been checked."
  UNCHECKED
  "Currently checking for mergeability."
  CHECKING
  "Branch can be merged."
  MERGEABLE
  "Source branch exists and contains commits."
  COMMITS_STATUS
  "Pipeline must succeed before merging."
  CI_MUST_PASS
  "Pipeline is still running."
  CI_STILL_RUNNING
  "Discussions must be resolved before merging."
  DISCUSSIONS_NOT_RESOLVED
  "Merge request must not be draft before merging."
  DRAFT_STATUS
  "Merge request must be open before merging."
  NOT_OPEN
  "Merge request must be approved before merging."
  NOT_APPROVED
  "Merge request dependencies must be merged."
  BLOCKED_STATUS
  "Status checks must pass."
  EXTERNAL_STATUS_CHECKS
  "Merge request diff is being created."
  PREPARING
  "Either the title or description must reference a Jira issue."
  JIRA_ASSOCIATION
  "There are conflicts between the source and target branches."
  CONFLICT
  "Merge request needs to be rebased."
  NEED_REBASE
  "Merge request approvals currently syncing."
  APPROVALS_SYNCING
  "Merge request includes locked paths."
  LOCKED_PATHS
  "Merge request includes locked LFS files."
  LOCKED_LFS_FILES
  "Merge request may not be merged until after the specified time."
  MERGE_TIME
  "All policy rules must be satisfied."
  SECURITY_POLICIES_VIOLATIONS
}
"Type of file the position refers to"
enum DiffPositionType {
  "Text file."
  text
  "An image."
  image
  "Unknown file type."
  file
}
"Type of a tree entry"
enum EntryType {
  "Directory tree type."
  tree
  "File tree type."
  blob
  "Commit tree type."
  commit
}
"Status of the error tracking service"
enum ErrorTrackingStatus {
  "Successfuly fetch the stack trace."
  SUCCESS
  "Error tracking service respond with an error."
  ERROR
  "Sentry issue not found."
  NOT_FOUND
  "Error tracking service is not ready."
  RETRY
}
"Event action"
enum EventAction {
  "Created action"
  CREATED
  "Updated action"
  UPDATED
  "Closed action"
  CLOSED
  "Reopened action"
  REOPENED
  "Pushed action"
  PUSHED
  "Commented action"
  COMMENTED
  "Merged action"
  MERGED
  "Joined action"
  JOINED
  "Left action"
  LEFT
  "Destroyed action"
  DESTROYED
  "Expired action"
  EXPIRED
  "Approved action"
  APPROVED
}
"Event target"
enum EventTarget {
  "All events"
  ALL
  "Push events"
  PUSH
  "Merged events"
  MERGED
  "Issue events"
  ISSUE
  "Comments events"
  COMMENTS
  "Team events"
  TEAM
  "Wiki events"
  WIKI
  "Designs events"
  DESIGNS
}
"Values for status of the Web IDE Extension Marketplace opt-in for the user"
enum ExtensionsMarketplaceOptInStatus {
  "Web IDE Extension Marketplace opt-in status: UNSET."
  UNSET
  "Web IDE Extension Marketplace opt-in status: ENABLED."
  ENABLED
  "Web IDE Extension Marketplace opt-in status: DISABLED."
  DISABLED
}
"Group member relation"
enum GroupMemberRelation {
  "Members in the group itself."
  DIRECT
  "Members in the group's ancestor groups."
  INHERITED
  "Members in the group's subgroups."
  DESCENDANTS
  "Invited group's members."
  SHARED_FROM_GROUPS
}
"User permission on groups"
enum GroupPermission {
  "Groups where the user can create projects."
  CREATE_PROJECTS
  "Groups where the user can transfer projects to."
  TRANSFER_PROJECTS
  "Groups where the user can import projects to."
  IMPORT_PROJECTS
}
"Values for sorting releases belonging to a group"
enum GroupReleaseSort {
  "Released at by descending order."
  RELEASED_AT_DESC
  "Released at by ascending order."
  RELEASED_AT_ASC
}
"Values for sorting groups"
enum GroupSort {
  "Most similar to the search query."
  SIMILARITY
  "Sort by name, ascending order."
  NAME_ASC
  "Sort by name, descending order."
  NAME_DESC
  "Sort by path, ascending order."
  PATH_ASC
  "Sort by path, descending order."
  PATH_DESC
  "Sort by ID, ascending order."
  ID_ASC
  "Sort by ID, descending order."
  ID_DESC
}
"Import source"
enum ImportSource {
  "Not imported"
  NONE
  "Gitlab Migration"
  GITLAB_MIGRATION
  "Gitlab Project"
  GITLAB_PROJECT
  "Gitlab Group"
  GITLAB_GROUP
  "Github"
  GITHUB
  "Bitbucket"
  BITBUCKET
  "Bitbucket Server"
  BITBUCKET_SERVER
  "Fogbugz"
  FOGBUGZ
  "Gitea"
  GITEA
  "Git"
  GIT
  "Manifest"
  MANIFEST
  "Custom Template"
  CUSTOM_TEMPLATE
}
enum ImportSourceUserStatus {
  "An import source user mapping that is pending reassignment."
  PENDING_REASSIGNMENT
  "An import source user mapping that is awaiting approval."
  AWAITING_APPROVAL
  "An import source user mapping that is reassignment in progress."
  REASSIGNMENT_IN_PROGRESS
  "An import source user mapping that is rejected."
  REJECTED
  "An import source user mapping that is failed."
  FAILED
  "An import source user mapping that is completed."
  COMPLETED
  "An import source user mapping that is keep as placeholder."
  KEEP_AS_PLACEHOLDER
}
"Integration Names"
enum IntegrationType {
  "Beyond Identity."
  BEYOND_IDENTITY
}
"Fields to perform the search in"
enum IssuableSearchableField {
  "Search in title field."
  TITLE
  "Search in description field."
  DESCRIPTION
}
"Incident severity"
enum IssuableSeverity {
  "Unknown severity"
  UNKNOWN
  "Low severity"
  LOW
  "Medium severity"
  MEDIUM
  "High severity"
  HIGH
  "Critical severity"
  CRITICAL
}
"State of a GitLab issue or merge request"
enum IssuableState {
  "In open state."
  opened
  "In closed state."
  closed
  "Discussion has been locked."
  locked
  "All available."
  all
}
"Values for subscribing and unsubscribing from issuables"
enum IssuableSubscriptionEvent {
  "Subscribe to an issuable."
  SUBSCRIBE
  "Unsubscribe from an issuable."
  UNSUBSCRIBE
}
"Issue escalation status values"
enum IssueEscalationStatus {
  "Investigation has not started."
  TRIGGERED
  "Someone is actively investigating the problem."
  ACKNOWLEDGED
  "The problem has been addressed."
  RESOLVED
  "No action will be taken."
  IGNORED
}
"Values for sorting issues"
enum IssueSort {
  "Closed time by ascending order."
  CLOSED_AT_ASC
  "Closed time by descending order."
  CLOSED_AT_DESC
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Due date by ascending order."
  DUE_DATE_ASC
  "Due date by descending order."
  DUE_DATE_DESC
  "Status from triggered to resolved."
  ESCALATION_STATUS_ASC
  "Status from resolved to triggered."
  ESCALATION_STATUS_DESC
  "Label priority by ascending order."
  LABEL_PRIORITY_ASC
  "Label priority by descending order."
  LABEL_PRIORITY_DESC
  "Milestone due date by ascending order."
  MILESTONE_DUE_ASC
  "Milestone due date by descending order."
  MILESTONE_DUE_DESC
  """
  Number of upvotes (awarded "thumbs up" emoji) by ascending order.
  """
  POPULARITY_ASC
  """
  Number of upvotes (awarded "thumbs up" emoji) by descending order.
  """
  POPULARITY_DESC
  "Priority by ascending order."
  PRIORITY_ASC
  "Priority by descending order."
  PRIORITY_DESC
  "Relative position by ascending order."
  RELATIVE_POSITION_ASC
  "Severity from less critical to more critical."
  SEVERITY_ASC
  "Severity from more critical to less critical."
  SEVERITY_DESC
  "Title by ascending order."
  TITLE_ASC
  "Title by descending order."
  TITLE_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"State of a GitLab issue"
enum IssueState {
  "In open state."
  opened
  "In closed state."
  closed
  "Discussion has been locked."
  locked
  "All available."
  all
}
"Values for issue state events"
enum IssueStateEvent {
  "Reopens the issue."
  REOPEN
  "Closes the issue."
  CLOSE
}
"Issue type"
enum IssueType {
  "Issue issue type"
  ISSUE
  "Incident issue type"
  INCIDENT
  "Test Case issue type"
  TEST_CASE
  "Requirement issue type"
  REQUIREMENT
  "Task issue type"
  TASK
  "Ticket issue type"
  TICKET
  "Objective issue type. Available only when feature flag `okrs_mvc` is enabled. Introduced in GitLab 15.6: **Status**: Experiment."
  OBJECTIVE @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.6.")
  "Key Result issue type. Available only when feature flag `okrs_mvc` is enabled. Introduced in GitLab 15.7: **Status**: Experiment."
  KEY_RESULT @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 15.7.")
  "Epic issue type. Available only when feature epics is available and the feature flag `work_item_epics` is enabled. Introduced in GitLab 16.7: **Status**: Experiment."
  EPIC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.7.")
}
enum JobArtifactFileType {
  "ARCHIVE job artifact file type."
  ARCHIVE
  "METADATA job artifact file type."
  METADATA
  "TRACE job artifact file type."
  TRACE
  "JUNIT job artifact file type."
  JUNIT
  "METRICS job artifact file type."
  METRICS
  "METRICS REFEREE job artifact file type."
  METRICS_REFEREE
  "NETWORK REFEREE job artifact file type."
  NETWORK_REFEREE
  "DOTENV job artifact file type."
  DOTENV
  "COBERTURA job artifact file type."
  COBERTURA
  "JACOCO job artifact file type."
  JACOCO
  "CLUSTER APPLICATIONS job artifact file type."
  CLUSTER_APPLICATIONS
  "LSIF job artifact file type."
  LSIF
  "CYCLONEDX job artifact file type."
  CYCLONEDX
  "ANNOTATIONS job artifact file type."
  ANNOTATIONS
  "REPOSITORY XRAY job artifact file type."
  REPOSITORY_XRAY
  "SAST job artifact file type."
  SAST
  "SECRET DETECTION job artifact file type."
  SECRET_DETECTION
  "DEPENDENCY SCANNING job artifact file type."
  DEPENDENCY_SCANNING
  "CONTAINER SCANNING job artifact file type."
  CONTAINER_SCANNING
  "CLUSTER IMAGE SCANNING job artifact file type."
  CLUSTER_IMAGE_SCANNING
  "DAST job artifact file type."
  DAST
  "LICENSE SCANNING job artifact file type."
  LICENSE_SCANNING
  "ACCESSIBILITY job artifact file type."
  ACCESSIBILITY
  "CODE QUALITY job artifact file type."
  CODEQUALITY
  "PERFORMANCE job artifact file type."
  PERFORMANCE
  "BROWSER PERFORMANCE job artifact file type."
  BROWSER_PERFORMANCE
  "LOAD PERFORMANCE job artifact file type."
  LOAD_PERFORMANCE
  "TERRAFORM job artifact file type."
  TERRAFORM
  "REQUIREMENTS job artifact file type."
  REQUIREMENTS
  "REQUIREMENTS V2 job artifact file type."
  REQUIREMENTS_V2
  "COVERAGE FUZZING job artifact file type."
  COVERAGE_FUZZING
  "API FUZZING job artifact file type."
  API_FUZZING
}
"List of fields where the provided searchTerm should be looked up"
enum LabelSearchFieldList {
  "Search in the label title."
  TITLE
  "Search in the label description."
  DESCRIPTION
}
"Possible identifier types for a measurement"
enum MeasurementIdentifier {
  "Project count."
  PROJECTS
  "User count."
  USERS
  "Issue count."
  ISSUES
  "Merge request count."
  MERGE_REQUESTS
  "Group count."
  GROUPS
  "Pipeline count."
  PIPELINES
  "Pipeline count with success status."
  PIPELINES_SUCCEEDED
  "Pipeline count with failed status."
  PIPELINES_FAILED
  "Pipeline count with canceled status."
  PIPELINES_CANCELED
  "Pipeline count with skipped status."
  PIPELINES_SKIPPED
}
"Access level of a group or project member"
enum MemberAccessLevel {
  "The Guest role is for users who need visibility into a project or group but should not have the ability to make changes, such as external stakeholders."
  GUEST
  "The Planner role is suitable for team members who need to manage projects and track work items but do not need to contribute code."
  PLANNER
  "The Reporter role is suitable for team members who need to stay informed about a project or group but do not actively contribute code."
  REPORTER
  "The Developer role gives users access to contribute code while restricting sensitive administrative actions."
  DEVELOPER
  "The Maintainer role is primarily used for managing code reviews, approvals, and administrative settings for projects. This role can also manage project memberships."
  MAINTAINER
  "The Owner role is typically assigned to the individual or team responsible for managing and maintaining the group or creating the project. This role has the highest level of administrative control, and can manage all aspects of the group or project, including managing other Owners."
  OWNER
}
"Values for sorting members"
enum MemberSort {
  "Access level ascending order."
  ACCESS_LEVEL_ASC
  "Access level descending order."
  ACCESS_LEVEL_DESC
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "User's full name ascending order."
  USER_FULL_NAME_ASC
  "User's full name descending order."
  USER_FULL_NAME_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"New state to apply to a merge request."
enum MergeRequestNewState {
  "Open the merge request if it is closed."
  OPEN
  "Close the merge request if it is open."
  CLOSED
}
"State of a review of a GitLab merge request."
enum MergeRequestReviewState {
  "Awaiting review from merge request reviewer."
  UNREVIEWED
  "Merge request reviewer has reviewed."
  REVIEWED
  "Merge request reviewer has requested changes."
  REQUESTED_CHANGES
  "Merge request reviewer has approved the changes."
  APPROVED
  "Merge request reviewer removed their approval of the changes."
  UNAPPROVED
  "Merge request reviewer has started a review."
  REVIEW_STARTED
}
"Values for sorting merge requests"
enum MergeRequestSort {
  "Closed time by ascending order."
  CLOSED_AT_ASC
  "Closed time by descending order."
  CLOSED_AT_DESC
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Label priority by ascending order."
  LABEL_PRIORITY_ASC
  "Label priority by descending order."
  LABEL_PRIORITY_DESC
  "Merge time by ascending order."
  MERGED_AT_ASC
  "Merge time by descending order."
  MERGED_AT_DESC
  "Milestone due date by ascending order."
  MILESTONE_DUE_ASC
  "Milestone due date by descending order."
  MILESTONE_DUE_DESC
  """
  Number of upvotes (awarded "thumbs up" emoji) by ascending order.
  """
  POPULARITY_ASC
  """
  Number of upvotes (awarded "thumbs up" emoji) by descending order.
  """
  POPULARITY_DESC
  "Priority by ascending order."
  PRIORITY_ASC
  "Priority by descending order."
  PRIORITY_DESC
  "Title by ascending order."
  TITLE_ASC
  "Title by descending order."
  TITLE_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"State of a GitLab merge request"
enum MergeRequestState {
  "Merge request has been merged."
  merged
  "Opened merge request."
  opened
  "In closed state."
  closed
  "Discussion has been locked."
  locked
  "All available."
  all
}
"Values for merge request dashboard list type"
enum MergeRequestsDashboardListType {
  "Action based list rendering."
  ACTION_BASED
  "Role based list rendering."
  ROLE_BASED
}
"Representation of whether a GitLab merge request can be merged."
enum MergeStatus {
  "Merge status has not been checked."
  UNCHECKED
  "Currently checking for mergeability."
  CHECKING
  "There are no conflicts between the source and target branches."
  CAN_BE_MERGED
  "There are conflicts between the source and target branches."
  CANNOT_BE_MERGED
  "Currently unchecked. The previous state was `CANNOT_BE_MERGED`."
  CANNOT_BE_MERGED_RECHECK
}
enum MergeStrategyEnum {
  "Use the merge_when_checks_pass merge strategy."
  MERGE_WHEN_CHECKS_PASS
}
"Representation of mergeability check identifier."
enum MergeabilityCheckIdentifier {
  "Checks whether the merge request is open"
  NOT_OPEN
  "Checks whether the merge is blocked due to a scheduled merge time"
  MERGE_TIME
  "Checks whether the merge request is draft"
  DRAFT_STATUS
  "Checks source branch exists and contains commits."
  COMMITS_STATUS
  "Checks whether the merge request has open discussions"
  DISCUSSIONS_NOT_RESOLVED
  "Checks whether CI has passed"
  CI_MUST_PASS
  "Checks whether the merge request contains locked LFS files that are locked by users other than the merge request author"
  LOCKED_LFS_FILES
  "Checks whether the merge request has a conflict"
  CONFLICT
  "Checks whether the merge request needs to be rebased"
  NEED_REBASE
}
"Representation of whether a mergeability check passed, checking, failed or is inactive."
enum MergeabilityCheckStatus {
  "Mergeability check has passed."
  SUCCESS
  "Mergeability check is being checked."
  CHECKING
  "Mergeability check has failed. The merge request cannot be merged."
  FAILED
  "Mergeability check is disabled via settings."
  INACTIVE
  "Mergeability check has passed with a warning."
  WARNING
}
"Values for sorting milestones"
enum MilestoneSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Milestone due date by ascending order."
  DUE_DATE_ASC
  "Milestone due date by descending order."
  DUE_DATE_DESC
  "Group milestones in the order: non-expired milestones with due dates, non-expired milestones without due dates and expired milestones then sort by due date in ascending order."
  EXPIRED_LAST_DUE_DATE_ASC
  "Group milestones in the order: non-expired milestones with due dates, non-expired milestones without due dates and expired milestones then sort by due date in descending order."
  EXPIRED_LAST_DUE_DATE_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"Current state of milestone"
enum MilestoneStateEnum {
  "Milestone is currently active."
  active
  "Milestone is closed."
  closed
}
"Milestone ID wildcard values"
enum MilestoneWildcardId {
  "No milestone is assigned."
  NONE
  "Milestone is assigned."
  ANY
  "Milestone assigned is open and started (start date <= today)."
  STARTED
  "Milestone assigned is due in the future (due date > today)."
  UPCOMING
}
"Field names for ordering machine learning model versions"
enum MlModelVersionsOrderBy {
  "Ordered by name."
  VERSION
  "Ordered by creation time."
  CREATED_AT
  "Ordered by id."
  ID
}
"Values for ordering machine learning models by a specific field"
enum MlModelsOrderBy {
  "Ordered by name."
  NAME
  "Ordered by creation time."
  CREATED_AT
  "Ordered by update time."
  UPDATED_AT
  "Ordered by id."
  ID
}
"Different toggles for changing mutator behavior"
enum MutationOperationMode {
  "Performs a replace operation."
  REPLACE
  "Performs an append operation."
  APPEND
  "Performs a removal operation."
  REMOVE
}
"Values for sorting projects"
enum NamespaceProjectSort {
  "Most similar to the search query."
  SIMILARITY
  "Sort by latest activity, descending order."
  ACTIVITY_DESC
  "Sort by total storage size, ascending order."
  STORAGE_SIZE_ASC
  "Sort by total storage size, descending order."
  STORAGE_SIZE_DESC
  "Sort by path, ascending order."
  PATH_ASC
  "Sort by path, descending order."
  PATH_DESC
  "Sort by total repository size, ascending order."
  REPOSITORY_SIZE_ASC
  "Sort by total repository size, descending order."
  REPOSITORY_SIZE_DESC
  "Sort by total snippet size, ascending order."
  SNIPPETS_SIZE_ASC
  "Sort by total snippet size, descending order."
  SNIPPETS_SIZE_DESC
  "Sort by total build artifact size, ascending order."
  BUILD_ARTIFACTS_SIZE_ASC
  "Sort by total build artifact size, descending order."
  BUILD_ARTIFACTS_SIZE_DESC
  "Sort by total LFS object size, ascending order."
  LFS_OBJECTS_SIZE_ASC
  "Sort by total LFS object size, descending order."
  LFS_OBJECTS_SIZE_DESC
  "Sort by total package size, ascending order."
  PACKAGES_SIZE_ASC
  "Sort by total package size, descending order."
  PACKAGES_SIZE_DESC
  "Sort by total wiki size, ascending order."
  WIKI_SIZE_ASC
  "Sort by total wiki size, descending order."
  WIKI_SIZE_DESC
  "Sort by total container registry size, ascending order."
  CONTAINER_REGISTRY_SIZE_ASC
  "Sort by total container registry size, descending order."
  CONTAINER_REGISTRY_SIZE_DESC
}
"Negated Milestone ID wildcard values"
enum NegatedMilestoneWildcardId {
  "Milestone assigned is open and yet to be started (start date > today)."
  STARTED
  "Milestone assigned is open but due in the past (due date <= today)."
  UPCOMING
}
"Work item notes collection type."
enum NotesFilterType {
  "Show all activity"
  ALL_NOTES
  "Show comments only"
  ONLY_COMMENTS
  "Show history only"
  ONLY_ACTIVITY
}
"Default list view for organization groups and projects."
enum OrganizationGroupProjectDisplay {
  "Display organization projects list. Introduced in GitLab 17.2: **Status**: Experiment."
  PROJECTS @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  "Display organization groups list. Introduced in GitLab 17.2: **Status**: Experiment."
  GROUPS @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
}
"Values for sorting organization groups and projects."
enum OrganizationGroupProjectSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Name ascending order. Introduced in GitLab 17.2: **Status**: Experiment."
  NAME_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  "Name descending order. Introduced in GitLab 17.2: **Status**: Experiment."
  NAME_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.2.")
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"Values for sorting organizations"
enum OrganizationSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
  "Default Rate in ascending order."
  DEFAULT_RATE_ASC
  "Default Rate in descending order."
  DEFAULT_RATE_DESC
  "Description in ascending order."
  DESCRIPTION_ASC
  "Description in descending order."
  DESCRIPTION_DESC
  "Name in ascending order."
  NAME_ASC
  "Name in descending order."
  NAME_DESC
}
"Access level of an organization user"
enum OrganizationUserAccessLevel {
  "Guest access. Introduced in GitLab 16.11: **Status**: Experiment."
  DEFAULT @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
  "Owner access. Introduced in GitLab 16.11: **Status**: Experiment."
  OWNER @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 16.11.")
}
enum PackageDependencyType {
  "dependencies dependency type"
  DEPENDENCIES
  "devDependencies dependency type"
  DEV_DEPENDENCIES
  "bundleDependencies dependency type"
  BUNDLE_DEPENDENCIES
  "peerDependencies dependency type"
  PEER_DEPENDENCIES
}
"Values for sorting group packages"
enum PackageGroupSort {
  "Ordered by project path in descending order."
  PROJECT_PATH_DESC
  "Ordered by project path in ascending order."
  PROJECT_PATH_ASC
  "Ordered by created_at in descending order."
  CREATED_DESC
  "Ordered by created_at in ascending order."
  CREATED_ASC
  "Ordered by name in descending order."
  NAME_DESC
  "Ordered by name in ascending order."
  NAME_ASC
  "Ordered by version in descending order."
  VERSION_DESC
  "Ordered by version in ascending order."
  VERSION_ASC
  "Ordered by type in descending order."
  TYPE_DESC
  "Ordered by type in ascending order."
  TYPE_ASC
}
"Values for sorting package"
enum PackageSort {
  "Ordered by created_at in descending order."
  CREATED_DESC
  "Ordered by created_at in ascending order."
  CREATED_ASC
  "Ordered by name in descending order."
  NAME_DESC
  "Ordered by name in ascending order."
  NAME_ASC
  "Ordered by version in descending order."
  VERSION_DESC
  "Ordered by version in ascending order."
  VERSION_ASC
  "Ordered by type in descending order."
  TYPE_DESC
  "Ordered by type in ascending order."
  TYPE_ASC
}
enum PackageStatus {
  "Packages with a default status"
  DEFAULT
  "Packages with a hidden status"
  HIDDEN
  "Packages with a processing status"
  PROCESSING
  "Packages with a error status"
  ERROR
  "Packages with a pending_destruction status"
  PENDING_DESTRUCTION
  "Packages with a deprecated status"
  DEPRECATED
}
enum PackageTypeEnum {
  "Packages from the Maven package manager"
  MAVEN
  "Packages from the npm package manager"
  NPM
  "Packages from the Conan package manager"
  CONAN
  "Packages from the Nuget package manager"
  NUGET
  "Packages from the PyPI package manager"
  PYPI
  "Packages from the Composer package manager"
  COMPOSER
  "Packages from the Generic package manager"
  GENERIC
  "Packages from the Golang package manager"
  GOLANG
  "Packages from the Debian package manager"
  DEBIAN
  "Packages from the Rubygems package manager"
  RUBYGEMS
  "Packages from the Helm package manager"
  HELM
  "Packages from the Terraform Module package manager"
  TERRAFORM_MODULE
  "Packages from the Rpm package manager"
  RPM
  "Packages from the Ml_model package manager"
  ML_MODEL
}
enum PackagesCleanupKeepDuplicatedPackageFilesEnum {
  "Value to keep all package files"
  ALL_PACKAGE_FILES
  "Value to keep 1 package files"
  ONE_PACKAGE_FILE
  "Value to keep 10 package files"
  TEN_PACKAGE_FILES
  "Value to keep 20 package files"
  TWENTY_PACKAGE_FILES
  "Value to keep 30 package files"
  THIRTY_PACKAGE_FILES
  "Value to keep 40 package files"
  FORTY_PACKAGE_FILES
  "Value to keep 50 package files"
  FIFTY_PACKAGE_FILES
}
"Access level of a package protection rule resource"
enum PackagesProtectionRuleAccessLevel {
  "Maintainer access."
  MAINTAINER
  "Owner access."
  OWNER
  "Admin access."
  ADMIN
}
"Access level for the deletion of a package protection rule resource."
enum PackagesProtectionRuleAccessLevelForDelete {
  "Owner access. Available only when feature flag `packages_protected_packages_delete` is enabled."
  OWNER
  "Admin access. Available only when feature flag `packages_protected_packages_delete` is enabled."
  ADMIN
}
"Package type of a package protection rule resource"
enum PackagesProtectionRulePackageType {
  "Packages of the Conan format. Available only when feature flag `packages_protected_packages_conan` is enabled. Introduced in GitLab 17.6: **Status**: Experiment."
  CONAN @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.6.")
  "Packages of the Maven format."
  MAVEN
  "Packages of the npm format."
  NPM
  "Packages of the PyPI format."
  PYPI
}
enum PipelineAnalyticsJobStatus {
  "Jobs with any status."
  ANY
  "Job that failed."
  FAILED
  "Job that succeeded."
  SUCCESS
  "Job that was canceled or skipped."
  OTHER
}
enum PipelineConfigSourceEnum {
  "Unknown source."
  UNKNOWN_SOURCE
  "Repository source."
  REPOSITORY_SOURCE
  "Auto DevOps source."
  AUTO_DEVOPS_SOURCE
  "Webide source."
  WEBIDE_SOURCE
  "Remote source."
  REMOTE_SOURCE
  "External project source."
  EXTERNAL_PROJECT_SOURCE
  "Bridge source."
  BRIDGE_SOURCE
  "Parameter source."
  PARAMETER_SOURCE
  "Compliance source."
  COMPLIANCE_SOURCE
  "Security policies default source."
  SECURITY_POLICIES_DEFAULT_SOURCE
  "Pipeline execution policy forced."
  PIPELINE_EXECUTION_POLICY_FORCED
}
"Event type of the pipeline associated with a merge request"
enum PipelineMergeRequestEventType {
  "Pipeline run on the changes from the source branch combined with the target branch."
  MERGED_RESULT
  "Pipeline run on the changes in the merge request source branch."
  DETACHED
}
"Values for sorting pipeline schedules."
enum PipelineScheduleSort {
  "Sort pipeline schedules by ID in descending order."
  ID_DESC
  "Sort pipeline schedules by ID in ascending order."
  ID_ASC
  "Sort pipeline schedules by description in descending order."
  DESCRIPTION_DESC
  "Sort pipeline schedules by description in ascending order."
  DESCRIPTION_ASC
  "Sort pipeline schedules by target in descending order."
  REF_DESC
  "Sort pipeline schedules by target in ascending order."
  REF_ASC
  "Sort pipeline schedules by next run in descending order."
  NEXT_RUN_AT_DESC
  "Sort pipeline schedules by next run in ascending order."
  NEXT_RUN_AT_ASC
  "Sort pipeline schedules by created date in descending order."
  CREATED_AT_DESC
  "Sort pipeline schedules by created date in ascending order."
  CREATED_AT_ASC
  "Sort pipeline schedules by updated date in descending order."
  UPDATED_AT_DESC
  "Sort pipeline schedules by updated date in ascending order."
  UPDATED_AT_ASC
}
enum PipelineScheduleStatus {
  "Active pipeline schedules."
  ACTIVE
  "Inactive pipeline schedules."
  INACTIVE
}
enum PipelineScopeEnum {
  "Pipeline is running."
  RUNNING
  "Pipeline has not started running yet."
  PENDING
  "Pipeline has completed."
  FINISHED
  "Branches."
  BRANCHES
  "Tags."
  TAGS
}
enum PipelineStatusEnum {
  "Pipeline has been created."
  CREATED
  "A resource (for example, a runner) that the pipeline requires to run is unavailable."
  WAITING_FOR_RESOURCE
  "Pipeline is preparing to run."
  PREPARING
  "Pipeline is waiting for an external action."
  WAITING_FOR_CALLBACK
  "Pipeline has not started running yet."
  PENDING
  "Pipeline is running."
  RUNNING
  "At least one stage of the pipeline failed."
  FAILED
  "Pipeline completed successfully."
  SUCCESS
  "Pipeline is in the process of canceling."
  CANCELING
  "Pipeline was canceled before completion."
  CANCELED
  "Pipeline was skipped."
  SKIPPED
  "Pipeline needs to be manually started."
  MANUAL
  "Pipeline is scheduled to run."
  SCHEDULED
}
"Pipeline variables minimum override roles."
enum PipelineVariablesDefaultRoleType {
  "No one allowed"
  NO_ONE_ALLOWED
  "Developer"
  DEVELOPER
  "Maintainer"
  MAINTAINER
  "Owner"
  OWNER
}
"Values for the archived argument"
enum ProjectArchived {
  "Only archived projects."
  ONLY
  "Include archvied projects."
  INCLUDE
  "Exclude archived projects."
  EXCLUDE
}
"Access level of a project feature"
enum ProjectFeatureAccessLevel {
  "Not enabled for anyone."
  DISABLED
  "Enabled only for team members."
  PRIVATE
  "Enabled for everyone able to access the project."
  ENABLED
}
"Project member relation"
enum ProjectMemberRelation {
  "Direct members"
  DIRECT
  "Inherited members"
  INHERITED
  "Descendants members"
  DESCENDANTS
  "Invited Groups members"
  INVITED_GROUPS
  "Shared Into Ancestors members"
  SHARED_INTO_ANCESTORS
}
"Values for sorting projects"
enum ProjectSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "ID by ascending order."
  ID_ASC
  "ID by descending order."
  ID_DESC
  "Latest activity by ascending order."
  LATEST_ACTIVITY_ASC
  "Latest activity by descending order."
  LATEST_ACTIVITY_DESC
  "Name by ascending order."
  NAME_ASC
  "Name by descending order."
  NAME_DESC
  "Path by ascending order."
  PATH_ASC
  "Path by descending order."
  PATH_DESC
  "Stars by ascending order."
  STARS_ASC
  "Stars by descending order."
  STARS_DESC
  "Storage size by ascending order."
  STORAGE_SIZE_ASC
  "Storage size by descending order."
  STORAGE_SIZE_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"Type of ref"
enum RefType {
  "Ref type for branches."
  HEADS
  "Ref type for tags."
  TAGS
}
"The position to which the object should be moved"
enum RelativePositionType {
  "Object is moved before an adjacent object."
  BEFORE
  "Object is moved after an adjacent object."
  AFTER
}
"Type of the link: `other`, `runbook`, `image`, `package`"
enum ReleaseAssetLinkType {
  "Other link type"
  OTHER
  "Runbook link type"
  RUNBOOK
  "Package link type"
  PACKAGE
  "Image link type"
  IMAGE
}
"Values for sorting releases"
enum ReleaseSort {
  "Created at descending order."
  CREATED_DESC
  "Created at ascending order."
  CREATED_ASC
  "Released at by descending order."
  RELEASED_AT_DESC
  "Released at by ascending order."
  RELEASED_AT_ASC
}
"Release tag ID wildcard values"
enum ReleaseTagWildcardId {
  "No release tag is assigned."
  NONE
  "Release tag is assigned."
  ANY
}
"Reviewer ID wildcard values"
enum ReviewerWildcardId {
  "No reviewer is assigned."
  NONE
  "Any reviewer is assigned."
  ANY
}
"Size of UI component in SAST configuration page"
enum SastUiComponentSize {
  "Size of UI component in SAST configuration page is small."
  SMALL
  "Size of UI component in SAST configuration page is medium."
  MEDIUM
  "Size of UI component in SAST configuration page is large."
  LARGE
}
enum SecurityReportTypeEnum {
  "SAST scan report"
  SAST
  "SAST ADVANCED scan report"
  SAST_ADVANCED
  "SAST IAC scan report"
  SAST_IAC
  "DAST scan report"
  DAST
  "DEPENDENCY SCANNING scan report"
  DEPENDENCY_SCANNING
  "CONTAINER SCANNING scan report"
  CONTAINER_SCANNING
  "SECRET DETECTION scan report"
  SECRET_DETECTION
  "COVERAGE FUZZING scan report"
  COVERAGE_FUZZING
  "API FUZZING scan report"
  API_FUZZING
  "CLUSTER IMAGE SCANNING scan report"
  CLUSTER_IMAGE_SCANNING
}
"State of a Sentry error"
enum SentryErrorStatus {
  "Error has been resolved."
  RESOLVED
  "Error has been ignored until next release."
  RESOLVED_IN_NEXT_RELEASE
  "Error is unresolved."
  UNRESOLVED
  "Error has been ignored."
  IGNORED
}
enum ServiceType {
  "AppleAppStoreService type"
  APPLE_APP_STORE_SERVICE
  "AsanaService type"
  ASANA_SERVICE
  "AssemblaService type"
  ASSEMBLA_SERVICE
  "BambooService type"
  BAMBOO_SERVICE
  "BugzillaService type"
  BUGZILLA_SERVICE
  "BuildkiteService type"
  BUILDKITE_SERVICE
  "CampfireService type"
  CAMPFIRE_SERVICE
  "ClickupService type"
  CLICKUP_SERVICE
  "ConfluenceService type"
  CONFLUENCE_SERVICE
  "CustomIssueTrackerService type"
  CUSTOM_ISSUE_TRACKER_SERVICE
  "DatadogService type"
  DATADOG_SERVICE
  "DiffblueCoverService type"
  DIFFBLUE_COVER_SERVICE
  "DiscordService type"
  DISCORD_SERVICE
  "DroneCiService type"
  DRONE_CI_SERVICE
  "EmailsOnPushService type"
  EMAILS_ON_PUSH_SERVICE
  "EwmService type"
  EWM_SERVICE
  "ExternalWikiService type"
  EXTERNAL_WIKI_SERVICE
  "GooglePlayService type"
  GOOGLE_PLAY_SERVICE
  "HangoutsChatService type"
  HANGOUTS_CHAT_SERVICE
  "HarborService type"
  HARBOR_SERVICE
  "IrkerService type"
  IRKER_SERVICE
  "JenkinsService type"
  JENKINS_SERVICE
  "JiraService type"
  JIRA_SERVICE
  "JiraCloudAppService type"
  JIRA_CLOUD_APP_SERVICE
  "MatrixService type"
  MATRIX_SERVICE
  "MattermostService type"
  MATTERMOST_SERVICE
  "MattermostSlashCommandsService type"
  MATTERMOST_SLASH_COMMANDS_SERVICE
  "MicrosoftTeamsService type"
  MICROSOFT_TEAMS_SERVICE
  "PackagistService type"
  PACKAGIST_SERVICE
  "PhorgeService type"
  PHORGE_SERVICE
  "PipelinesEmailService type"
  PIPELINES_EMAIL_SERVICE
  "PivotaltrackerService type"
  PIVOTALTRACKER_SERVICE
  "PrometheusService type"
  PROMETHEUS_SERVICE
  "PumbleService type"
  PUMBLE_SERVICE
  "PushoverService type"
  PUSHOVER_SERVICE
  "RedmineService type"
  REDMINE_SERVICE
  "SlackService type"
  SLACK_SERVICE
  "SlackSlashCommandsService type"
  SLACK_SLASH_COMMANDS_SERVICE
  "SquashTmService type"
  SQUASH_TM_SERVICE
  "TeamcityService type"
  TEAMCITY_SERVICE
  "TelegramService type"
  TELEGRAM_SERVICE
  "UnifyCircuitService type"
  UNIFY_CIRCUIT_SERVICE
  "WebexTeamsService type"
  WEBEX_TEAMS_SERVICE
  "YoutrackService type"
  YOUTRACK_SERVICE
  "ZentaoService type"
  ZENTAO_SERVICE
}
"How to format SHA strings."
enum ShaFormat {
  "Abbreviated format. Short SHAs are typically eight characters long."
  SHORT
  "Unabbreviated format."
  LONG
}
enum SharedRunnersSetting {
  "Sharing of runners is disabled and unoverridable."
  DISABLED_AND_UNOVERRIDABLE
  "Sharing of runners is disabled and overridable."
  DISABLED_AND_OVERRIDABLE
  "Sharing of runners is enabled."
  ENABLED
}
"Type of a snippet blob input action"
enum SnippetBlobActionEnum {
  "Create a snippet blob."
  create
  "Update a snippet blob."
  update
  "Delete a snippet blob."
  delete
  "Move a snippet blob."
  move
}
"Common sort values"
enum Sort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
"Values for sort direction"
enum SortDirectionEnum {
  "Ascending order."
  ASC
  "Descending order."
  DESC
}
"Values for sorting the mapping of users on source instance to users on destination instance."
enum SourceUserSort {
  "Status of the mapping by ascending order."
  STATUS_ASC
  "Status of the mapping by descending order."
  STATUS_DESC
  "Instance source name by ascending order."
  SOURCE_NAME_ASC
  "Instance source name by descending order."
  SOURCE_NAME_DESC
  "ID of the source user by ascending order."
  ID_ASC
  "ID of the source user by descending order."
  ID_DESC
}
"Options for default squash behaviour for merge requests"
enum SquashOptionSetting {
  "Do not allow."
  NEVER
  "Allow."
  ALLOWED
  "Encourage."
  ENCOURAGED
  "Require."
  ALWAYS
}
"Status of the subscription to an issuable."
enum SubscriptionStatus {
  "User is explicitly subscribed to the issuable."
  EXPLICITLY_SUBSCRIBED
  "User is explicitly unsubscribed from the issuable."
  EXPLICITLY_UNSUBSCRIBED
}
enum TestCaseStatus {
  "Test case that has a status of error."
  error
  "Test case that has a status of failed."
  failed
  "Test case that has a status of success."
  success
  "Test case that has a status of skipped."
  skipped
}
"Values for sorting timelogs"
enum TimelogSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Spent at ascending order."
  SPENT_AT_ASC
  "Spent at descending order."
  SPENT_AT_DESC
  "Time spent ascending order."
  TIME_SPENT_ASC
  "Time spent descending order."
  TIME_SPENT_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
enum TodoActionEnum {
  "User was assigned."
  assigned
  "User was mentioned."
  mentioned
  "Build triggered by the user failed."
  build_failed
  "User added a to-do item."
  marked
  "User was set as an approver."
  approval_required
  "Merge request authored by the user could not be merged."
  unmergeable
  "User was directly addressed."
  directly_addressed
  "Merge request authored by the user was removed from the merge train."
  merge_train_removed
  "Review was requested from the user."
  review_requested
  "Group or project access requested from the user."
  member_access_requested
  "Merge request authored by the user received a review."
  review_submitted
  "An OKR assigned to the user requires an update."
  okr_checkin_requested
  "User was added as an approver."
  added_approver
  "SSH key of the user has expired."
  ssh_key_expired
  "SSH key of the user will expire soon."
  ssh_key_expiring_soon
  "Access to Duo Pro has been granted to the user."
  duo_pro_access_granted
  "Access to Duo Enterprise has been granted to the user."
  duo_enterprise_access_granted
}
"Sort options for todos."
enum TodoSort {
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "By label priority in ascending order."
  LABEL_PRIORITY_ASC
  "By label priority in descending order."
  LABEL_PRIORITY_DESC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
}
enum TodoStateEnum {
  "State of the todo is pending."
  pending
  "State of the todo is done."
  done
}
enum TodoTargetEnum {
  "User."
  USER
  "Commit."
  COMMIT
  "Issue."
  ISSUE
  "Work item."
  WORKITEM
  "Merge request."
  MERGEREQUEST
  "Design."
  DESIGN
  "Alert."
  ALERT
  "Project."
  PROJECT
  "Namespace."
  NAMESPACE
  "SSH key."
  KEY
  "Wiki page."
  WIKIPAGEMETA
}
enum TypeEnum {
  "Snippet created independent of any project."
  personal
  "Snippet related to a specific project."
  project
}
"Name of the feature that the callout is for."
enum UserCalloutFeatureNameEnum {
  "Callout feature name for gke_cluster_integration."
  GKE_CLUSTER_INTEGRATION
  "Callout feature name for gcp_signup_offer."
  GCP_SIGNUP_OFFER
  "Callout feature name for cluster_security_warning."
  CLUSTER_SECURITY_WARNING
  "Callout feature name for ultimate_trial."
  ULTIMATE_TRIAL
  "Callout feature name for geo_enable_hashed_storage."
  GEO_ENABLE_HASHED_STORAGE
  "Callout feature name for geo_migrate_hashed_storage."
  GEO_MIGRATE_HASHED_STORAGE
  "Callout feature name for canary_deployment."
  CANARY_DEPLOYMENT
  "Callout feature name for gold_trial_billings."
  GOLD_TRIAL_BILLINGS
  "Callout feature name for suggest_popover_dismissed."
  SUGGEST_POPOVER_DISMISSED
  "Callout feature name for tabs_position_highlight."
  TABS_POSITION_HIGHLIGHT
  "Callout feature name for threat_monitoring_info."
  THREAT_MONITORING_INFO
  "Callout feature name for two_factor_auth_recovery_settings_check."
  TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK
  "Callout feature name for web_ide_alert_dismissed."
  WEB_IDE_ALERT_DISMISSED
  "Callout feature name for active_user_count_threshold."
  ACTIVE_USER_COUNT_THRESHOLD
  "Callout feature name for buy_pipeline_minutes_notification_dot."
  BUY_PIPELINE_MINUTES_NOTIFICATION_DOT
  "Callout feature name for personal_access_token_expiry."
  PERSONAL_ACCESS_TOKEN_EXPIRY
  "Callout feature name for suggest_pipeline."
  SUGGEST_PIPELINE
  "Callout feature name for feature_flags_new_version."
  FEATURE_FLAGS_NEW_VERSION
  "Callout feature name for registration_enabled_callout."
  REGISTRATION_ENABLED_CALLOUT
  "Callout feature name for new_user_signups_cap_reached."
  NEW_USER_SIGNUPS_CAP_REACHED
  "Callout feature name for unfinished_tag_cleanup_callout."
  UNFINISHED_TAG_CLEANUP_CALLOUT
  "Callout feature name for pipeline_needs_banner."
  PIPELINE_NEEDS_BANNER
  "Callout feature name for pipeline_needs_hover_tip."
  PIPELINE_NEEDS_HOVER_TIP
  "Callout feature name for web_ide_ci_environments_guidance."
  WEB_IDE_CI_ENVIRONMENTS_GUIDANCE
  "Callout feature name for security_configuration_upgrade_banner."
  SECURITY_CONFIGURATION_UPGRADE_BANNER
  "Callout feature name for trial_status_reminder_d14."
  TRIAL_STATUS_REMINDER_D14
  "Callout feature name for trial_status_reminder_d3."
  TRIAL_STATUS_REMINDER_D3
  "Callout feature name for security_configuration_devops_alert."
  SECURITY_CONFIGURATION_DEVOPS_ALERT
  "Callout feature name for profile_personal_access_token_expiry."
  PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY
  "Callout feature name for terraform_notification_dismissed."
  TERRAFORM_NOTIFICATION_DISMISSED
  "Callout feature name for security_newsletter_callout."
  SECURITY_NEWSLETTER_CALLOUT
  "Callout feature name for verification_reminder."
  VERIFICATION_REMINDER
  "Callout feature name for ci_deprecation_warning_for_types_keyword."
  CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD
  "Callout feature name for security_training_feature_promotion."
  SECURITY_TRAINING_FEATURE_PROMOTION
  "Callout feature name for namespace_storage_pre_enforcement_banner."
  NAMESPACE_STORAGE_PRE_ENFORCEMENT_BANNER
  "Callout feature name for ci_minutes_limit_alert_warning_stage."
  CI_MINUTES_LIMIT_ALERT_WARNING_STAGE
  "Callout feature name for ci_minutes_limit_alert_danger_stage."
  CI_MINUTES_LIMIT_ALERT_DANGER_STAGE
  "Callout feature name for ci_minutes_limit_alert_exceeded_stage."
  CI_MINUTES_LIMIT_ALERT_EXCEEDED_STAGE
  "Callout feature name for preview_user_over_limit_free_plan_alert."
  PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT
  "Callout feature name for user_reached_limit_free_plan_alert."
  USER_REACHED_LIMIT_FREE_PLAN_ALERT
  "Callout feature name for submit_license_usage_data_banner."
  SUBMIT_LICENSE_USAGE_DATA_BANNER
  "Callout feature name for personal_project_limitations_banner."
  PERSONAL_PROJECT_LIMITATIONS_BANNER
  "Callout feature name for mr_experience_survey."
  MR_EXPERIENCE_SURVEY
  "Callout feature name for namespace_storage_limit_alert_warning_threshold."
  NAMESPACE_STORAGE_LIMIT_ALERT_WARNING_THRESHOLD
  "Callout feature name for namespace_storage_limit_alert_alert_threshold."
  NAMESPACE_STORAGE_LIMIT_ALERT_ALERT_THRESHOLD
  "Callout feature name for namespace_storage_limit_alert_error_threshold."
  NAMESPACE_STORAGE_LIMIT_ALERT_ERROR_THRESHOLD
  "Callout feature name for project_quality_summary_feedback."
  PROJECT_QUALITY_SUMMARY_FEEDBACK
  "Callout feature name for new_top_level_group_alert."
  NEW_TOP_LEVEL_GROUP_ALERT
  "Callout feature name for branch_rules_info_callout."
  BRANCH_RULES_INFO_CALLOUT
  "Callout feature name for project_repository_limit_alert_warning_threshold."
  PROJECT_REPOSITORY_LIMIT_ALERT_WARNING_THRESHOLD
  "Callout feature name for namespace_over_storage_users_combined_alert."
  NAMESPACE_OVER_STORAGE_USERS_COMBINED_ALERT
  "Callout feature name for vsd_feedback_banner."
  VSD_FEEDBACK_BANNER
  "Callout feature name for security_policy_protected_branch_modification."
  SECURITY_POLICY_PROTECTED_BRANCH_MODIFICATION
  "Callout feature name for vulnerability_report_grouping."
  VULNERABILITY_REPORT_GROUPING
  "Callout feature name for duo_chat_callout."
  DUO_CHAT_CALLOUT
  "Callout feature name for product_analytics_dashboard_feedback."
  PRODUCT_ANALYTICS_DASHBOARD_FEEDBACK
  "Callout feature name for joining_a_project_alert."
  JOINING_A_PROJECT_ALERT
  "Callout feature name for transition_to_jihu_callout."
  TRANSITION_TO_JIHU_CALLOUT
  "Callout feature name for deployment_details_feedback."
  DEPLOYMENT_DETAILS_FEEDBACK
  "Callout feature name for deployment_approvals_empty_state."
  DEPLOYMENT_APPROVALS_EMPTY_STATE
  "Callout feature name for period_in_terraform_state_name_alert."
  PERIOD_IN_TERRAFORM_STATE_NAME_ALERT
  "Callout feature name for work_item_epic_feedback."
  WORK_ITEM_EPIC_FEEDBACK
  "Callout feature name for branch_rules_tip_callout."
  BRANCH_RULES_TIP_CALLOUT
  "Callout feature name for openssl_callout."
  OPENSSL_CALLOUT
  "Callout feature name for new_mr_dashboard_banner."
  NEW_MR_DASHBOARD_BANNER
  "Callout feature name for planner_role_callout."
  PLANNER_ROLE_CALLOUT
  "Callout feature name for pipl_compliance_alert."
  PIPL_COMPLIANCE_ALERT
  "Callout feature name for new_merge_request_dashboard_welcome."
  NEW_MERGE_REQUEST_DASHBOARD_WELCOME
  "Callout feature name for pipeline_inputs_announcement_banner."
  PIPELINE_INPUTS_ANNOUNCEMENT_BANNER
  "Callout feature name for pipeline_new_inputs_adoption_banner."
  PIPELINE_NEW_INPUTS_ADOPTION_BANNER
  "Callout feature name for pipeline_schedules_inputs_adoption_banner."
  PIPELINE_SCHEDULES_INPUTS_ADOPTION_BANNER
  "Callout feature name for product_usage_data_collection_changes."
  PRODUCT_USAGE_DATA_COLLECTION_CHANGES
}
"Possible states of a user"
enum UserState {
  "User is active and can use the system."
  active
  "User has been blocked by an administrator and cannot use the system."
  blocked
  "User is no longer active and cannot use the system."
  deactivated
  "User is blocked, and their contributions are hidden."
  banned
  "User has been blocked by the system."
  ldap_blocked
  "User is blocked and pending approval."
  blocked_pending_approval
}
"Possible types of user"
enum UserType {
  "Human"
  HUMAN
  "Support bot"
  SUPPORT_BOT
  "Alert bot"
  ALERT_BOT
  "Visual review bot"
  VISUAL_REVIEW_BOT
  "Service user"
  SERVICE_USER
  "Ghost"
  GHOST
  "Project bot"
  PROJECT_BOT
  "Migration bot"
  MIGRATION_BOT
  "Security bot"
  SECURITY_BOT
  "Automation bot"
  AUTOMATION_BOT
  "Security policy bot"
  SECURITY_POLICY_BOT
  "Admin bot"
  ADMIN_BOT
  "Suggested reviewers bot"
  SUGGESTED_REVIEWERS_BOT
  "Service account"
  SERVICE_ACCOUNT
  "Llm bot"
  LLM_BOT
  "Placeholder"
  PLACEHOLDER
  "Duo code review bot"
  DUO_CODE_REVIEW_BOT
  "Import user"
  IMPORT_USER
}
"Stage event identifiers"
enum ValueStreamStageEvent {
  "Issue created event."
  ISSUE_CREATED
  "Issue first mentioned in commit event."
  ISSUE_FIRST_MENTIONED_IN_COMMIT
  "Issue deployed to production event."
  ISSUE_DEPLOYED_TO_PRODUCTION
  "Merge request created event."
  MERGE_REQUEST_CREATED
  "Merge request first deployed to production event."
  MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION
  "Merge request last build finished event."
  MERGE_REQUEST_LAST_BUILD_FINISHED
  "Merge request last build started event."
  MERGE_REQUEST_LAST_BUILD_STARTED
  "Merge request merged event."
  MERGE_REQUEST_MERGED
  "Code stage start event."
  CODE_STAGE_START
  "Issue stage end event."
  ISSUE_STAGE_END
  "Plan stage start event."
  PLAN_STAGE_START
}
"Sorting values available to value stream stage items"
enum ValueStreamStageItemSort {
  "Duration by ascending order."
  DURATION_ASC
  "Duration by ascending order."
  DURATION_DESC
  "Stage end event time by ascending order."
  END_EVENT_ASC
  "Stage end event time by descending order."
  END_EVENT_DESC
}
"Verification status of a GPG, X.509 or SSH signature for a commit."
enum VerificationStatus {
  "unverified verification status."
  UNVERIFIED
  "verified verification status."
  VERIFIED
  "same_user_different_email verification status."
  SAME_USER_DIFFERENT_EMAIL
  "other_user verification status."
  OTHER_USER
  "unverified_key verification status."
  UNVERIFIED_KEY
  "unknown_key verification status."
  UNKNOWN_KEY
  "multiple_signatures verification status."
  MULTIPLE_SIGNATURES
  "revoked_key verification status."
  REVOKED_KEY
  "verified_system verification status."
  VERIFIED_SYSTEM
  "unverified_author_email verification status."
  UNVERIFIED_AUTHOR_EMAIL
}
enum VisibilityLevelsEnum {
  "Private visibility level."
  private
  "Internal visibility level."
  internal
  "Public visibility level."
  public
}
"Determines whether the pipeline list shows ID or IID"
enum VisibilityPipelineIdType {
  "Display pipeline ID."
  ID
  "Display pipeline IID."
  IID
}
enum VisibilityScopesEnum {
  "Snippet is visible only to the snippet creator."
  private
  "Snippet is visible for any logged in user except external users."
  internal
  "Snippet can be accessed without any authentication."
  public
}
"Values for work item award emoji update enum"
enum WorkItemAwardEmojiUpdateAction {
  "Adds the emoji."
  ADD
  "Removes the emoji."
  REMOVE
  "Toggles the status of the emoji."
  TOGGLE
}
"Values for work item link types"
enum WorkItemRelatedLinkType {
  "Related type."
  RELATED
}
"Values for sorting work items"
enum WorkItemSort {
  "Closed time by ascending order. Introduced in GitLab 17.10: **Status**: Experiment."
  CLOSED_AT_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Closed time by descending order. Introduced in GitLab 17.10: **Status**: Experiment."
  CLOSED_AT_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Created at ascending order."
  CREATED_ASC
  "Created at ascending order. Deprecated in GitLab 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in GitLab 13.5.")
  "Created at descending order."
  CREATED_DESC
  "Created at descending order. Deprecated in GitLab 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in GitLab 13.5.")
  "Due date by ascending order. Introduced in GitLab 17.9: **Status**: Experiment."
  DUE_DATE_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Due date by descending order. Introduced in GitLab 17.9: **Status**: Experiment."
  DUE_DATE_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Status from triggered to resolved. Introduced in GitLab 17.10: **Status**: Experiment."
  ESCALATION_STATUS_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Status from resolved to triggered. Introduced in GitLab 17.10: **Status**: Experiment."
  ESCALATION_STATUS_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Label priority by ascending order."
  LABEL_PRIORITY_ASC
  "Label priority by descending order."
  LABEL_PRIORITY_DESC
  "Milestone due date by ascending order."
  MILESTONE_DUE_ASC
  "Milestone due date by descending order."
  MILESTONE_DUE_DESC
  """
  Number of upvotes (awarded "thumbs up" emoji) by ascending order. Introduced in GitLab 17.10: **Status**: Experiment.
  """
  POPULARITY_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  """
  Number of upvotes (awarded "thumbs up" emoji) by descending order. Introduced in GitLab 17.10: **Status**: Experiment.
  """
  POPULARITY_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Priority by ascending order. Introduced in GitLab 17.10: **Status**: Experiment."
  PRIORITY_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Priority by descending order. Introduced in GitLab 17.10: **Status**: Experiment."
  PRIORITY_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Relative position by ascending order. Introduced in GitLab 17.10: **Status**: Experiment."
  RELATIVE_POSITION_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Severity from less critical to more critical. Introduced in GitLab 17.10: **Status**: Experiment."
  SEVERITY_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Severity from more critical to less critical. Introduced in GitLab 17.10: **Status**: Experiment."
  SEVERITY_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.10.")
  "Start date by ascending order. Introduced in GitLab 17.9: **Status**: Experiment."
  START_DATE_ASC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Start date by descending order. Introduced in GitLab 17.9: **Status**: Experiment."
  START_DATE_DESC @deprecated(reason: "**Status**: Experiment. Introduced in GitLab 17.9.")
  "Title by ascending order."
  TITLE_ASC
  "Title by descending order."
  TITLE_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at ascending order. Deprecated in GitLab 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in GitLab 13.5.")
  "Updated at descending order."
  UPDATED_DESC
  "Updated at descending order. Deprecated in GitLab 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in GitLab 13.5.")
}
"State of a GitLab work item"
enum WorkItemState {
  "In open state."
  OPEN
  "In closed state."
  CLOSED
}
"Values for work item state events"
enum WorkItemStateEvent {
  "Reopens the work item."
  REOPEN
  "Closes the work item."
  CLOSE
}
"Values for work item to-do update enum"
enum WorkItemTodoUpdateAction {
  "Marks the to-do as done."
  MARK_AS_DONE
  "Adds the to-do."
  ADD
}
"Type of a work item widget"
enum WorkItemWidgetType {
  "Assignees widget."
  ASSIGNEES
  "Description widget."
  DESCRIPTION
  "Hierarchy widget."
  HIERARCHY
  "Labels widget."
  LABELS
  "Milestone widget."
  MILESTONE
  "Notes widget."
  NOTES
  "Start And Due Date widget."
  START_AND_DUE_DATE
  "Notifications widget."
  NOTIFICATIONS
  "Current User Todos widget."
  CURRENT_USER_TODOS
  "Award Emoji widget."
  AWARD_EMOJI
  "Linked Items widget."
  LINKED_ITEMS
  "Participants widget."
  PARTICIPANTS
  "Time Tracking widget."
  TIME_TRACKING
  "Designs widget."
  DESIGNS
  "Development widget."
  DEVELOPMENT
  "Crm Contacts widget."
  CRM_CONTACTS
  "Email Participants widget."
  EMAIL_PARTICIPANTS
  "Linked Resources widget."
  LINKED_RESOURCES
  "Error Tracking widget."
  ERROR_TRACKING
}
"Autogenerated input type of AbuseReportLabelCreate"
input AbuseReportLabelCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Title of the label."
  title: String!
  """
  The color of the label given in 6-digit hex notation with leading '#' sign
  (for example, `#FFAABB`) or one of the CSS color names.
  """
  color: String = "#6699cc"
}
"Autogenerated input type of AchievementsAward"
input AchievementsAwardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the achievement being awarded."
  achievementId: AchievementsAchievementID!
  "Global ID of the user being awarded the achievement."
  userId: UserID!
}
"Autogenerated input type of AchievementsCreate"
input AchievementsCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Namespace for the achievement."
  namespaceId: NamespaceID!
  "Name for the achievement."
  name: String!
  "Avatar for the achievement."
  avatar: Upload
  "Description of or notes for the achievement."
  description: String
}
"Autogenerated input type of AchievementsDelete"
input AchievementsDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the achievement being deleted."
  achievementId: AchievementsAchievementID!
}
"Autogenerated input type of AchievementsRevoke"
input AchievementsRevokeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the user achievement being revoked."
  userAchievementId: AchievementsUserAchievementID!
}
"Autogenerated input type of AchievementsUpdate"
input AchievementsUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the achievement being updated."
  achievementId: AchievementsAchievementID!
  "Name for the achievement."
  name: String
  "Avatar for the achievement."
  avatar: Upload
  "Description of or notes for the achievement."
  description: String
}
"Autogenerated input type of AdminSidekiqQueuesDeleteJobs"
input AdminSidekiqQueuesDeleteJobsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Delete jobs matching organization_id in the context metadata."
  organizationId: String
  "Delete jobs matching user in the context metadata."
  user: String
  "Delete jobs matching user_id in the context metadata."
  userId: String
  "Delete jobs matching scoped_user in the context metadata."
  scopedUser: String
  "Delete jobs matching scoped_user_id in the context metadata."
  scopedUserId: String
  "Delete jobs matching project in the context metadata."
  project: String
  "Delete jobs matching root_namespace in the context metadata."
  rootNamespace: String
  "Delete jobs matching client_id in the context metadata."
  clientId: String
  "Delete jobs matching caller_id in the context metadata."
  callerId: String
  "Delete jobs matching remote_ip in the context metadata."
  remoteIp: String
  "Delete jobs matching job_id in the context metadata."
  jobId: String
  "Delete jobs matching pipeline_id in the context metadata."
  pipelineId: String
  "Delete jobs matching related_class in the context metadata."
  relatedClass: String
  "Delete jobs matching feature_category in the context metadata."
  featureCategory: String
  "Delete jobs matching artifact_size in the context metadata."
  artifactSize: String
  "Delete jobs matching artifact_used_cdn in the context metadata."
  artifactUsedCdn: String
  "Delete jobs matching artifacts_dependencies_size in the context metadata."
  artifactsDependenciesSize: String
  "Delete jobs matching artifacts_dependencies_count in the context metadata."
  artifactsDependenciesCount: String
  "Delete jobs matching root_caller_id in the context metadata."
  rootCallerId: String
  "Delete jobs matching merge_action_status in the context metadata."
  mergeActionStatus: String
  "Delete jobs matching bulk_import_entity_id in the context metadata."
  bulkImportEntityId: String
  "Delete jobs matching sidekiq_destination_shard_redis in the context metadata."
  sidekiqDestinationShardRedis: String
  "Delete jobs with the given worker class."
  workerClass: String
  "Name of the queue to delete jobs from."
  queueName: String!
}
"Autogenerated input type of AlertSetAssignees"
input AlertSetAssigneesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the alert to mutate is in."
  projectPath: ID!
  "IID of the alert to mutate."
  iid: String!
  "Usernames to assign to the alert. Replaces existing assignees by default."
  assigneeUsernames: [String!]!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode
}
"Autogenerated input type of AlertTodoCreate"
input AlertTodoCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the alert to mutate is in."
  projectPath: ID!
  "IID of the alert to mutate."
  iid: String!
}
"Autogenerated input type of ArtifactDestroy"
input ArtifactDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the artifact to delete."
  id: CiJobArtifactID!
}
"Autogenerated input type of AwardEmojiAdd"
input AwardEmojiAddInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the awardable resource."
  awardableId: AwardableID!
  "Emoji name."
  name: String!
}
"Autogenerated input type of AwardEmojiRemove"
input AwardEmojiRemoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the awardable resource."
  awardableId: AwardableID!
  "Emoji name."
  name: String!
}
"Autogenerated input type of AwardEmojiToggle"
input AwardEmojiToggleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the awardable resource."
  awardableId: AwardableID!
  "Emoji name."
  name: String!
}
input BoardIssueInput {
  "Filter by label name."
  labelName: [String]
  "Filter by author username."
  authorUsername: String
  """
  Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.
  """
  myReactionEmoji: String
  """
  List of IIDs of issues. For example `["1", "2"]`.
  """
  iids: [String!]
  "Filter by milestone title."
  milestoneTitle: String
  "Filter by assignee username."
  assigneeUsername: [String]
  "Filter by release tag."
  releaseTag: String
  "Filter by the given issue types."
  types: [IssueType!]
  "Filter by milestone ID wildcard."
  milestoneWildcardId: MilestoneWildcardId
  "List of negated arguments."
  not: NegatedBoardIssueInput
  "List of arguments with inclusive OR."
  or: UnionedIssueFilterInput
  "Search query for issue title or description."
  search: String
  "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
  assigneeWildcardId: AssigneeWildcardId
  "Filter by confidentiality."
  confidential: Boolean
}
"Autogenerated input type of BoardListCreate"
input BoardListCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Create the backlog list."
  backlog: Boolean
  "Global ID of an existing label."
  labelId: LabelID
  "Global ID of the issue board to mutate."
  boardId: BoardID!
  "Position of the list."
  position: Int
}
"Autogenerated input type of BranchDelete"
input BranchDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project full path the branch is associated with."
  projectPath: ID!
  "Name of the branch."
  name: String!
}
input BranchProtectionInput {
  "Details about who can merge into the branch rule target."
  mergeAccessLevels: [MergeAccessLevelInput!] = []
  "Details about who can push to the branch rule target."
  pushAccessLevels: [PushAccessLevelInput!] = []
  "Allows users with write access to the branch rule target to force push changes."
  allowForcePush: Boolean = false
}
"Autogenerated input type of BranchRuleCreate"
input BranchRuleCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path to the project that the branch is associated with."
  projectPath: ID!
  "Branch name, with wildcards, for the branch rules."
  name: String!
}
"Autogenerated input type of BranchRuleDelete"
input BranchRuleDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the branch rule to destroy."
  id: ProjectsBranchRuleID!
}
"Autogenerated input type of BranchRuleSquashOptionUpdate"
input BranchRuleSquashOptionUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the branch rule."
  branchRuleId: ProjectsBranchRuleID!
  "Squash option after mutation."
  squashOption: SquashOptionSetting!
}
"Autogenerated input type of BranchRuleUpdate"
input BranchRuleUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the branch rule to update."
  id: ProjectsBranchRuleID!
  "Branch name, with wildcards, for the branch rules."
  name: String!
  "Branch protections configured for the branch rule."
  branchProtection: BranchProtectionInput
}
"Autogenerated input type of BulkDestroyJobArtifacts"
input BulkDestroyJobArtifactsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the job artifacts to destroy."
  ids: [CiJobArtifactID!]!
  "Global Project ID of the job artifacts to destroy. Incompatible with projectPath."
  projectId: ProjectID!
}
"Autogenerated input type of BulkRunnerDelete"
input BulkRunnerDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IDs of the runners to delete."
  ids: [CiRunnerID!]
}
"Autogenerated input type of CatalogResourcesCreate"
input CatalogResourcesCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project path belonging to the catalog resource."
  projectPath: ID!
}
"Autogenerated input type of CatalogResourcesDestroy"
input CatalogResourcesDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project path belonging to the catalog resource."
  projectPath: ID!
}
"Attributes for defining an input."
input CiInputsInput {
  "Name of the input."
  name: String!
  "Value of the input."
  value: CiInputsValue!
  "Set to `true` to delete the input."
  destroy: Boolean
}
"Autogenerated input type of CiJobTokenScopeAddGroupOrProject"
input CiJobTokenScopeAddGroupOrProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project that the CI job token scope belongs to."
  projectPath: ID!
  "Group or project to be added to the CI job token scope."
  targetPath: ID!
}
"Autogenerated input type of CiJobTokenScopeAddProject"
input CiJobTokenScopeAddProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project that the CI job token scope belongs to."
  projectPath: ID!
  "Project to be added to the CI job token scope."
  targetProjectPath: ID!
}
"Autogenerated input type of CiJobTokenScopeAutopopulateAllowlist"
input CiJobTokenScopeAutopopulateAllowlistInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project in which to autopopulate the allowlist."
  projectPath: ID!
}
"Autogenerated input type of CiJobTokenScopeClearAllowlistAutopopulations"
input CiJobTokenScopeClearAllowlistAutopopulationsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project in which to autopopulate the allowlist."
  projectPath: ID!
}
"Autogenerated input type of CiJobTokenScopeRemoveGroup"
input CiJobTokenScopeRemoveGroupInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project that the CI job token scope belongs to."
  projectPath: ID!
  "Group to be removed from the CI job token scope."
  targetGroupPath: ID!
}
"Autogenerated input type of CiJobTokenScopeRemoveProject"
input CiJobTokenScopeRemoveProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project that the CI job token scope belongs to."
  projectPath: ID!
  "Project to be removed from the CI job token scope."
  targetProjectPath: ID!
}
"Autogenerated input type of CiJobTokenScopeUpdatePolicies"
input CiJobTokenScopeUpdatePoliciesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project that the CI job token scope belongs to."
  projectPath: ID!
  "Group or project that the CI job token targets."
  targetPath: ID!
  "Indicates whether default permissions are enabled (true) or fine-grained permissions are enabled (false)."
  defaultPermissions: Boolean!
  "List of policies added to the CI job token scope."
  jobTokenPolicies: [CiJobTokenScopePolicies!]!
}
"Attributes for defining a CI/CD variable."
input CiVariableInput {
  "Name of the variable."
  key: String!
  "Value of the variable."
  value: String!
  "Type of variable."
  variableType: CiVariableType
}
"Autogenerated input type of ClusterAgentDelete"
input ClusterAgentDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the cluster agent that will be deleted."
  id: ClustersAgentID!
}
"Autogenerated input type of ClusterAgentTokenCreate"
input ClusterAgentTokenCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the cluster agent that will be associated with the new token."
  clusterAgentId: ClustersAgentID!
  "Description of the token."
  description: String
  "Name of the token."
  name: String!
}
"Autogenerated input type of ClusterAgentTokenRevoke"
input ClusterAgentTokenRevokeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the agent token that will be revoked."
  id: ClustersAgentTokenID!
}
input CommitAction {
  "Action to perform: create, delete, move, update, or chmod."
  action: CommitActionMode!
  "Content of the file."
  content: String
  "Encoding of the file. Default is text."
  encoding: CommitEncoding
  "Enables/disables the execute flag on the file."
  executeFilemode: Boolean
  "Full path to the file."
  filePath: String!
  "Last known file commit ID."
  lastCommitId: String
  "Original full path to the file being moved."
  previousPath: String
}
"Autogenerated input type of CommitCreate"
input CommitCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project full path the branch is associated with."
  projectPath: ID!
  "Name of the branch to commit into, it can be a new branch."
  branch: String!
  "If on a new branch, name of the original branch."
  startBranch: String
  "Raw commit message."
  message: String!
  "Array of action hashes to commit as a batch."
  actions: [CommitAction!]!
}
"Autogenerated input type of ConfigureSastIac"
input ConfigureSastIacInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}
"Autogenerated input type of ConfigureSast"
input ConfigureSastInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
  "SAST CI configuration for the project."
  configuration: SastCiConfigurationInput!
}
"Autogenerated input type of ConfigureSecretDetection"
input ConfigureSecretDetectionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}
"Autogenerated input type of CreateAbuseReportNote"
input CreateAbuseReportNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the abuse report."
  abuseReportId: AbuseReportID!
  "Content of the note."
  body: String!
  "Global ID of the abuse report discussion the note is in reply to."
  discussionId: DiscussionID
}
"Autogenerated input type of CreateAlertIssue"
input CreateAlertIssueInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the alert to mutate is in."
  projectPath: ID!
  "IID of the alert to mutate."
  iid: String!
}
"Autogenerated input type of CreateAnnotation"
input CreateAnnotationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the environment to add an annotation to."
  environmentId: EnvironmentID
  "Global ID of the cluster to add an annotation to."
  clusterId: ClustersClusterID
  "Timestamp indicating starting moment to which the annotation relates."
  startingAt: Time!
  "Timestamp indicating ending moment to which the annotation relates."
  endingAt: Time
  "Path to a file defining the dashboard on which the annotation should be added."
  dashboardPath: String!
  "Description of the annotation."
  description: String!
}
"Autogenerated input type of CreateBoard"
input CreateBoardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Board name."
  name: String
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
}
"Autogenerated input type of CreateBranch"
input CreateBranchInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project full path the branch is associated with."
  projectPath: ID!
  "Name of the branch."
  name: String!
  "Branch name or commit SHA to create branch from."
  ref: String!
}
"Autogenerated input type of CreateClusterAgent"
input CreateClusterAgentInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the associated project for the cluster agent."
  projectPath: ID!
  "Name of the cluster agent."
  name: String!
}
"Autogenerated input type of CreateContainerProtectionRepositoryRule"
input CreateContainerProtectionRepositoryRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project where a protection rule is located."
  projectPath: ID!
  "Container repository path pattern protected by the protection rule. Must start with the project’s full path. For example: `my-project/*-prod-*`. Wildcard character `*` is allowed anywhere after the project’s full path."
  repositoryPathPattern: String!
  "Minimum GitLab access level required to delete container images from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForDelete: ContainerProtectionRepositoryRuleAccessLevel
  "Minimum GitLab access level required to push container images to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForPush: ContainerProtectionRepositoryRuleAccessLevel
}
"Autogenerated input type of CreateCustomEmoji"
input CreateCustomEmojiInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Namespace full path the emoji is associated with."
  groupPath: ID!
  "Name of the emoji."
  name: String!
  "Location of the emoji file."
  url: String!
}
"Autogenerated input type of CreateDiffNote"
input CreateDiffNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the resource to add a note to."
  noteableId: NoteableID!
  "Content of the note."
  body: String!
  "Internal flag for a note. Default is false."
  internal: Boolean
  "Position of the note on a diff."
  position: DiffPositionInput!
}
"Autogenerated input type of CreateDiscussion"
input CreateDiscussionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the resource to add a note to."
  noteableId: NoteableID!
  "Content of the note."
  body: String!
  "Internal flag for a note. Default is false."
  internal: Boolean
}
"Autogenerated input type of CreateImageDiffNote"
input CreateImageDiffNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the resource to add a note to."
  noteableId: NoteableID!
  "Content of the note."
  body: String!
  "Internal flag for a note. Default is false."
  internal: Boolean
  "Position of the note on a diff."
  position: DiffImagePositionInput!
}
"Autogenerated input type of CreateIssue"
input CreateIssueInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the issue."
  description: String
  "Due date of the issue."
  dueDate: ISO8601Date
  "Indicates the issue is confidential."
  confidential: Boolean
  "Indicates discussion is locked on the issue."
  locked: Boolean
  "Type of the issue."
  type: IssueType
  "Project full path the issue is associated with."
  projectPath: ID!
  "IID (internal ID) of a project issue. Only admins and project owners can modify."
  iid: Int
  "Title of the issue."
  title: String!
  "ID of the milestone to assign to the issue. On update milestone will be removed if set to null."
  milestoneId: MilestoneID
  "Labels of the issue."
  labels: [String!]
  "IDs of labels to be added to the issue."
  labelIds: [LabelID!]
  "Timestamp when the issue was created. Available only for admins and project owners."
  createdAt: Time
  "IID of a merge request for which to resolve discussions."
  mergeRequestToResolveDiscussionsOf: MergeRequestID
  "ID of a discussion to resolve. Also pass `merge_request_to_resolve_discussions_of`."
  discussionToResolve: String
  "Array of user IDs to assign to the issue."
  assigneeIds: [UserID!]
  "Global ID of issue that should be placed before the current issue."
  moveBeforeId: IssueID
  "Global ID of issue that should be placed after the current issue."
  moveAfterId: IssueID
}
"Autogenerated input type of CreateNote"
input CreateNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the resource to add a note to."
  noteableId: NoteableID!
  "Content of the note."
  body: String!
  "Internal flag for a note. Default is false."
  internal: Boolean
  "Global ID of the discussion the note is in reply to."
  discussionId: DiscussionID
  "SHA of the head commit which is used to ensure that the merge request has not been updated since the request was sent."
  mergeRequestDiffHeadSha: String
}
"Autogenerated input type of CreatePackagesProtectionRule"
input CreatePackagesProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project where a protection rule is located."
  projectPath: ID!
  "Package name protected by the protection rule. For example, `@my-scope/my-package-*`. Wildcard character `*` allowed."
  packageNamePattern: String!
  "Package type protected by the protection rule. For example, `NPM`, `PYPI`."
  packageType: PackagesProtectionRulePackageType!
  "Minimum GitLab access required to push packages to the package registry. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForPush: PackagesProtectionRuleAccessLevel
}
"Autogenerated input type of CreateSnippet"
input CreateSnippetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Title of the snippet."
  title: String!
  "Description of the snippet."
  description: String
  "Visibility level of the snippet."
  visibilityLevel: VisibilityLevelsEnum!
  "Full path of the project the snippet is associated with."
  projectPath: ID
  "Paths to files uploaded in the snippet description."
  uploadedFiles: [String!]
  "Actions to perform over the snippet repository and blobs."
  blobActions: [SnippetBlobActionInputType!]
}
"Autogenerated input type of CustomerRelationsContactCreate"
input CustomerRelationsContactCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group for the contact."
  groupId: GroupID!
  "Organization for the contact."
  organizationId: CustomerRelationsOrganizationID
  "First name of the contact."
  firstName: String!
  "Last name of the contact."
  lastName: String!
  "Phone number of the contact."
  phone: String
  "Email address of the contact."
  email: String
  "Description of or notes for the contact."
  description: String
}
"Autogenerated input type of CustomerRelationsContactUpdate"
input CustomerRelationsContactUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the contact."
  id: CustomerRelationsContactID!
  "Organization of the contact."
  organizationId: CustomerRelationsOrganizationID
  "First name of the contact."
  firstName: String
  "Last name of the contact."
  lastName: String
  "Phone number of the contact."
  phone: String
  "Email address of the contact."
  email: String
  "Description of or notes for the contact."
  description: String
  "State of the contact."
  active: Boolean
}
"Autogenerated input type of CustomerRelationsOrganizationCreate"
input CustomerRelationsOrganizationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group for the organization."
  groupId: GroupID!
  "Name of the organization."
  name: String!
  "Standard billing rate for the organization."
  defaultRate: Float
  "Description of or notes for the organization."
  description: String
}
"Autogenerated input type of CustomerRelationsOrganizationUpdate"
input CustomerRelationsOrganizationUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the organization."
  id: CustomerRelationsOrganizationID!
  "Name of the organization."
  name: String
  "Standard billing rate for the organization."
  defaultRate: Float
  "Description of or notes for the organization."
  description: String
  "State of the organization."
  active: Boolean
}
"Autogenerated input type of DeleteAnnotation"
input DeleteAnnotationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the annotation to delete."
  id: String!
}
"Autogenerated input type of DeleteContainerProtectionRepositoryRule"
input DeleteContainerProtectionRepositoryRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the container repository protection rule to delete."
  id: ContainerRegistryProtectionRuleID!
}
"Autogenerated input type of DeleteContainerProtectionTagRule"
input DeleteContainerProtectionTagRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the tag protection rule to delete."
  id: ContainerRegistryProtectionTagRuleID!
}
"Autogenerated input type of DeletePackagesProtectionRule"
input DeletePackagesProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the package protection rule to delete."
  id: PackagesProtectionRuleID!
}
"Autogenerated input type of DeletePagesDeployment"
input DeletePagesDeploymentInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Pages Deployment."
  id: PagesDeploymentID!
}
"Values for ordering deployments by a specific field"
input DeploymentsOrderByInput {
  "Order by Created time."
  createdAt: SortDirectionEnum
  "Order by Finished time."
  finishedAt: SortDirectionEnum
}
"Autogenerated input type of DesignManagementDelete"
input DesignManagementDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project where the issue is to upload designs for."
  projectPath: ID!
  "IID of the issue to modify designs for."
  iid: ID!
  "Filenames of the designs to delete."
  filenames: [String!]!
}
"Autogenerated input type of DesignManagementMove"
input DesignManagementMoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the design to move."
  id: DesignManagementDesignID!
  "ID of the immediately preceding design."
  previous: DesignManagementDesignID
  "ID of the immediately following design."
  next: DesignManagementDesignID
}
"Autogenerated input type of DesignManagementUpdate"
input DesignManagementUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the design to update."
  id: DesignManagementDesignID!
  "Description of the design."
  description: String
}
"Autogenerated input type of DesignManagementUpload"
input DesignManagementUploadInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project where the issue is to upload designs for."
  projectPath: ID!
  "IID of the issue to modify designs for."
  iid: ID!
  "Files to upload."
  files: [Upload!]!
}
"Autogenerated input type of DestroyBoard"
input DestroyBoardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the board to destroy."
  id: BoardID!
}
"Autogenerated input type of DestroyBoardList"
input DestroyBoardListInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the list to destroy. Only label lists are accepted."
  listId: ListID!
}
"Autogenerated input type of DestroyContainerRepository"
input DestroyContainerRepositoryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the container repository."
  id: ContainerRepositoryID!
}
"Autogenerated input type of DestroyContainerRepositoryTags"
input DestroyContainerRepositoryTagsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the container repository."
  id: ContainerRepositoryID!
  "Container repository tag(s) to delete. Total number can't be greater than 20"
  tagNames: [String!]!
}
"Autogenerated input type of DestroyCustomEmoji"
input DestroyCustomEmojiInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the custom emoji to destroy."
  id: CustomEmojiID!
}
"Autogenerated input type of DestroyNote"
input DestroyNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the note to destroy."
  id: NoteID!
}
"Autogenerated input type of DestroyPackageFile"
input DestroyPackageFileInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Package file."
  id: PackagesPackageFileID!
}
"Autogenerated input type of DestroyPackageFiles"
input DestroyPackageFilesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project path where the packages cleanup policy is located."
  projectPath: ID!
  "IDs of the Package file."
  ids: [PackagesPackageFileID!]!
}
"Autogenerated input type of DestroyPackage"
input DestroyPackageInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Package."
  id: PackagesPackageID!
}
"Autogenerated input type of DestroyPackages"
input DestroyPackagesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the Packages. Max 100"
  ids: [PackagesPackageID!]!
}
"Autogenerated input type of DestroySnippet"
input DestroySnippetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the snippet to destroy."
  id: SnippetID!
}
input DiffImagePositionInput {
  "Merge base of the branch the comment was made on."
  baseSha: String
  "SHA of the HEAD at the time the comment was made."
  headSha: String!
  "SHA of the branch being compared against."
  startSha: String!
  "The paths of the file that was changed. Both of the properties of this input are optional, but at least one of them is required"
  paths: DiffPathsInput!
  "Total height of the image."
  height: Int!
  "Total width of the image."
  width: Int!
  "X position of the note."
  x: Int!
  "Y position of the note."
  y: Int!
}
input DiffPathsInput {
  "Path of the file on the HEAD SHA."
  newPath: String
  "Path of the file on the start SHA."
  oldPath: String
}
input DiffPositionInput {
  "Merge base of the branch the comment was made on."
  baseSha: String
  "SHA of the HEAD at the time the comment was made."
  headSha: String!
  "SHA of the branch being compared against."
  startSha: String!
  "The paths of the file that was changed. Both of the properties of this input are optional, but at least one of them is required"
  paths: DiffPathsInput!
  "Line on HEAD SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field."
  newLine: Int
  "Line on start SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field."
  oldLine: Int
}
"Autogenerated input type of DiscussionToggleResolve"
input DiscussionToggleResolveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the discussion."
  id: DiscussionID!
  "Will resolve the discussion when true, and unresolve the discussion when false."
  resolve: Boolean!
}
"Autogenerated input type of EchoCreate"
input EchoCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors to return to the user."
  errors: [String!]
  "Messages to return to the user."
  messages: [String!]
}
"Autogenerated input type of EnvironmentCreate"
input EnvironmentCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
  "Name of the environment."
  name: String!
  "Description of the environment."
  description: String
  "External URL of the environment."
  externalUrl: String
  "Tier of the environment."
  tier: DeploymentTier
  "Cluster agent of the environment."
  clusterAgentId: ClustersAgentID
  "Kubernetes namespace of the environment."
  kubernetesNamespace: String
  "Flux resource path of the environment."
  fluxResourcePath: String
  "Auto stop setting of the environment."
  autoStopSetting: AutoStopSetting
}
"Autogenerated input type of EnvironmentDelete"
input EnvironmentDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the environment to Delete."
  id: EnvironmentID!
}
"Autogenerated input type of EnvironmentStop"
input EnvironmentStopInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the environment to stop."
  id: EnvironmentID!
  "Force environment to stop without executing on_stop actions."
  force: Boolean
}
"Autogenerated input type of EnvironmentUpdate"
input EnvironmentUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the environment to update."
  id: EnvironmentID!
  "Description of the environment."
  description: String
  "External URL of the environment."
  externalUrl: String
  "Tier of the environment."
  tier: DeploymentTier
  "Cluster agent of the environment."
  clusterAgentId: ClustersAgentID
  "Kubernetes namespace of the environment."
  kubernetesNamespace: String
  "Flux resource path of the environment."
  fluxResourcePath: String
  "Auto stop setting of the environment."
  autoStopSetting: AutoStopSetting
}
"Autogenerated input type of EnvironmentsCanaryIngressUpdate"
input EnvironmentsCanaryIngressUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the environment to update."
  id: EnvironmentID!
  "Weight of the Canary Ingress."
  weight: Int!
}
"Autogenerated input type of GroupMemberBulkUpdate"
input GroupMemberBulkUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the members."
  userIds: [UserID!]!
  "Access level to update the members to."
  accessLevel: MemberAccessLevel!
  "Date and time the membership expires."
  expiresAt: Time
  "Global ID of the group."
  groupId: GroupID!
}
"Autogenerated input type of GroupUpdate"
input GroupUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the group that will be updated."
  fullPath: ID!
  "Indicates if math rendering limits are locked for all descendant groups."
  lockMathRenderingLimitsEnabled: Boolean
  "Indicates if math rendering limits are used for the group."
  mathRenderingLimitsEnabled: Boolean
  "Name of the group."
  name: String
  "Path of the namespace."
  path: String
  "Shared runners availability for the namespace and its descendants."
  sharedRunnersSetting: SharedRunnersSetting
  "Visibility of the namespace."
  visibility: VisibilityLevelsEnum
}
"Autogenerated input type of HttpIntegrationCreate"
input HttpIntegrationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project to create the integration in."
  projectPath: ID!
  "Name of the integration."
  name: String!
  "Whether the integration is receiving alerts."
  active: Boolean!
}
"Autogenerated input type of HttpIntegrationDestroy"
input HttpIntegrationDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to remove."
  id: AlertManagementHttpIntegrationID!
}
"Autogenerated input type of HttpIntegrationResetToken"
input HttpIntegrationResetTokenInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: AlertManagementHttpIntegrationID!
}
"Autogenerated input type of HttpIntegrationUpdate"
input HttpIntegrationUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: AlertManagementHttpIntegrationID!
  "Name of the integration."
  name: String
  "Whether the integration is receiving alerts."
  active: Boolean
}
"Autogenerated input type of ImportSourceUserCancelReassignment"
input ImportSourceUserCancelReassignmentInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the mapping of a user on source instance to a user on destination instance."
  id: ImportSourceUserID!
}
"Autogenerated input type of ImportSourceUserKeepAllAsPlaceholder"
input ImportSourceUserKeepAllAsPlaceholderInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the namespace."
  namespaceId: NamespaceID!
}
"Autogenerated input type of ImportSourceUserKeepAsPlaceholder"
input ImportSourceUserKeepAsPlaceholderInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the mapping of a user on source instance to a user on destination instance."
  id: ImportSourceUserID!
}
"Autogenerated input type of ImportSourceUserReassign"
input ImportSourceUserReassignInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the mapping of a user on source instance to a user on destination instance."
  id: ImportSourceUserID!
  "Global ID of the assignee user."
  assigneeUserId: UserID!
}
"Autogenerated input type of ImportSourceUserResendNotification"
input ImportSourceUserResendNotificationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the mapping of a user on source instance to a user on destination instance."
  id: ImportSourceUserID!
}
"Autogenerated input type of IntegrationExclusionCreate"
input IntegrationExclusionCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Type of integration to exclude."
  integrationName: IntegrationType!
  "IDs of projects to exclude up to a maximum of 100."
  projectIds: [ProjectID!]
  "IDs of groups to exclude up to a maximum of 100."
  groupIds: [GroupID!]
}
"Autogenerated input type of IntegrationExclusionDelete"
input IntegrationExclusionDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Type of integration."
  integrationName: IntegrationType!
  "IDs of excluded projects."
  projectIds: [ProjectID!]
  "IDs of excluded groups."
  groupIds: [GroupID!]
}
"Autogenerated input type of IssueLinkAlerts"
input IssueLinkAlertsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Alerts references to be linked to the incident."
  alertReferences: [String!]!
}
"Autogenerated input type of IssueMove"
input IssueMoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Project to move the issue to."
  targetProjectPath: ID!
}
"Autogenerated input type of IssueMoveList"
input IssueMoveListInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the board that the issue is in."
  boardId: BoardID!
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "ID of the board list that the issue will be moved from."
  fromListId: ID
  "ID of the board list that the issue will be moved to."
  toListId: ID
  "ID of issue that should be placed before the current issue."
  moveBeforeId: ID
  "ID of issue that should be placed after the current issue."
  moveAfterId: ID
  "Position of issue within the board list. Positions start at 0. Use -1 to move to the end of the list."
  positionInList: Int
}
"Autogenerated input type of IssueSetAssignees"
input IssueSetAssigneesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Usernames to assign to the resource. Replaces existing assignees by default."
  assigneeUsernames: [String!]!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode = REPLACE
}
"Autogenerated input type of IssueSetConfidential"
input IssueSetConfidentialInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Whether or not to set the issue as a confidential."
  confidential: Boolean!
}
"Autogenerated input type of IssueSetCrmContacts"
input IssueSetCrmContactsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Customer relations contact IDs to set. Replaces existing contacts by default."
  contactIds: [CustomerRelationsContactID!]!
  "Changes the operation mode. Defaults to REPLACE."
  operationMode: MutationOperationMode
}
"Autogenerated input type of IssueSetDueDate"
input IssueSetDueDateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Desired due date for the issue. Due date is removed if null."
  dueDate: Time
}
"Autogenerated input type of IssueSetEscalationStatus"
input IssueSetEscalationStatusInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Set the escalation status."
  status: IssueEscalationStatus!
}
"Autogenerated input type of IssueSetLocked"
input IssueSetLockedInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Whether or not to lock discussion on the issue."
  locked: Boolean!
}
"Autogenerated input type of IssueSetSeverity"
input IssueSetSeverityInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Set the incident severity level."
  severity: IssuableSeverity!
}
"Autogenerated input type of IssueSetSubscription"
input IssueSetSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Desired state of the subscription."
  subscribedState: Boolean!
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
}
"Autogenerated input type of IssueUnlinkAlert"
input IssueUnlinkAlertInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Global ID of the alert to unlink from the incident."
  alertId: AlertManagementAlertID!
}
"Autogenerated input type of IssuesBulkUpdate"
input IssuesBulkUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  """
  Global ID of the parent to which the bulk update will be scoped. The parent can be a project. The parent can also be a group (Premium and Ultimate only). Example `IssueParentID` are `"gid://gitlab/Project/1"` and `"gid://gitlab/Group/1"`.
  """
  parentId: IssueParentID!
  "Global ID array of the issues that will be updated. IDs that the user can't update will be ignored. A max of 100 can be provided."
  ids: [IssueID!]!
  "Global ID array of the users that will be assigned to the given issues. Existing assignees will be replaced with the ones on this list."
  assigneeIds: [UserID!]
  "Global ID of the milestone that will be assigned to the issues."
  milestoneId: MilestoneID
  "Close or reopen an issue."
  stateEvent: IssueStateEvent
  "Global ID array of the labels that will be added to the issues. "
  addLabelIds: [LabelID!]
  "Global ID array of the labels that will be removed from the issues. "
  removeLabelIds: [LabelID!]
  "Subscribe to or unsubscribe from issue notifications."
  subscriptionEvent: IssuableSubscriptionEvent
}
"Autogenerated input type of JiraImportStart"
input JiraImportStartInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project key of the importer Jira project."
  jiraProjectKey: String!
  "Project to import the Jira project into."
  projectPath: ID!
  "Mapping of Jira to GitLab users."
  usersMapping: [JiraUsersMappingInputType!]
}
"Autogenerated input type of JiraImportUsers"
input JiraImportUsersInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project to import the Jira users into."
  projectPath: ID!
  "Index of the record the import should started at, default 0 (50 records returned)."
  startAt: Int
}
input JiraUsersMappingInputType {
  "ID of the GitLab user."
  gitlabId: Int
  "Jira account ID of the user."
  jiraAccountId: String!
}
"Autogenerated input type of JobArtifactsDestroy"
input JobArtifactsDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiBuildID!
}
"Autogenerated input type of JobCancel"
input JobCancelInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiBuildID!
}
"Autogenerated input type of JobPlay"
input JobPlayInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiProcessableID!
  "Variables to use when playing a manual job."
  variables: [CiVariableInput!] = []
}
"Autogenerated input type of JobRetry"
input JobRetryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiProcessableID!
  "Variables to use when retrying a manual job."
  variables: [CiVariableInput!] = []
}
"Autogenerated input type of JobUnschedule"
input JobUnscheduleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiBuildID!
}
"Autogenerated input type of LabelCreate"
input LabelCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Title of the label."
  title: String!
  "Description of the label."
  description: String
  """
  The color of the label given in 6-digit hex notation with leading '#' sign
  (for example, `#FFAABB`) or one of the CSS color names.
  """
  color: String = "#6699cc"
}
"Autogenerated input type of MarkAsSpamSnippet"
input MarkAsSpamSnippetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the snippet to update."
  id: SnippetID!
}
"Defines which user roles, users, or groups can merge into a protected branch."
input MergeAccessLevelInput {
  "Access level allowed to perform action."
  accessLevel: Int
}
"Autogenerated input type of MergeRequestAccept"
input MergeRequestAcceptInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  "How to merge the merge request."
  strategy: MergeStrategyEnum
  "Custom merge commit message."
  commitMessage: String
  "HEAD SHA at the time when the merge was requested."
  sha: String!
  "Custom squash commit message (if squash is true)."
  squashCommitMessage: String
  "Should the source branch be removed."
  shouldRemoveSourceBranch: Boolean
  "Squash commits on the source branch before merge."
  squash: Boolean = false
}
"Autogenerated input type of MergeRequestCreate"
input MergeRequestCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project full path the merge request is associated with."
  projectPath: ID!
  "Title of the merge request."
  title: String!
  "Source branch of the merge request."
  sourceBranch: String!
  "Target branch of the merge request."
  targetBranch: String!
  "Description of the merge request (Markdown rendered as HTML for caching)."
  description: String
  "Labels of the merge request."
  labels: [String!]
  "Date after which the merge request can be merged."
  mergeAfter: Time
}
"Autogenerated input type of MergeRequestReviewerRereview"
input MergeRequestReviewerRereviewInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  """
  User ID for the user that has been requested for a new review.
  """
  userId: UserID!
}
"Autogenerated input type of MergeRequestSetAssignees"
input MergeRequestSetAssigneesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  "Usernames to assign to the resource. Replaces existing assignees by default."
  assigneeUsernames: [String!]!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode = REPLACE
}
"Autogenerated input type of MergeRequestSetDraft"
input MergeRequestSetDraftInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  """
  Whether or not to set the merge request as a draft.
  """
  draft: Boolean!
}
"Autogenerated input type of MergeRequestSetLabels"
input MergeRequestSetLabelsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  """
  Label IDs to set. Replaces existing labels by default.
  """
  labelIds: [LabelID!]!
  """
  Changes the operation mode. Defaults to REPLACE.
  """
  operationMode: MutationOperationMode
}
"Autogenerated input type of MergeRequestSetLocked"
input MergeRequestSetLockedInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  """
  Whether or not to lock the merge request.
  """
  locked: Boolean!
}
"Autogenerated input type of MergeRequestSetMilestone"
input MergeRequestSetMilestoneInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  """
  Milestone to assign to the merge request.
  """
  milestoneId: MilestoneID
}
"Autogenerated input type of MergeRequestSetReviewers"
input MergeRequestSetReviewersInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  "Usernames of reviewers to assign. Replaces existing reviewers by default."
  reviewerUsernames: [String!]!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode = REPLACE
}
"Autogenerated input type of MergeRequestSetSubscription"
input MergeRequestSetSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Desired state of the subscription."
  subscribedState: Boolean!
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
}
"Autogenerated input type of MergeRequestUpdate"
input MergeRequestUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the merge request to mutate is in."
  projectPath: ID!
  "IID of the merge request to mutate."
  iid: String!
  "Title of the merge request."
  title: String
  "Target branch of the merge request."
  targetBranch: String
  "Description of the merge request (Markdown rendered as HTML for caching)."
  description: String
  "Action to perform to change the state."
  state: MergeRequestNewState
  "Estimated time to complete the merge request. Use `null` or `0` to remove the current estimate."
  timeEstimate: String
  "Date after which the merge request can be merged."
  mergeAfter: Time
}
input MergeRequestsResolverNegatedParams {
  "Filters merge requests to exclude any that are approved by usernames in the given array."
  approvedBy: [String!]
  "Filters merge requests to exclude any that are assigned to the usernames in the given array."
  assigneeUsernames: [String!]
  "Filters merge requests to exclude any that are authored by the given user."
  authorUsername: String
  "Filters merge requests to exclude any that have the labels provided in the given array."
  labelName: [String!]
  "Filters merge requests to those not in the given milestone."
  milestoneTitle: String
  "Filters merge requests to those without the given reaction from the authenticated user."
  myReactionEmoji: String
  "Filters merge requests to those without the given release tag."
  releaseTag: String
  "Filters merge requests to those not reviewed by the given user."
  reviewerUsername: String
  "Filters merge requests to exclude the source branch names provided in the given array."
  sourceBranches: [String!]
  "Filters merge requests to exclude the target branch names provided in the given array."
  targetBranches: [String!]
}
"Autogenerated input type of MlModelCreate"
input MlModelCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the model to mutate is in."
  projectPath: ID!
  "Name of the model."
  name: String!
  "Description of the model."
  description: String
}
"Autogenerated input type of MlModelDelete"
input MlModelDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the model to mutate is in."
  projectPath: ID!
  "Global ID of the model to be deleted."
  id: MlModelID!
}
"Autogenerated input type of MlModelDestroy"
input MlModelDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the model to mutate is in."
  projectPath: ID!
  "Global ID of the model to be deleted."
  id: MlModelID!
}
"Autogenerated input type of MlModelEdit"
input MlModelEditInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the model to mutate is in."
  projectPath: ID!
  "Id of the model."
  modelId: Int
  "Name of the model."
  name: String!
  "Description of the model."
  description: String
}
"Autogenerated input type of MlModelVersionCreate"
input MlModelVersionCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the model to mutate is in."
  projectPath: ID!
  "Global ID of the model the version belongs to."
  modelId: MlModelID!
  "Model version."
  version: String
  "Description of the model version."
  description: String
  "Global ID of a candidate to promote optionally."
  candidateId: MlCandidateID
}
"Autogenerated input type of MlModelVersionDelete"
input MlModelVersionDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the model version to be deleted."
  id: MlModelVersionID!
}
"Autogenerated input type of MlModelVersionEdit"
input MlModelVersionEditInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the model to mutate is in."
  projectPath: ID!
  "Global ID of the model the version belongs to."
  modelId: MlModelID!
  "Model version."
  version: String!
  "Description of the model version."
  description: String!
}
"Autogenerated input type of NamespaceSettingsUpdate"
input NamespaceSettingsUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the namespace the settings belong to."
  fullPath: ID!
  "Indicates the default minimum role required to override pipeline variables in the namespace."
  pipelineVariablesDefaultRole: PipelineVariablesDefaultRoleType
}
input NegatedBoardIssueInput {
  "Filter by label name."
  labelName: [String]
  "Filter by author username."
  authorUsername: String
  """
  Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported.
  """
  myReactionEmoji: String
  """
  List of IIDs of issues. For example `["1", "2"]`.
  """
  iids: [String!]
  "Filter by milestone title."
  milestoneTitle: String
  "Filter by assignee username."
  assigneeUsername: [String]
  "Filter by release tag."
  releaseTag: String
  "Filter by the given issue types."
  types: [IssueType!]
  "Filter by milestone ID wildcard."
  milestoneWildcardId: MilestoneWildcardId
}
input NegatedIssueFilterInput {
  "ID of a user not assigned to the issues."
  assigneeId: String
  "Usernames of users not assigned to the issue."
  assigneeUsernames: [String!]
  "Username of a user who didn't author the issue."
  authorUsername: [String!]
  "List of IIDs of issues to exclude. For example, `[1, 2]`."
  iids: [String!]
  "Labels not applied to the issue."
  labelName: [String!]
  "Milestone not applied to the issue."
  milestoneTitle: [String!]
  "Filter by negated milestone wildcard values."
  milestoneWildcardId: NegatedMilestoneWildcardId
  "Filter by reaction emoji applied by the current user."
  myReactionEmoji: String
  "Release tag not associated with the issue's milestone. Ignored when parent is a group."
  releaseTag: [String!]
  "Filters out issues by the given issue types."
  types: [IssueType!]
}
input NegatedWorkItemFilterInput {
  "Usernames of users not assigned to the work item."
  assigneeUsernames: [String!]
  "Username of a user who didn't author the work item."
  authorUsername: [String!]
  "Labels not applied to the work item."
  labelName: [String!]
  "Milestone not applied to the work item."
  milestoneTitle: [String!]
  "Filter by negated milestone wildcard values."
  milestoneWildcardId: NegatedMilestoneWildcardId
  "Filter by reaction emoji not applied by the current user."
  myReactionEmoji: String
  "Filter out work items by the given types."
  types: [IssueType!]
}
"Autogenerated input type of NoteConvertToThread"
input NoteConvertToThreadInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Note to convert."
  id: NoteID!
}
"Autogenerated input type of OrganizationCreate"
input OrganizationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the organization."
  description: String
  "Avatar for the organization."
  avatar: Upload
  "Name for the organization."
  name: String!
  "Path for the organization."
  path: String!
}
"Autogenerated input type of OrganizationUpdate"
input OrganizationUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the organization."
  description: String
  "Avatar for the organization."
  avatar: Upload
  "ID of the organization to mutate."
  id: OrganizationsOrganizationID!
  "Name for the organization."
  name: String
  "Path for the organization."
  path: String
}
"Autogenerated input type of OrganizationUserUpdate"
input OrganizationUserUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Access level to update the organization user to."
  accessLevel: OrganizationUserAccessLevel!
  "ID of the organization user to mutate."
  id: OrganizationsOrganizationUserID!
}
"Autogenerated input type of PagesMarkOnboardingComplete"
input PagesMarkOnboardingCompleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}
"Autogenerated input type of PipelineCancel"
input PipelineCancelInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline to mutate."
  id: CiPipelineID!
}
"Autogenerated input type of PipelineCreate"
input PipelineCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project that is triggering the pipeline."
  projectPath: ID!
  "Ref on which to run the pipeline."
  ref: String!
  "Variables for the pipeline."
  variables: [CiVariableInput!]
}
"Autogenerated input type of PipelineDestroy"
input PipelineDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline to mutate."
  id: CiPipelineID!
}
"Autogenerated input type of PipelineRetry"
input PipelineRetryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline to mutate."
  id: CiPipelineID!
}
"Autogenerated input type of PipelineScheduleCreate"
input PipelineScheduleCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project the pipeline schedule is associated with."
  projectPath: ID!
  "Description of the pipeline schedule."
  description: String!
  "Cron expression of the pipeline schedule."
  cron: String!
  """
                      Cron time zone supported by ActiveSupport::TimeZone.
                      For example: "Pacific Time (US & Canada)" (default: "UTC").
  """
  cronTimezone: String
  "Ref of the pipeline schedule."
  ref: String!
  "Indicates if the pipeline schedule should be active or not."
  active: Boolean
  "Variables for the pipeline schedule."
  variables: [PipelineScheduleVariableInput!]
}
"Autogenerated input type of PipelineScheduleDelete"
input PipelineScheduleDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
}
"Autogenerated input type of PipelineSchedulePlay"
input PipelineSchedulePlayInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
}
"Autogenerated input type of PipelineScheduleTakeOwnership"
input PipelineScheduleTakeOwnershipInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
}
"Autogenerated input type of PipelineScheduleUpdate"
input PipelineScheduleUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
  "Description of the pipeline schedule."
  description: String
  "Cron expression of the pipeline schedule."
  cron: String
  """
                      Cron time zone supported by ActiveSupport::TimeZone.
                      For example: "Pacific Time (US & Canada)" (default: "UTC").
  """
  cronTimezone: String
  "Ref of the pipeline schedule."
  ref: String
  "Indicates if the pipeline schedule should be active or not."
  active: Boolean
  "Variables for the pipeline schedule."
  variables: [PipelineScheduleVariableInput!]
}
"Attributes for the pipeline schedule variable."
input PipelineScheduleVariableInput {
  "ID of the variable to mutate."
  id: CiPipelineScheduleVariableID
  "Name of the variable."
  key: String!
  "Value of the variable."
  value: String!
  "Type of the variable."
  variableType: CiVariableType!
  "Boolean option to destroy the variable."
  destroy: Boolean
}
"Autogenerated input type of PipelineTriggerCreate"
input PipelineTriggerCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project that the pipeline trigger token to mutate is in."
  projectPath: ID!
  "Description of the pipeline trigger token."
  description: String!
  "Timestamp of when the pipeline trigger token expires."
  expiresAt: Time
}
"Autogenerated input type of PipelineTriggerDelete"
input PipelineTriggerDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline trigger token to delete."
  id: CiTriggerID!
}
"Autogenerated input type of PipelineTriggerUpdate"
input PipelineTriggerUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline trigger token to update."
  id: CiTriggerID!
  "Description of the pipeline trigger token."
  description: String!
}
"Autogenerated input type of ProjectCiCdSettingsUpdate"
input ProjectCiCdSettingsUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full Path of the project the settings belong to."
  fullPath: ID!
  "Indicates if the latest artifact should be kept for the project."
  keepLatestArtifact: Boolean
  "Indicates CI/CD job tokens generated in other projects have restricted access to this project."
  inboundJobTokenScopeEnabled: Boolean
  "Indicates the ability to push to the original project repository using a job token"
  pushRepositoryForJobTokenAllowed: Boolean
  "Minimum role required to set variables when creating a pipeline or running a job."
  pipelineVariablesMinimumOverrideRole: String
}
"Autogenerated input type of ProjectMemberBulkUpdate"
input ProjectMemberBulkUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the members."
  userIds: [UserID!]!
  "Access level to update the members to."
  accessLevel: MemberAccessLevel!
  "Date and time the membership expires."
  expiresAt: Time
  "Global ID of the project."
  projectId: ProjectID!
}
"Autogenerated input type of ProjectSyncFork"
input ProjectSyncForkInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project to initialize."
  projectPath: ID!
  "Ref of the fork to fetch into."
  targetBranch: String!
}
"Autogenerated input type of PrometheusIntegrationCreate"
input PrometheusIntegrationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project to create the integration in."
  projectPath: ID!
  "Whether the integration is receiving alerts."
  active: Boolean!
  "Endpoint at which Prometheus can be queried."
  apiUrl: String
}
"Autogenerated input type of PrometheusIntegrationResetToken"
input PrometheusIntegrationResetTokenInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: IntegrationsPrometheusID!
}
"Autogenerated input type of PrometheusIntegrationUpdate"
input PrometheusIntegrationUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: IntegrationsPrometheusID!
  "Whether the integration is receiving alerts."
  active: Boolean
  "Endpoint at which Prometheus can be queried."
  apiUrl: String
}
"Defines which user roles, users, deploy keys, or groups can push to a protected branch."
input PushAccessLevelInput {
  "Access level allowed to perform action."
  accessLevel: Int
  "Deploy key assigned to the access level."
  deployKeyId: DeployKeyID
}
"Autogenerated input type of ReleaseAssetLinkCreate"
input ReleaseAssetLinkCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Name of the asset link."
  name: String!
  "URL of the asset link."
  url: String!
  "Relative path for a direct asset link."
  directAssetPath: String
  "Type of the asset link."
  linkType: ReleaseAssetLinkType = OTHER
  "Full path of the project the asset link is associated with."
  projectPath: ID!
  "Name of the associated release's tag."
  tagName: String!
}
"Autogenerated input type of ReleaseAssetLinkDelete"
input ReleaseAssetLinkDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the release asset link to delete."
  id: ReleasesLinkID!
}
"Fields that are available when modifying a release asset link"
input ReleaseAssetLinkInput {
  "Name of the asset link."
  name: String!
  "URL of the asset link."
  url: String!
  "Relative path for a direct asset link."
  directAssetPath: String
  "Type of the asset link."
  linkType: ReleaseAssetLinkType = OTHER
}
"Autogenerated input type of ReleaseAssetLinkUpdate"
input ReleaseAssetLinkUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the release asset link to update."
  id: ReleasesLinkID!
  "Name of the asset link."
  name: String
  "URL of the asset link."
  url: String
  "Relative path for a direct asset link."
  directAssetPath: String
  "Type of the asset link."
  linkType: ReleaseAssetLinkType
}
"Fields that are available when modifying release assets"
input ReleaseAssetsInput {
  "List of asset links to associate to the release."
  links: [ReleaseAssetLinkInput!]
}
"Autogenerated input type of ReleaseCreate"
input ReleaseCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project the release is associated with."
  projectPath: ID!
  "Name of the tag to associate with the release."
  tagName: String!
  "Message to use if creating a new annotated tag."
  tagMessage: String
  "Commit SHA or branch name to use if creating a new tag."
  ref: String
  "Name of the release."
  name: String
  """
  Description (also known as "release notes") of the release.
  """
  description: String
  "Date and time for the release. Defaults to the current time. Expected in ISO 8601 format (`2019-03-15T08:00:00Z`). Only provide this field if creating an upcoming or historical release."
  releasedAt: Time
  "Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones."
  milestones: [String!]
  "Assets associated to the release."
  assets: ReleaseAssetsInput
}
"Autogenerated input type of ReleaseDelete"
input ReleaseDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project the release is associated with."
  projectPath: ID!
  "Name of the tag associated with the release to delete."
  tagName: String!
}
"Autogenerated input type of ReleaseUpdate"
input ReleaseUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project the release is associated with."
  projectPath: ID!
  "Name of the tag associated with the release."
  tagName: String!
  "Name of the release."
  name: String
  "Description (release notes) of the release."
  description: String
  "Release date."
  releasedAt: Time
  "Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones."
  milestones: [String!]
}
"Autogenerated input type of RepositionImageDiffNote"
input RepositionImageDiffNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the DiffNote to update."
  id: DiffNoteID!
  "Position of the note on a diff."
  position: UpdateDiffImagePositionInput!
}
"Autogenerated input type of RestorePagesDeployment"
input RestorePagesDeploymentInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Pages Deployment."
  id: PagesDeploymentID!
}
"Autogenerated input type of RunnerBulkPause"
input RunnerBulkPauseInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IDs of the runners to pause or unpause."
  ids: [CiRunnerID!]!
  "Indicates the runner is not allowed to receive jobs."
  paused: Boolean!
}
"Autogenerated input type of RunnerCacheClear"
input RunnerCacheClearInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the project that will have its runner cache cleared."
  projectId: ProjectID!
}
"Autogenerated input type of RunnerCreate"
input RunnerCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the runner."
  description: String
  "Runner's maintenance notes."
  maintenanceNote: String
  "Maximum timeout (in seconds) for jobs processed by the runner."
  maximumTimeout: Int
  "Access level of the runner."
  accessLevel: CiRunnerAccessLevel
  "Indicates the runner is not allowed to receive jobs."
  paused: Boolean
  "Indicates the runner is locked."
  locked: Boolean
  "Indicates the runner is able to run untagged jobs."
  runUntagged: Boolean
  "Tags associated with the runner."
  tagList: [String!]
  "Type of the runner to create."
  runnerType: CiRunnerType!
  "Global ID of the group that the runner is created in (valid only for group runner)."
  groupId: GroupID
  "Global ID of the project that the runner is created in (valid only for project runner)."
  projectId: ProjectID
}
"Autogenerated input type of RunnerDelete"
input RunnerDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the runner to delete."
  id: CiRunnerID!
}
"Autogenerated input type of RunnerUpdate"
input RunnerUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the runner."
  description: String
  "Runner's maintenance notes."
  maintenanceNote: String
  "Maximum timeout (in seconds) for jobs processed by the runner."
  maximumTimeout: Int
  "Access level of the runner."
  accessLevel: CiRunnerAccessLevel
  "Indicates the runner is not allowed to receive jobs."
  paused: Boolean
  "Indicates the runner is locked."
  locked: Boolean
  "Indicates the runner is able to run untagged jobs."
  runUntagged: Boolean
  "Tags associated with the runner."
  tagList: [String!]
  "ID of the runner to update."
  id: CiRunnerID!
  "Projects associated with the runner. Available only for project runners."
  associatedProjects: [ProjectID!]
}
"Autogenerated input type of RunnersRegistrationTokenReset"
input RunnersRegistrationTokenResetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Scope of the object to reset the token for."
  type: CiRunnerType!
  "ID of the project or group to reset the token for. Omit if resetting instance runner token."
  id: ID
}
"Represents the analyzers entity in SAST CI configuration"
input SastCiConfigurationAnalyzersEntityInput {
  "Name of analyzer."
  name: String!
  "State of the analyzer."
  enabled: Boolean!
  "List of variables for the analyzer."
  variables: [SastCiConfigurationEntityInput!]
}
"Represents an entity in SAST CI configuration"
input SastCiConfigurationEntityInput {
  "CI keyword of entity."
  field: String!
  "Default value that is used if value is empty."
  defaultValue: String!
  "Current value of the entity."
  value: String!
}
"Represents a CI configuration of SAST"
input SastCiConfigurationInput {
  "List of global entities related to SAST configuration."
  global: [SastCiConfigurationEntityInput!]
  "List of pipeline entities related to SAST configuration."
  pipeline: [SastCiConfigurationEntityInput!]
  "List of analyzers and related variables for the SAST configuration."
  analyzers: [SastCiConfigurationAnalyzersEntityInput!]
}
"Autogenerated input type of SavedReplyCreate"
input SavedReplyCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Name of the saved reply."
  name: String!
  "Content of the saved reply."
  content: String!
}
"Autogenerated input type of SavedReplyDestroy"
input SavedReplyDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the user saved reply."
  id: UsersSavedReplyID!
}
"Autogenerated input type of SavedReplyUpdate"
input SavedReplyUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Name of the saved reply."
  name: String!
  "Content of the saved reply."
  content: String!
  "Global ID of the user saved reply."
  id: UsersSavedReplyID!
}
"Represents an action to perform over a snippet file"
input SnippetBlobActionInputType {
  "Type of input action."
  action: SnippetBlobActionEnum!
  "Previous path of the snippet file."
  previousPath: String
  "Path of the snippet file."
  filePath: String!
  "Snippet file content."
  content: String
}
"Autogenerated input type of StarProject"
input StarProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project to star or unstar."
  projectId: ProjectID!
  "Indicates whether to star or unstar the project."
  starred: Boolean!
}
"Autogenerated input type of TagCreate"
input TagCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project full path the branch is associated with."
  projectPath: ID!
  "Name of the tag."
  name: String!
  "Tag name or commit SHA to create tag from."
  ref: String!
  "Tagging message."
  message: String = ""
}
"Autogenerated input type of TagDelete"
input TagDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project full path the branch is associated with."
  projectPath: ID!
  "Name of the tag."
  name: String!
}
"Autogenerated input type of TerraformStateDelete"
input TerraformStateDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Terraform state."
  id: TerraformStateID!
}
"Autogenerated input type of TerraformStateLock"
input TerraformStateLockInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Terraform state."
  id: TerraformStateID!
}
"Autogenerated input type of TerraformStateUnlock"
input TerraformStateUnlockInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Terraform state."
  id: TerraformStateID!
}
"A time-frame defined as a closed inclusive range of two dates"
input Timeframe {
  "Start of the range."
  start: Date!
  "End of the range."
  end: Date!
}
"Autogenerated input type of TimelineEventCreate"
input TimelineEventCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Incident ID of the timeline event."
  incidentId: IssueID!
  "Text note of the timeline event."
  note: String!
  "Timestamp of when the event occurred."
  occurredAt: Time!
  "Tags for the incident timeline event."
  timelineEventTagNames: [String!]
}
"Autogenerated input type of TimelineEventDestroy"
input TimelineEventDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Timeline event ID to remove."
  id: IncidentManagementTimelineEventID!
}
"Autogenerated input type of TimelineEventPromoteFromNote"
input TimelineEventPromoteFromNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Note ID from which the timeline event promoted."
  noteId: NoteID!
}
"Autogenerated input type of TimelineEventTagCreate"
input TimelineEventTagCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project to create the timeline event tag in."
  projectPath: ID!
  "Name of the tag."
  name: String!
}
"Autogenerated input type of TimelineEventUpdate"
input TimelineEventUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the timeline event to update."
  id: IncidentManagementTimelineEventID!
  "Text note of the timeline event."
  note: String
  "Timestamp when the event occurred."
  occurredAt: Time
  "Tags for the incident timeline event."
  timelineEventTagNames: [String!]
}
"Autogenerated input type of TimelogCreate"
input TimelogCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Amount of time spent."
  timeSpent: String!
  "Timestamp of when the time was spent. If empty, defaults to current time."
  spentAt: Time
  "Summary of time spent."
  summary: String!
  "Global ID of the issuable (Issue, WorkItem or MergeRequest)."
  issuableId: IssuableID!
}
"Autogenerated input type of TimelogDelete"
input TimelogDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the timelog."
  id: TimelogID!
}
"Autogenerated input type of TodoCreate"
input TodoCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported."
  targetId: TodoableID!
}
"Autogenerated input type of TodoDeleteMany"
input TodoDeleteManyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the to-do items to process (a maximum of 100 is supported at once)."
  ids: [TodoID!]!
}
"Autogenerated input type of TodoMarkDone"
input TodoMarkDoneInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item to mark as done."
  id: TodoID!
}
"Autogenerated input type of TodoResolveMany"
input TodoResolveManyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the to-do items to process (a maximum of 100 is supported at once)."
  ids: [TodoID!]!
}
"Autogenerated input type of TodoRestore"
input TodoRestoreInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item to restore."
  id: TodoID!
}
"Autogenerated input type of TodoRestoreMany"
input TodoRestoreManyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the to-do items to process (a maximum of 100 is supported at once)."
  ids: [TodoID!]!
}
"Autogenerated input type of TodoSnooze"
input TodoSnoozeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item to be snoozed."
  id: TodoID!
  "Time until which the todo should be snoozed."
  snoozeUntil: Time!
}
"Autogenerated input type of TodoSnoozeMany"
input TodoSnoozeManyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the to-do items to process (a maximum of 100 is supported at once)."
  ids: [TodoID!]!
  "Time until which the todos should be snoozed."
  snoozeUntil: Time!
}
"Autogenerated input type of TodoUnSnooze"
input TodoUnSnoozeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item to be snoozed."
  id: TodoID!
}
"Autogenerated input type of TodoUnsnoozeMany"
input TodoUnsnoozeManyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the to-do items to process (a maximum of 100 is supported at once)."
  ids: [TodoID!]!
}
"Autogenerated input type of TodosMarkAllDone"
input TodosMarkAllDoneInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported. If argument is omitted, all pending to-do items of the current user are marked as done."
  targetId: TodoableID
  "ID of an author."
  authorId: [ID!]
  "ID of a project."
  projectId: [ID!]
  "ID of a group."
  groupId: [ID!]
  "Action to be filtered."
  action: [TodoActionEnum!]
  "Type of the todo."
  type: [TodoTargetEnum!]
}
input UnionedIssueFilterInput {
  "Filters issues that are assigned to at least one of the given users."
  assigneeUsernames: [String!]
  "Filters issues that are authored by one of the given users."
  authorUsernames: [String!]
  "Filters issues that have at least one of the given labels."
  labelNames: [String!]
}
input UnionedMergeRequestFilterInput {
  "Filters MRs that are assigned to at least one of the given users."
  assigneeUsernames: [String!]
}
input UnionedWorkItemFilterInput {
  "Filters work items that are assigned to at least one of the given users."
  assigneeUsernames: [String!]
  "Filters work items that are authored by one of the given users."
  authorUsernames: [String!]
  "Filters work items that have at least one of the given labels."
  labelNames: [String!]
}
"Autogenerated input type of UpdateAbuseReportNote"
input UpdateAbuseReportNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the note to update."
  id: AntiAbuseReportsNoteID!
  "Content of the note."
  body: String!
}
"Autogenerated input type of UpdateAlertStatus"
input UpdateAlertStatusInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the alert to mutate is in."
  projectPath: ID!
  "IID of the alert to mutate."
  iid: String!
  "Status to set the alert."
  status: AlertManagementStatus!
}
"Autogenerated input type of UpdateBoard"
input UpdateBoardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Board name."
  name: String
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "Board global ID."
  id: BoardID!
}
"Autogenerated input type of UpdateBoardList"
input UpdateBoardListInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Position of list within the board."
  position: Int
  "Indicates if the list is collapsed for the user."
  collapsed: Boolean
  "Global ID of the list."
  listId: ListID!
}
"Autogenerated input type of UpdateContainerExpirationPolicy"
input UpdateContainerExpirationPolicyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project path where the container expiration policy is located."
  projectPath: ID!
  "Indicates whether the container expiration policy is enabled."
  enabled: Boolean
  "Schedule of the container expiration policy."
  cadence: ContainerExpirationPolicyCadenceEnum
  "Tags older than the given age will expire."
  olderThan: ContainerExpirationPolicyOlderThanEnum
  "Number of tags to retain."
  keepN: ContainerExpirationPolicyKeepEnum
  "Tags with names matching the regex pattern will expire."
  nameRegex: UntrustedRegexp
  "Tags with names matching the regex pattern will be preserved."
  nameRegexKeep: UntrustedRegexp
}
"Autogenerated input type of UpdateContainerProtectionRepositoryRule"
input UpdateContainerProtectionRepositoryRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the container repository protection rule to be updated."
  id: ContainerRegistryProtectionRuleID!
  "Container repository path pattern protected by the protection rule. Must start with the project’s full path. For example: `my-project/*-prod-*`. Wildcard character `*` is allowed anywhere after the project’s full path."
  repositoryPathPattern: String
  "Minimum GitLab access level required to delete container images from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForDelete: ContainerProtectionRepositoryRuleAccessLevel
  "Minimum GitLab access level required to push container images to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForPush: ContainerProtectionRepositoryRuleAccessLevel
}
"Autogenerated input type of UpdateContainerProtectionTagRule"
input UpdateContainerProtectionTagRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the tag protection rule to update."
  id: ContainerRegistryProtectionTagRuleID!
}
"Autogenerated input type of UpdateDependencyProxyImageTtlGroupPolicy"
input UpdateDependencyProxyImageTtlGroupPolicyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group path for the group dependency proxy image TTL policy."
  groupPath: ID!
  "Indicates whether the policy is enabled or disabled."
  enabled: Boolean
  "Number of days to retain a cached image file."
  ttl: Int
}
"Autogenerated input type of UpdateDependencyProxySettings"
input UpdateDependencyProxySettingsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group path for the group dependency proxy."
  groupPath: ID!
  "Indicates whether the policy is enabled or disabled."
  enabled: Boolean
  "Identity credential used to authenticate with Docker Hub when pulling images. Can be a username (for password or personal access token (PAT)) or organization name (for organization access token (OAT))."
  identity: String
  "Secret credential used to authenticate with Docker Hub when pulling images. Can be a password, personal access token (PAT), or organization access token (OAT)."
  secret: String
}
input UpdateDiffImagePositionInput {
  "X position of the note."
  x: Int
  "Y position of the note."
  y: Int
  "Total width of the image."
  width: Int
  "Total height of the image."
  height: Int
}
"Autogenerated input type of UpdateImageDiffNote"
input UpdateImageDiffNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the note to update."
  id: NoteID!
  "Content of the note."
  body: String
  "Position of the note on a diff."
  position: UpdateDiffImagePositionInput
}
"Autogenerated input type of UpdateIssue"
input UpdateIssueInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the issue to mutate is in."
  projectPath: ID!
  "IID of the issue to mutate."
  iid: String!
  "Description of the issue."
  description: String
  "Due date of the issue."
  dueDate: ISO8601Date
  "Indicates the issue is confidential."
  confidential: Boolean
  "Indicates discussion is locked on the issue."
  locked: Boolean
  "Type of the issue."
  type: IssueType
  "Title of the issue."
  title: String
  "ID of the milestone to assign to the issue. On update milestone will be removed if set to null."
  milestoneId: ID
  "IDs of labels to be added to the issue."
  addLabelIds: [ID!]
  "IDs of labels to be removed from the issue."
  removeLabelIds: [ID!]
  "IDs of labels to be set. Replaces existing issue labels."
  labelIds: [ID!]
  "Close or reopen an issue."
  stateEvent: IssueStateEvent
  "Estimated time to complete the issue. Use `null` or `0` to remove the current estimate."
  timeEstimate: String
}
"Autogenerated input type of UpdateNamespacePackageSettings"
input UpdateNamespacePackageSettingsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Namespace path where the namespace package setting is located."
  namespacePath: ID!
  "Indicates whether duplicate Maven packages are allowed for the namespace."
  mavenDuplicatesAllowed: Boolean
  "When maven_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  mavenDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate generic packages are allowed for the namespace."
  genericDuplicatesAllowed: Boolean
  "When generic_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  genericDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate NuGet packages are allowed for the namespace."
  nugetDuplicatesAllowed: Boolean
  "When nuget_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. "
  nugetDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate Terraform packages are allowed for the namespace."
  terraformModuleDuplicatesAllowed: Boolean
  "When terraform_module_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  terraformModuleDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether Maven package forwarding is allowed for the namespace."
  mavenPackageRequestsForwarding: Boolean
  "Indicates whether npm package forwarding is allowed for the namespace."
  npmPackageRequestsForwarding: Boolean
  "Indicates whether PyPI package forwarding is allowed for the namespace."
  pypiPackageRequestsForwarding: Boolean
  "Indicates whether Maven package forwarding is locked for all descendent namespaces."
  lockMavenPackageRequestsForwarding: Boolean
  "Indicates whether npm package forwarding is locked for all descendent namespaces."
  lockNpmPackageRequestsForwarding: Boolean
  "Indicates whether PyPI package forwarding is locked for all descendent namespaces."
  lockPypiPackageRequestsForwarding: Boolean
  "Indicates whether the NuGet symbol server is enabled for the namespace."
  nugetSymbolServerEnabled: Boolean
}
"Autogenerated input type of UpdateNote"
input UpdateNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the note to update."
  id: NoteID!
  "Content of the note."
  body: String
}
"Autogenerated input type of UpdatePackagesCleanupPolicy"
input UpdatePackagesCleanupPolicyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project path where the packages cleanup policy is located."
  projectPath: ID!
  "Number of duplicated package files to retain."
  keepNDuplicatedPackageFiles: PackagesCleanupKeepDuplicatedPackageFilesEnum
}
"Autogenerated input type of UpdatePackagesProtectionRule"
input UpdatePackagesProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the package protection rule to be updated."
  id: PackagesProtectionRuleID!
  "Package name protected by the protection rule. For example, `@my-scope/my-package-*`. Wildcard character `*` allowed."
  packageNamePattern: String
  "Package type protected by the protection rule. For example, `NPM`, `PYPI`."
  packageType: PackagesProtectionRulePackageType
  "Minimum GitLab access required to push packages to the package registry. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, the default minimum access level is `DEVELOPER`."
  minimumAccessLevelForPush: PackagesProtectionRuleAccessLevel
}
"Autogenerated input type of UpdateSnippet"
input UpdateSnippetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the snippet to update."
  id: SnippetID!
  "Title of the snippet."
  title: String
  "Description of the snippet."
  description: String
  "Visibility level of the snippet."
  visibilityLevel: VisibilityLevelsEnum
  "Actions to perform over the snippet repository and blobs."
  blobActions: [SnippetBlobActionInputType!]
}
"Autogenerated input type of UploadDelete"
input UploadDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Secret part of upload path."
  secret: String!
  "Upload filename."
  filename: String!
}
"Autogenerated input type of UserAchievementPrioritiesUpdate"
input UserAchievementPrioritiesUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the user achievements being prioritized, ordered from highest to lowest priority."
  userAchievementIds: [AchievementsUserAchievementID!]!
}
"Autogenerated input type of UserAchievementsDelete"
input UserAchievementsDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the user achievement being deleted."
  userAchievementId: AchievementsUserAchievementID!
}
"Autogenerated input type of UserAchievementsUpdate"
input UserAchievementsUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the user achievement being updated."
  userAchievementId: AchievementsUserAchievementID!
  "Indicates whether or not the user achievement is visible on the profile."
  showOnProfile: Boolean!
}
"Autogenerated input type of UserCalloutCreate"
input UserCalloutCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Feature name you want to dismiss the callout for."
  featureName: String!
}
"Autogenerated input type of UserPreferencesUpdate"
input UserPreferencesUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Status of the Web IDE Extension Marketplace opt-in for the user."
  extensionsMarketplaceOptInStatus: ExtensionsMarketplaceOptInStatus
  "Sort order for issue lists."
  issuesSort: IssueSort
  "Merge request dashboard list rendering type."
  mergeRequestDashboardListType: MergeRequestsDashboardListType
  "Sort order for issue lists."
  mergeRequestsSort: MergeRequestSort
  "Use work item view instead of legacy issue view."
  useWorkItemsView: Boolean
  "Determines whether the pipeline list shows ID or IID."
  visibilityPipelineIdType: VisibilityPipelineIdType
  "Sort order for projects."
  projectsSort: ProjectSort
}
"Autogenerated input type of UserSetNamespaceCommitEmail"
input UserSetNamespaceCommitEmailInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the namespace to set the namespace commit email for."
  namespaceId: NamespaceID!
  "ID of the email to set."
  emailId: EmailID
}
"Autogenerated input type of WorkItemAddClosingMergeRequest"
input WorkItemAddClosingMergeRequestInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the context namespace (project or group). Only project full paths are used to find a merge request using a short reference syntax like `!1`. Ignored for full references and URLs. Defaults to the namespace of the work item if not provided."
  contextNamespacePath: ID
  "Global ID of the work item."
  id: WorkItemID!
  "Merge request reference (short, full or URL). Example: `!1`, `project_full_path!1` or `https://gitlab.com/gitlab-org/gitlab/-/merge_requests/1`."
  mergeRequestReference: String!
}
"Autogenerated input type of WorkItemAddLinkedItems"
input WorkItemAddLinkedItemsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Type of link. Defaults to `RELATED`."
  linkType: WorkItemRelatedLinkType
  "Global IDs of the items to link. Maximum number of IDs you can provide: 10."
  workItemsIds: [WorkItemID!]!
}
"Autogenerated input type of WorkItemBulkUpdate"
input WorkItemBulkUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID array of the issues that will be updated. IDs that the user can't update will be ignored. A max of 100 can be provided."
  ids: [WorkItemID!]!
  """
  Global ID of the parent to which the bulk update will be scoped. The parent can be a project. The parent can also be a group (Premium and Ultimate only). Example `WorkItemsParentID` are `"gid://gitlab/Project/1"` and `"gid://gitlab/Group/1"`.
  """
  parentId: WorkItemsParentID!
  "Input for labels widget."
  labelsWidget: WorkItemWidgetLabelsUpdateInput
}
"Autogenerated input type of WorkItemConvert"
input WorkItemConvertInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Global ID of the new work item type."
  workItemTypeId: WorkItemsTypeID!
}
input WorkItemConvertTaskInput {
  "Last line in the Markdown source that defines the list item task."
  lineNumberEnd: Int!
  "First line in the Markdown source that defines the list item task."
  lineNumberStart: Int!
  "Current lock version of the work item containing the task in the description."
  lockVersion: Int!
  "Full string of the task to be replaced. New title for the created work item."
  title: String!
  "Global ID of the work item type used to create the new work item."
  workItemTypeId: WorkItemsTypeID!
}
"Autogenerated input type of WorkItemCreateFromTask"
input WorkItemCreateFromTaskInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Arguments necessary to convert a task into a work item."
  workItemData: WorkItemConvertTaskInput!
}
"Autogenerated input type of WorkItemCreate"
input WorkItemCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Input for assignees widget."
  assigneesWidget: WorkItemWidgetAssigneesInput
  "Sets the work item confidentiality."
  confidential: Boolean
  "Input for description widget."
  descriptionWidget: WorkItemWidgetDescriptionInput
  "Input for milestone widget."
  milestoneWidget: WorkItemWidgetMilestoneInput
  "Timestamp when the work item was created. Available only for admins and project owners."
  createdAt: Time
  "Input for CRM contacts widget."
  crmContactsWidget: WorkItemWidgetCrmContactsCreateInput
  "Information required to resolve discussions in a noteable, when the work item is created."
  discussionsToResolve: WorkItemResolveDiscussionsInput
  "Input for hierarchy widget."
  hierarchyWidget: WorkItemWidgetHierarchyCreateInput
  "Input for labels widget."
  labelsWidget: WorkItemWidgetLabelsCreateInput
  "Input for linked items widget."
  linkedItemsWidget: WorkItemWidgetLinkedItemsCreateInput
  "Full path of the namespace(project or group) the work item is created in."
  namespacePath: ID
  "Input for start and due date widget."
  startAndDueDateWidget: WorkItemWidgetStartAndDueDateUpdateInput
  "Title of the work item."
  title: String!
  "Global ID of a work item type."
  workItemTypeId: WorkItemsTypeID!
}
"Autogenerated input type of WorkItemDelete"
input WorkItemDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
}
input WorkItemDescriptionTemplateContentInput {
  "Name of the description template."
  name: String!
  "ID of the project the template belongs to."
  projectId: Int!
}
"Autogenerated input type of WorkItemExport"
input WorkItemExportInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Search query for title or description."
  search: String
  """
  Specify the fields to perform the search in.
  Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
  """
  in: [IssuableSearchableField!]
  "Filter work items by author username."
  authorUsername: String
  "Filter for confidential work items. If `false`, excludes confidential work items. If `true`, returns only confidential work items."
  confidential: Boolean
  "Usernames of users assigned to the work item."
  assigneeUsernames: [String!]
  "Filter by assignee wildcard. Incompatible with `assigneeUsernames`."
  assigneeWildcardId: AssigneeWildcardId
  "Labels applied to the work item."
  labelName: [String!]
  "Milestone applied to the work item."
  milestoneTitle: [String!]
  "Filter by milestone ID wildcard. Incompatible with `milestoneTitle`."
  milestoneWildcardId: MilestoneWildcardId
  "Filter by reaction emoji applied by the current user. Wildcard values `NONE` and `ANY` are supported."
  myReactionEmoji: String
  """
  List of IIDs of work items. For example, `["1", "2"]`.
  """
  iids: [String!]
  "Current state of the work item."
  state: IssuableState
  "Filter work items by the given work item types."
  types: [IssueType!]
  "Work items created before the timestamp."
  createdBefore: Time
  "Work items created after the timestamp."
  createdAfter: Time
  "Work items updated before the timestamp."
  updatedBefore: Time
  "Work items updated after the timestamp."
  updatedAfter: Time
  "Work items due before the timestamp."
  dueBefore: Time
  "Work items due after the timestamp."
  dueAfter: Time
  "Work items closed before the date."
  closedBefore: Time
  "Work items closed after the date."
  closedAfter: Time
  "Work items the current user is subscribed to."
  subscribed: SubscriptionStatus
  "Negated work item arguments."
  not: NegatedWorkItemFilterInput
  "List of arguments with inclusive `OR`."
  or: UnionedWorkItemFilterInput
  "Full project path."
  projectPath: ID!
  "List of selected fields to be exported. Omit to export all available fields."
  selectedFields: [AvailableExportFields!]
}
"Autogenerated input type of WorkItemRemoveLinkedItems"
input WorkItemRemoveLinkedItemsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Global IDs of the items to unlink. Maximum number of IDs you can provide: 10."
  workItemsIds: [WorkItemID!]!
}
input WorkItemResolveDiscussionsInput {
  "ID of a discussion to resolve."
  discussionId: String
  "Global ID of the noteable where discussions will be resolved when the work item is created. Only `MergeRequestID` is supported at the moment."
  noteableId: NoteableID!
}
"Autogenerated input type of WorkItemSubscribe"
input WorkItemSubscribeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Desired state of the subscription."
  subscribed: Boolean!
}
"Autogenerated input type of WorkItemUpdate"
input WorkItemUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Input for assignees widget."
  assigneesWidget: WorkItemWidgetAssigneesInput
  "Sets the work item confidentiality."
  confidential: Boolean
  "Input for description widget."
  descriptionWidget: WorkItemWidgetDescriptionInput
  "Input for milestone widget."
  milestoneWidget: WorkItemWidgetMilestoneInput
  "Input for emoji reactions widget."
  awardEmojiWidget: WorkItemWidgetAwardEmojiUpdateInput
  "Input for CRM contacts widget."
  crmContactsWidget: WorkItemWidgetCrmContactsUpdateInput
  "Input for to-dos widget."
  currentUserTodosWidget: WorkItemWidgetCurrentUserTodosInput
  "Input for hierarchy widget."
  hierarchyWidget: WorkItemWidgetHierarchyUpdateInput
  "Global ID of the work item."
  id: WorkItemID!
  "Input for labels widget."
  labelsWidget: WorkItemWidgetLabelsUpdateInput
  "Input for notes widget."
  notesWidget: WorkItemWidgetNotesInput
  "Input for notifications widget."
  notificationsWidget: WorkItemWidgetNotificationsUpdateInput
  "Input for start and due date widget."
  startAndDueDateWidget: WorkItemWidgetStartAndDueDateUpdateInput
  "Close or reopen a work item."
  stateEvent: WorkItemStateEvent
  "Input for time tracking widget."
  timeTrackingWidget: WorkItemWidgetTimeTrackingInput
  "Title of the work item."
  title: String
}
"Autogenerated input type of WorkItemUserPreferenceUpdate"
input WorkItemUserPreferenceUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the namespace on which the preference is set."
  namespacePath: ID!
  "Global ID of a work item type."
  workItemTypeId: WorkItemsTypeID
  "Sort order for work item lists."
  sort: WorkItemSort = CREATED_ASC
}
input WorkItemWidgetAssigneesInput {
  "Global IDs of assignees."
  assigneeIds: [UserID!]!
}
input WorkItemWidgetAwardEmojiUpdateInput {
  "Action for the update."
  action: WorkItemAwardEmojiUpdateAction!
  "Emoji name."
  name: String!
}
input WorkItemWidgetCrmContactsCreateInput {
  "CRM contact IDs to set."
  contactIds: [CustomerRelationsContactID!]!
}
input WorkItemWidgetCrmContactsUpdateInput {
  "CRM contact IDs to set. Replaces existing contacts by default."
  contactIds: [CustomerRelationsContactID!]!
  "Set the operation mode."
  operationMode: MutationOperationMode = REPLACE
}
input WorkItemWidgetCurrentUserTodosInput {
  "Action for the update."
  action: WorkItemTodoUpdateAction!
  "Global ID of the to-do. If not present, all to-dos of the work item will be updated."
  todoId: TodoID
}
input WorkItemWidgetDescriptionInput {
  "Description of the work item."
  description: String!
}
input WorkItemWidgetHierarchyCreateInput {
  "Global ID of the parent work item."
  parentId: WorkItemID
}
input WorkItemWidgetHierarchyUpdateInput {
  "ID of the work item to be switched with."
  adjacentWorkItemId: WorkItemID
  "Global IDs of children work items."
  childrenIds: [WorkItemID!]
  "Global ID of the parent work item. Use `null` to remove the association."
  parentId: WorkItemID
  "Type of switch. Valid values are `BEFORE` or `AFTER`."
  relativePosition: RelativePositionType
}
input WorkItemWidgetLabelsCreateInput {
  "IDs of labels to be added to the work item."
  labelIds: [LabelID!]!
}
input WorkItemWidgetLabelsUpdateInput {
  "Global IDs of labels to be added to the work item."
  addLabelIds: [LabelID!]
  "Global IDs of labels to be removed from the work item."
  removeLabelIds: [LabelID!]
}
input WorkItemWidgetLinkedItemsCreateInput {
  "Type of link. Defaults to `RELATED`."
  linkType: WorkItemRelatedLinkType
  "Global IDs of the items to link. Maximum number of IDs you can provide: 10."
  workItemsIds: [WorkItemID!]!
}
input WorkItemWidgetMilestoneInput {
  "Milestone to assign to the work item."
  milestoneId: MilestoneID
}
input WorkItemWidgetNotesInput {
  "Discussion lock attribute for notes widget of the work item."
  discussionLocked: Boolean!
}
input WorkItemWidgetNotificationsUpdateInput {
  "Desired state of the subscription."
  subscribed: Boolean!
}
input WorkItemWidgetStartAndDueDateUpdateInput {
  "Due date for the work item."
  dueDate: Date
  "Start date for the work item."
  startDate: Date
}
input WorkItemWidgetTimeTrackingInput {
  "Time estimate for the work item in human readable format. For example: 1h 30m."
  timeEstimate: String
  "Timelog data for time spent on the work item."
  timelog: WorkItemWidgetTimeTrackingTimelogInput
}
input WorkItemWidgetTimeTrackingTimelogInput {
  "Amount of time spent in human readable format. For example: 1h 30m."
  timeSpent: String!
  "Timestamp of when the time tracked was spent at, if not provided would be set to current timestamp."
  spentAt: Time
  "Summary of how the time was spent."
  summary: String
}
"Autogenerated input type of createContainerProtectionTagRule"
input createContainerProtectionTagRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project containing the container image tags."
  projectPath: ID!
  "The pattern that matches container image tags to protect. For example, `v1.*`. Wildcard character `*` allowed. Introduced in GitLab 17.8: **Status**: Experiment."
  tagNamePattern: String!
  "Minimum GitLab access level required to delete container image tags from the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can delete tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForDelete: ContainerProtectionTagRuleAccessLevel
  "Minimum GitLab access level required to push container image tags to the container repository. Valid values include `MAINTAINER`, `OWNER`, or `ADMIN`. If the value is `nil`, no access level can push tags. Introduced in GitLab 17.8: **Status**: Experiment."
  minimumAccessLevelForPush: ContainerProtectionTagRuleAccessLevel
}
"Autogenerated input type of projectBlobsRemove"
input projectBlobsRemoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project to replace."
  projectPath: ID!
  "List of blob oids."
  blobOids: [String!]!
}
"Autogenerated input type of projectTextReplace"
input projectTextReplaceInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project to replace."
  projectPath: ID!
  "List of text patterns to replace project-wide."
  replacements: [String!]!
}
"Autogenerated input type of workItemsHierarchyReorder"
input workItemsHierarchyReorderInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item to be reordered."
  id: WorkItemID!
  "ID of the work item to move next to. For example, the item above or below."
  adjacentWorkItemId: WorkItemID
  "Global ID of the new parent work item."
  parentId: WorkItemID
  "Position relative to the adjacent work item. Valid values are `BEFORE` or `AFTER`."
  relativePosition: RelativePositionType
}
"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT
"Exposes a URL that specifies the behavior of this scalar."
directive @specifiedBy(
    "The URL that specifies the behavior of this scalar."
    url: String!
  ) on SCALAR
